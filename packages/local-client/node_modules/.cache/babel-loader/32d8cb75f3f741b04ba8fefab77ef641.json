{"ast":null,"code":"import produce from \"immer\";\nimport { ActionType } from \"../action-types\";\nconst initialState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {}\n};\nconst reducer = produce(function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case ActionType.UPDATE_CELL:\n      const {\n        id,\n        content\n      } = action.payload;\n      state.data[id].content = content;\n      return;\n\n    case ActionType.DELETE_CELL:\n      // delete cell\n      delete state.data[action.payload]; // delete cell id from order array\n\n      state.order = state.order.filter(id => id !== action.payload);\n      return;\n\n    case ActionType.MOVE_CELL:\n      const {\n        direction\n      } = action.payload; // index of cell\n\n      const index = state.order.findIndex(id => id === action.payload.id); // new index of cell depending on move direction\n\n      const targetId = direction === \"up\" ? index - 1 : index + 1; // ensure new index is within bounds of order array\n\n      if (targetId < 0 || targetId > state.order.length - 1) {\n        return;\n      } // swap\n\n\n      state.order[index] = state.order[targetId];\n      state.order[targetId] = action.payload.id;\n      return;\n\n    case ActionType.INSERT_CELL_BEFORE:\n      const cell = {\n        id: randomId(),\n        type: action.payload.type,\n        content: \"\"\n      }; // insert cell into data array, which contains all the cells and their ids\n\n      state.data[cell.id] = cell; // find index of cell to insert before\n\n      const foundIndex = state.order.findIndex(id => id === action.payload.id);\n\n      if (foundIndex === -1) {\n        state.order.push(cell.id);\n      }\n\n      return;\n\n    default:\n      return state;\n  }\n});\n\nconst randomId = () => {\n  return Math.random().toString(36).substr(2, 5);\n};\n\nexport default reducer;","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/src/state/reducers/cellsReducer.ts"],"names":["produce","ActionType","initialState","loading","error","order","data","reducer","state","action","type","UPDATE_CELL","id","content","payload","DELETE_CELL","filter","MOVE_CELL","direction","index","findIndex","targetId","length","INSERT_CELL_BEFORE","cell","randomId","foundIndex","push","Math","random","toString","substr"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,OAApB;AACA,SAASC,UAAT,QAA2B,iBAA3B;AAaA,MAAMC,YAAwB,GAAG;AAChCC,EAAAA,OAAO,EAAE,KADuB;AAEhCC,EAAAA,KAAK,EAAE,IAFyB;AAGhCC,EAAAA,KAAK,EAAE,EAHyB;AAIhCC,EAAAA,IAAI,EAAE;AAJ0B,CAAjC;AAOA,MAAMC,OAAO,GAAGP,OAAO,CAAC,YAAyE;AAAA,MAAxEQ,KAAwE,uEAApDN,YAAoD;AAAA,MAAtCO,MAAsC;;AAChG,UAAQA,MAAM,CAACC,IAAf;AACC,SAAKT,UAAU,CAACU,WAAhB;AACC,YAAM;AAAEC,QAAAA,EAAF;AAAMC,QAAAA;AAAN,UAAkBJ,MAAM,CAACK,OAA/B;AACAN,MAAAA,KAAK,CAACF,IAAN,CAAWM,EAAX,EAAeC,OAAf,GAAyBA,OAAzB;AACA;;AACD,SAAKZ,UAAU,CAACc,WAAhB;AACC;AACA,aAAOP,KAAK,CAACF,IAAN,CAAWG,MAAM,CAACK,OAAlB,CAAP,CAFD,CAGC;;AACAN,MAAAA,KAAK,CAACH,KAAN,GAAcG,KAAK,CAACH,KAAN,CAAYW,MAAZ,CAAoBJ,EAAD,IAAQA,EAAE,KAAKH,MAAM,CAACK,OAAzC,CAAd;AACA;;AACD,SAAKb,UAAU,CAACgB,SAAhB;AACC,YAAM;AAAEC,QAAAA;AAAF,UAAgBT,MAAM,CAACK,OAA7B,CADD,CAEC;;AACA,YAAMK,KAAK,GAAGX,KAAK,CAACH,KAAN,CAAYe,SAAZ,CAAuBR,EAAD,IAAQA,EAAE,KAAKH,MAAM,CAACK,OAAP,CAAeF,EAApD,CAAd,CAHD,CAIC;;AACA,YAAMS,QAAQ,GAAGH,SAAS,KAAK,IAAd,GAAqBC,KAAK,GAAG,CAA7B,GAAiCA,KAAK,GAAG,CAA1D,CALD,CAMC;;AACA,UAAIE,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAGb,KAAK,CAACH,KAAN,CAAYiB,MAAZ,GAAqB,CAApD,EAAuD;AACtD;AACA,OATF,CAUC;;;AACAd,MAAAA,KAAK,CAACH,KAAN,CAAYc,KAAZ,IAAqBX,KAAK,CAACH,KAAN,CAAYgB,QAAZ,CAArB;AACAb,MAAAA,KAAK,CAACH,KAAN,CAAYgB,QAAZ,IAAwBZ,MAAM,CAACK,OAAP,CAAeF,EAAvC;AACA;;AACD,SAAKX,UAAU,CAACsB,kBAAhB;AACC,YAAMC,IAAU,GAAG;AAClBZ,QAAAA,EAAE,EAAEa,QAAQ,EADM;AAElBf,QAAAA,IAAI,EAAED,MAAM,CAACK,OAAP,CAAeJ,IAFH;AAGlBG,QAAAA,OAAO,EAAE;AAHS,OAAnB,CADD,CAMC;;AACAL,MAAAA,KAAK,CAACF,IAAN,CAAWkB,IAAI,CAACZ,EAAhB,IAAsBY,IAAtB,CAPD,CAQC;;AACA,YAAME,UAAU,GAAGlB,KAAK,CAACH,KAAN,CAAYe,SAAZ,CAAuBR,EAAD,IAAQA,EAAE,KAAKH,MAAM,CAACK,OAAP,CAAeF,EAApD,CAAnB;;AACA,UAAIc,UAAU,KAAK,CAAC,CAApB,EAAuB;AACtBlB,QAAAA,KAAK,CAACH,KAAN,CAAYsB,IAAZ,CAAiBH,IAAI,CAACZ,EAAtB;AACA;;AAED;;AACD;AACC,aAAOJ,KAAP;AAzCF;AA2CA,CA5CsB,CAAvB;;AA8CA,MAAMiB,QAAQ,GAAG,MAAM;AACtB,SAAOG,IAAI,CAACC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,MAA3B,CAAkC,CAAlC,EAAqC,CAArC,CAAP;AACA,CAFD;;AAIA,eAAexB,OAAf","sourcesContent":["import produce from \"immer\";\r\nimport { ActionType } from \"../action-types\";\r\nimport { Action } from \"../actions\";\r\nimport { Cell } from \"../cell\";\r\n\r\ninterface CellsState {\r\n\tloading: boolean;\r\n\terror: string | null;\r\n\torder: string[];\r\n\tdata: {\r\n\t\t[key: string]: Cell;\r\n\t};\r\n}\r\n\r\nconst initialState: CellsState = {\r\n\tloading: false,\r\n\terror: null,\r\n\torder: [],\r\n\tdata: {}\r\n};\r\n\r\nconst reducer = produce((state: CellsState = initialState, action: Action): CellsState | void => {\r\n\tswitch (action.type) {\r\n\t\tcase ActionType.UPDATE_CELL:\r\n\t\t\tconst { id, content } = action.payload;\r\n\t\t\tstate.data[id].content = content;\r\n\t\t\treturn;\r\n\t\tcase ActionType.DELETE_CELL:\r\n\t\t\t// delete cell\r\n\t\t\tdelete state.data[action.payload];\r\n\t\t\t// delete cell id from order array\r\n\t\t\tstate.order = state.order.filter((id) => id !== action.payload);\r\n\t\t\treturn;\r\n\t\tcase ActionType.MOVE_CELL:\r\n\t\t\tconst { direction } = action.payload;\r\n\t\t\t// index of cell\r\n\t\t\tconst index = state.order.findIndex((id) => id === action.payload.id);\r\n\t\t\t// new index of cell depending on move direction\r\n\t\t\tconst targetId = direction === \"up\" ? index - 1 : index + 1;\r\n\t\t\t// ensure new index is within bounds of order array\r\n\t\t\tif (targetId < 0 || targetId > state.order.length - 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// swap\r\n\t\t\tstate.order[index] = state.order[targetId];\r\n\t\t\tstate.order[targetId] = action.payload.id;\r\n\t\t\treturn;\r\n\t\tcase ActionType.INSERT_CELL_BEFORE:\r\n\t\t\tconst cell: Cell = {\r\n\t\t\t\tid: randomId(),\r\n\t\t\t\ttype: action.payload.type,\r\n\t\t\t\tcontent: \"\"\r\n\t\t\t};\r\n\t\t\t// insert cell into data array, which contains all the cells and their ids\r\n\t\t\tstate.data[cell.id] = cell;\r\n\t\t\t// find index of cell to insert before\r\n\t\t\tconst foundIndex = state.order.findIndex((id) => id === action.payload.id);\r\n\t\t\tif (foundIndex === -1) {\r\n\t\t\t\tstate.order.push(cell.id);\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\tdefault:\r\n\t\t\treturn state;\r\n\t}\r\n});\r\n\r\nconst randomId = () => {\r\n\treturn Math.random().toString(36).substr(2, 5);\r\n};\r\n\r\nexport default reducer;\r\n"]},"metadata":{},"sourceType":"module"}