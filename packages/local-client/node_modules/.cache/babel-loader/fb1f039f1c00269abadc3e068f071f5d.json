{"ast":null,"code":"import { saveCells } from \"../action-creators\";\nimport { ActionType } from \"../action-types\";\n// a redux middleware provides a point between an action and the momemnt it reaches the reducer\n// uses: logging, crash reporting, talking to an async API, routing, etc.\n// eg. log every action that happens in the app, together with the state computed after it so that when something goes wrong, we can look back at the log and figure out which action corrupted the state\n// dispatch is destructured from store\nexport const persistMiddleware = _ref => {\n  let {\n    dispatch,\n    getState\n  } = _ref;\n  let timer;\n  return next => {\n    return action => {\n      // dispatch action\n      console.log(\"Dispatching action\", action);\n      next(action); // check incoming action to see if we should saveCells()\n\n      if ([ActionType.MOVE_CELL, ActionType.UPDATE_CELL, ActionType.INSERT_CELL_AFTER, ActionType.DELETE_CELL].includes(action.type)) {\n        if (timer) {\n          clearTimeout(timer);\n        } // debouncing with setTimeout\n\n\n        timer = setTimeout(() => {\n          // have to immediately invoke the function returned from saveCells() as it was used with redux thunk\n          saveCells()(dispatch, getState);\n        }, 250);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/src/state/middlewares/persist-middleware.ts"],"names":["saveCells","ActionType","persistMiddleware","dispatch","getState","timer","next","action","console","log","MOVE_CELL","UPDATE_CELL","INSERT_CELL_AFTER","DELETE_CELL","includes","type","clearTimeout","setTimeout"],"mappings":"AACA,SAASA,SAAT,QAA0B,oBAA1B;AAEA,SAASC,UAAT,QAA2B,iBAA3B;AAGA;AACA;AAEA;AAEA;AACA,OAAO,MAAMC,iBAAiB,GAAG,QAM3B;AAAA,MAN4B;AACjCC,IAAAA,QADiC;AAEjCC,IAAAA;AAFiC,GAM5B;AACL,MAAIC,KAAJ;AACA,SAAQC,IAAD,IAAoC;AAC1C,WAAQC,MAAD,IAAoB;AAC1B;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkCF,MAAlC;AAEAD,MAAAA,IAAI,CAACC,MAAD,CAAJ,CAJ0B,CAK1B;;AACA,UACC,CACCN,UAAU,CAACS,SADZ,EAECT,UAAU,CAACU,WAFZ,EAGCV,UAAU,CAACW,iBAHZ,EAICX,UAAU,CAACY,WAJZ,EAKEC,QALF,CAKWP,MAAM,CAACQ,IALlB,CADD,EAOE;AACD,YAAIV,KAAJ,EAAW;AACVW,UAAAA,YAAY,CAACX,KAAD,CAAZ;AACA,SAHA,CAID;;;AACAA,QAAAA,KAAK,GAAGY,UAAU,CAAC,MAAM;AACxB;AACAjB,UAAAA,SAAS,GAAGG,QAAH,EAAaC,QAAb,CAAT;AACA,SAHiB,EAGf,GAHe,CAAlB;AAIA;AACD,KAvBD;AAwBA,GAzBD;AA0BA,CAlCM","sourcesContent":["import { Dispatch } from \"redux\";\r\nimport { saveCells } from \"../action-creators\";\r\nimport { Action } from \"../actions\";\r\nimport { ActionType } from \"../action-types\";\r\nimport { RootState } from \"..\";\r\n\r\n// a redux middleware provides a point between an action and the momemnt it reaches the reducer\r\n// uses: logging, crash reporting, talking to an async API, routing, etc.\r\n\r\n// eg. log every action that happens in the app, together with the state computed after it so that when something goes wrong, we can look back at the log and figure out which action corrupted the state\r\n\r\n// dispatch is destructured from store\r\nexport const persistMiddleware = ({\r\n\tdispatch,\r\n\tgetState\r\n}: {\r\n\tdispatch: Dispatch<Action>;\r\n\tgetState: () => RootState;\r\n}) => {\r\n\tlet timer: any;\r\n\treturn (next: (action: Action) => void) => {\r\n\t\treturn (action: Action) => {\r\n\t\t\t// dispatch action\r\n\t\t\tconsole.log(\"Dispatching action\", action);\r\n\r\n\t\t\tnext(action);\r\n\t\t\t// check incoming action to see if we should saveCells()\r\n\t\t\tif (\r\n\t\t\t\t[\r\n\t\t\t\t\tActionType.MOVE_CELL,\r\n\t\t\t\t\tActionType.UPDATE_CELL,\r\n\t\t\t\t\tActionType.INSERT_CELL_AFTER,\r\n\t\t\t\t\tActionType.DELETE_CELL\r\n\t\t\t\t].includes(action.type)\r\n\t\t\t) {\r\n\t\t\t\tif (timer) {\r\n\t\t\t\t\tclearTimeout(timer);\r\n\t\t\t\t}\r\n\t\t\t\t// debouncing with setTimeout\r\n\t\t\t\ttimer = setTimeout(() => {\r\n\t\t\t\t\t// have to immediately invoke the function returned from saveCells() as it was used with redux thunk\r\n\t\t\t\t\tsaveCells()(dispatch, getState);\r\n\t\t\t\t}, 250);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}