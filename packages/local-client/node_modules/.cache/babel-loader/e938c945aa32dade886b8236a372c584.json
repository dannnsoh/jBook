{"ast":null,"code":"/**\n * See https://tools.ietf.org/html/rfc4647#section-3.1\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array.<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array.<Range>} Ranges\n * @typedef {function(Tag, Range): boolean} Check\n * @typedef {function(Tag|Tags, Range|Ranges=): Tags} Filter\n * @typedef {function(Tag|Tags, Range|Ranges=): Tag} Lookup\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @type {{\n *   (check: Check, filter: true): Filter\n *   (check: Check, filter?: false): Lookup\n * }}\n */\n// prettier-ignore\nvar factory =\n/**\n * @param {Check} check\n * @param {boolean} [filter=false]\n */\nfunction (check, filter) {\n  return match;\n  /**\n   * @param {Tag|Tags} tags\n   * @param {Range|Ranges} [ranges='*']\n   * @returns {Tag|Tags}\n   */\n\n  function match(tags, ranges) {\n    var left = cast(tags, 'tag');\n    var right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n\n    var matches = [];\n    var rightIndex = -1;\n    /** @type {Range} */\n\n    var range;\n    /** @type {number} */\n\n    var leftIndex;\n    /** @type {Tags} */\n\n    var next;\n\n    while (++rightIndex < right.length) {\n      range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\n\n      if (!filter && range === '*') continue;\n      leftIndex = -1;\n      next = [];\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) return left[leftIndex];\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n\n      left = next;\n    } // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n\n\n    return filter ? matches : undefined;\n  }\n};\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\n\n\nexport var basicFilter = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\n\nexport var extendedFilter = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  // 3.3.2.1\n  var left = tag.split('-');\n  var right = range.split('-');\n  var leftIndex = 0;\n  var rightIndex = 0; // 3.3.2.2\n\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n\n  leftIndex++;\n  rightIndex++; // 3.3.2.3\n\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.B\n\n\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\n\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.D\n\n\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\n\n    leftIndex++;\n  } // 3.3.2.4\n\n\n  return true;\n}, true);\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\nexport var lookup = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  var right = range;\n  /** @type {number} */\n\n  var index;\n  /* eslint-disable-next-line no-constant-condition */\n\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n});\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array.<string>} values\n * @param {string} name\n * @returns {Array.<string>}\n */\n\nfunction cast(values, name) {\n  var value = values && typeof values === 'string' ? [values] : values;\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n\n  return value;\n}","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/node_modules/bcp-47-match/index.js"],"names":["factory","check","filter","match","tags","ranges","left","cast","right","undefined","matches","rightIndex","range","leftIndex","next","length","toLowerCase","push","basicFilter","tag","includes","extendedFilter","split","lookup","index","lastIndexOf","charAt","slice","values","name","value","Error"],"mappings":"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","sourcesContent":["/**\n * See https://tools.ietf.org/html/rfc4647#section-3.1\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array.<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array.<Range>} Ranges\n * @typedef {function(Tag, Range): boolean} Check\n * @typedef {function(Tag|Tags, Range|Ranges=): Tags} Filter\n * @typedef {function(Tag|Tags, Range|Ranges=): Tag} Lookup\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @type {{\n *   (check: Check, filter: true): Filter\n *   (check: Check, filter?: false): Lookup\n * }}\n */\n// prettier-ignore\nvar factory = (\n  /**\n   * @param {Check} check\n   * @param {boolean} [filter=false]\n   */\n  function (check, filter) {\n    return match\n\n    /**\n     * @param {Tag|Tags} tags\n     * @param {Range|Ranges} [ranges='*']\n     * @returns {Tag|Tags}\n     */\n    function match(tags, ranges) {\n      var left = cast(tags, 'tag')\n      var right = cast(\n        ranges === null || ranges === undefined ? '*' : ranges,\n        'range'\n      )\n      /** @type {Tags} */\n      var matches = []\n      var rightIndex = -1\n      /** @type {Range} */\n      var range\n      /** @type {number} */\n      var leftIndex\n      /** @type {Tags} */\n      var next\n\n      while (++rightIndex < right.length) {\n        range = right[rightIndex].toLowerCase()\n\n        // Ignore wildcards in lookup mode.\n        if (!filter && range === '*') continue\n\n        leftIndex = -1\n        next = []\n\n        while (++leftIndex < left.length) {\n          if (check(left[leftIndex].toLowerCase(), range)) {\n            // Exit if this is a lookup and we have a match.\n            if (!filter) return left[leftIndex]\n            matches.push(left[leftIndex])\n          } else {\n            next.push(left[leftIndex])\n          }\n        }\n\n        left = next\n      }\n\n      // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n      // a match, so return `undefined`.\n      return filter ? matches : undefined\n    }\n  }\n)\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport var basicFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    return range === '*' || tag === range || tag.includes(range + '-')\n  },\n  true\n)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport var extendedFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    // 3.3.2.1\n    var left = tag.split('-')\n    var right = range.split('-')\n    var leftIndex = 0\n    var rightIndex = 0\n\n    // 3.3.2.2\n    if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n      return false\n    }\n\n    leftIndex++\n    rightIndex++\n\n    // 3.3.2.3\n    while (rightIndex < right.length) {\n      // 3.3.2.3.A\n      if (right[rightIndex] === '*') {\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.B\n      if (!left[leftIndex]) return false\n\n      // 3.3.2.3.C\n      if (left[leftIndex] === right[rightIndex]) {\n        leftIndex++\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.D\n      if (left[leftIndex].length === 1) return false\n\n      // 3.3.2.3.E\n      leftIndex++\n    }\n\n    // 3.3.2.4\n    return true\n  },\n  true\n)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\nexport var lookup = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    var right = range\n    /** @type {number} */\n    var index\n\n    /* eslint-disable-next-line no-constant-condition */\n    while (true) {\n      if (right === '*' || tag === right) return true\n\n      index = right.lastIndexOf('-')\n\n      if (index < 0) return false\n\n      if (right.charAt(index - 2) === '-') index -= 2\n\n      right = right.slice(0, index)\n    }\n  }\n)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array.<string>} values\n * @param {string} name\n * @returns {Array.<string>}\n */\nfunction cast(values, name) {\n  var value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}