{"ast":null,"code":"import axios from \"axios\";\nimport localforage from \"localforage\";\nconst fileCache = localforage.createInstance({\n  name: \"filecache\"\n});\nexport const unpkgPathPlugin = inputCode => {\n  return {\n    // name is mainly to identify this plugin for debugging purposes\n    name: \"unpkg-path-plugin\",\n\n    // setup of bundling process\n    setup(build) {\n      // onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\n      // can have multiple onResolve functions for different types of files, with the regex filter changing to look for the different types of files\n      // return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\n      // namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\n      // handle root entry file of index.js\n      build.onResolve({\n        filter: /(^index\\.js$)/\n      }, () => {\n        return {\n          path: \"index.js\",\n          namespace: \"a\"\n        };\n      }); // handle relative paths in a module\n\n      build.onResolve({\n        filter: /^\\.+\\//\n      }, async args => {\n        return {\n          namespace: \"a\",\n          path: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\n        };\n      }); // onResolve for root package files\n\n      build.onResolve({\n        filter: /.*/\n      }, async args => {\n        return {\n          namespace: \"a\",\n          path: `https://unpkg.com/${args.path}`\n        };\n      }); // onLoad event listener (override esbuild's default file loading process)\n\n      build.onLoad({\n        filter: /.*/\n      }, async args => {\n        console.log(\"onLoad\", args);\n\n        if (args.path === \"index.js\") {\n          return {\n            loader: \"jsx\",\n            contents: inputCode\n          };\n        } // Check to see if this file has already been fetched and if it is in the cache\n\n\n        const cachedResult = await fileCache.getItem(args.path); // If it is, return it immediately\n\n        if (cachedResult) {\n          return cachedResult;\n        } else {\n          // axios get request to path\n          const {\n            data,\n            request\n          } = await axios.get(args.path);\n          const result = {\n            loader: \"jsx\",\n            contents: data,\n            resolveDir: new URL(\"./\", request.responseURL).pathname\n          }; // store response in cache\n\n          await fileCache.setItem(args.path, result);\n          return result;\n        }\n      });\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/Udemy/React and Typescript (Stephen Grider)/jbook/src/plugins/unpkg-path-plugin.ts"],"names":["axios","localforage","fileCache","createInstance","name","unpkgPathPlugin","inputCode","setup","build","onResolve","filter","path","namespace","args","URL","resolveDir","href","onLoad","console","log","loader","contents","cachedResult","getItem","data","request","get","result","responseURL","pathname","setItem"],"mappings":"AACA,OAAOA,KAAP,MAAqC,OAArC;AACA,OAAOC,WAAP,MAAwB,aAAxB;AAEA,MAAMC,SAAS,GAAGD,WAAW,CAACE,cAAZ,CAA2B;AAC5CC,EAAAA,IAAI,EAAE;AADsC,CAA3B,CAAlB;AAIA,OAAO,MAAMC,eAAe,GAAIC,SAAD,IAAuB;AACrD,SAAO;AACN;AACAF,IAAAA,IAAI,EAAE,mBAFA;;AAGN;AACAG,IAAAA,KAAK,CAACC,KAAD,EAA6B;AACjC;AACA;AACA;AACA;AAEA;AACAA,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAA6C,MAAM;AAClD,eAAO;AAAEC,UAAAA,IAAI,EAAE,UAAR;AAAoBC,UAAAA,SAAS,EAAE;AAA/B,SAAP;AACA,OAFD,EAPiC,CAWjC;;AACAJ,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAAsC,MAAOG,IAAP,IAAqB;AAC1D,eAAO;AACND,UAAAA,SAAS,EAAE,GADL;AAEND,UAAAA,IAAI,EAAE,IAAIG,GAAJ,CAAQD,IAAI,CAACF,IAAb,EAAoB,oBAAmBE,IAAI,CAACE,UAAW,GAAvD,EAA2DC;AAF3D,SAAP;AAIA,OALD,EAZiC,CAkBjC;;AACAR,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAAkC,MAAOG,IAAP,IAAqB;AACtD,eAAO;AACND,UAAAA,SAAS,EAAE,GADL;AAEND,UAAAA,IAAI,EAAG,qBAAoBE,IAAI,CAACF,IAAK;AAF/B,SAAP;AAIA,OALD,EAnBiC,CA0BjC;;AACAH,MAAAA,KAAK,CAACS,MAAN,CAAa;AAAEP,QAAAA,MAAM,EAAE;AAAV,OAAb,EAA+B,MAAOG,IAAP,IAAqB;AACnDK,QAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAAsBN,IAAtB;;AAEA,YAAIA,IAAI,CAACF,IAAL,KAAc,UAAlB,EAA8B;AAC7B,iBAAO;AACNS,YAAAA,MAAM,EAAE,KADF;AAENC,YAAAA,QAAQ,EAAEf;AAFJ,WAAP;AAIA,SARkD,CAUnD;;;AACA,cAAMgB,YAAY,GAAG,MAAMpB,SAAS,CAACqB,OAAV,CAAwCV,IAAI,CAACF,IAA7C,CAA3B,CAXmD,CAYnD;;AACA,YAAIW,YAAJ,EAAkB;AACjB,iBAAOA,YAAP;AACA,SAFD,MAEO;AACN;AACA,gBAAM;AAAEE,YAAAA,IAAF;AAAQC,YAAAA;AAAR,cAAoB,MAAMzB,KAAK,CAAC0B,GAAN,CAAUb,IAAI,CAACF,IAAf,CAAhC;AACA,gBAAMgB,MAA4B,GAAG;AACpCP,YAAAA,MAAM,EAAE,KAD4B;AAEpCC,YAAAA,QAAQ,EAAEG,IAF0B;AAGpCT,YAAAA,UAAU,EAAE,IAAID,GAAJ,CAAQ,IAAR,EAAcW,OAAO,CAACG,WAAtB,EAAmCC;AAHX,WAArC,CAHM,CAQN;;AACA,gBAAM3B,SAAS,CAAC4B,OAAV,CAAkBjB,IAAI,CAACF,IAAvB,EAA6BgB,MAA7B,CAAN;AACA,iBAAOA,MAAP;AACA;AACD,OA3BD;AA4BA;;AA3DK,GAAP;AA6DA,CA9DM","sourcesContent":["import * as esbuild from \"esbuild-wasm\";\r\nimport axios, { AxiosResponse } from \"axios\";\r\nimport localforage from \"localforage\";\r\n\r\nconst fileCache = localforage.createInstance({\r\n\tname: \"filecache\"\r\n});\r\n\r\nexport const unpkgPathPlugin = (inputCode: string) => {\r\n\treturn {\r\n\t\t// name is mainly to identify this plugin for debugging purposes\r\n\t\tname: \"unpkg-path-plugin\",\r\n\t\t// setup of bundling process\r\n\t\tsetup(build: esbuild.PluginBuild) {\r\n\t\t\t// onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\r\n\t\t\t// can have multiple onResolve functions for different types of files, with the regex filter changing to look for the different types of files\r\n\t\t\t// return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\r\n\t\t\t// namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\r\n\r\n\t\t\t// handle root entry file of index.js\r\n\t\t\tbuild.onResolve({ filter: /(^index\\.js$)/ }, () => {\r\n\t\t\t\treturn { path: \"index.js\", namespace: \"a\" };\r\n\t\t\t});\r\n\r\n\t\t\t// handle relative paths in a module\r\n\t\t\tbuild.onResolve({ filter: /^\\.+\\// }, async (args: any) => {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\tpath: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\t// onResolve for root package files\r\n\t\t\tbuild.onResolve({ filter: /.*/ }, async (args: any) => {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\tpath: `https://unpkg.com/${args.path}`\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\t// onLoad event listener (override esbuild's default file loading process)\r\n\t\t\tbuild.onLoad({ filter: /.*/ }, async (args: any) => {\r\n\t\t\t\tconsole.log(\"onLoad\", args);\r\n\r\n\t\t\t\tif (args.path === \"index.js\") {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents: inputCode\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check to see if this file has already been fetched and if it is in the cache\r\n\t\t\t\tconst cachedResult = await fileCache.getItem<esbuild.OnLoadResult>(args.path);\r\n\t\t\t\t// If it is, return it immediately\r\n\t\t\t\tif (cachedResult) {\r\n\t\t\t\t\treturn cachedResult;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// axios get request to path\r\n\t\t\t\t\tconst { data, request } = await axios.get(args.path);\r\n\t\t\t\t\tconst result: esbuild.OnLoadResult = {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents: data,\r\n\t\t\t\t\t\tresolveDir: new URL(\"./\", request.responseURL).pathname\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// store response in cache\r\n\t\t\t\t\tawait fileCache.setItem(args.path, result);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}