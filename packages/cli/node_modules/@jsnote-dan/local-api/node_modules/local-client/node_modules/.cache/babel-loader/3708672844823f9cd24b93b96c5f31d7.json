{"ast":null,"code":"(exports => {\n  var __defProp = Object.defineProperty;\n  var __defProps = Object.defineProperties;\n  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n\n  var __async = (__this, __arguments, generator) => {\n    return new Promise((resolve, reject) => {\n      var fulfilled = value => {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var rejected = value => {\n        try {\n          step(generator.throw(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n      step((generator = generator.apply(__this, __arguments)).next());\n    });\n  }; // lib/npm/browser.ts\n\n\n  __export(exports, {\n    analyzeMetafile: () => analyzeMetafile,\n    analyzeMetafileSync: () => analyzeMetafileSync,\n    build: () => build,\n    buildSync: () => buildSync,\n    formatMessages: () => formatMessages,\n    formatMessagesSync: () => formatMessagesSync,\n    initialize: () => initialize,\n    serve: () => serve,\n    transform: () => transform,\n    transformSync: () => transformSync,\n    version: () => version\n  }); // lib/shared/stdio_protocol.ts\n\n\n  function encodePacket(packet) {\n    let visit = value => {\n      if (value === null) {\n        bb.write8(0);\n      } else if (typeof value === \"boolean\") {\n        bb.write8(1);\n        bb.write8(+value);\n      } else if (typeof value === \"number\") {\n        bb.write8(2);\n        bb.write32(value | 0);\n      } else if (typeof value === \"string\") {\n        bb.write8(3);\n        bb.write(encodeUTF8(value));\n      } else if (value instanceof Uint8Array) {\n        bb.write8(4);\n        bb.write(value);\n      } else if (value instanceof Array) {\n        bb.write8(5);\n        bb.write32(value.length);\n\n        for (let item of value) {\n          visit(item);\n        }\n      } else {\n        let keys = Object.keys(value);\n        bb.write8(6);\n        bb.write32(keys.length);\n\n        for (let key of keys) {\n          bb.write(encodeUTF8(key));\n          visit(value[key]);\n        }\n      }\n    };\n\n    let bb = new ByteBuffer();\n    bb.write32(0);\n    bb.write32(packet.id << 1 | +!packet.isRequest);\n    visit(packet.value);\n    writeUInt32LE(bb.buf, bb.len - 4, 0);\n    return bb.buf.subarray(0, bb.len);\n  }\n\n  function decodePacket(bytes) {\n    let visit = () => {\n      switch (bb.read8()) {\n        case 0:\n          return null;\n\n        case 1:\n          return !!bb.read8();\n\n        case 2:\n          return bb.read32();\n\n        case 3:\n          return decodeUTF8(bb.read());\n\n        case 4:\n          return bb.read();\n\n        case 5:\n          {\n            let count = bb.read32();\n            let value2 = [];\n\n            for (let i = 0; i < count; i++) {\n              value2.push(visit());\n            }\n\n            return value2;\n          }\n\n        case 6:\n          {\n            let count = bb.read32();\n            let value2 = {};\n\n            for (let i = 0; i < count; i++) {\n              value2[decodeUTF8(bb.read())] = visit();\n            }\n\n            return value2;\n          }\n\n        default:\n          throw new Error(\"Invalid packet\");\n      }\n    };\n\n    let bb = new ByteBuffer(bytes);\n    let id = bb.read32();\n    let isRequest = (id & 1) === 0;\n    id >>>= 1;\n    let value = visit();\n\n    if (bb.ptr !== bytes.length) {\n      throw new Error(\"Invalid packet\");\n    }\n\n    return {\n      id,\n      isRequest,\n      value\n    };\n  }\n\n  var ByteBuffer = class {\n    constructor() {\n      let buf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array(1024);\n      this.buf = buf;\n      this.len = 0;\n      this.ptr = 0;\n    }\n\n    _write(delta) {\n      if (this.len + delta > this.buf.length) {\n        let clone = new Uint8Array((this.len + delta) * 2);\n        clone.set(this.buf);\n        this.buf = clone;\n      }\n\n      this.len += delta;\n      return this.len - delta;\n    }\n\n    write8(value) {\n      let offset = this._write(1);\n\n      this.buf[offset] = value;\n    }\n\n    write32(value) {\n      let offset = this._write(4);\n\n      writeUInt32LE(this.buf, value, offset);\n    }\n\n    write(bytes) {\n      let offset = this._write(4 + bytes.length);\n\n      writeUInt32LE(this.buf, bytes.length, offset);\n      this.buf.set(bytes, offset + 4);\n    }\n\n    _read(delta) {\n      if (this.ptr + delta > this.buf.length) {\n        throw new Error(\"Invalid packet\");\n      }\n\n      this.ptr += delta;\n      return this.ptr - delta;\n    }\n\n    read8() {\n      return this.buf[this._read(1)];\n    }\n\n    read32() {\n      return readUInt32LE(this.buf, this._read(4));\n    }\n\n    read() {\n      let length = this.read32();\n      let bytes = new Uint8Array(length);\n\n      let ptr = this._read(bytes.length);\n\n      bytes.set(this.buf.subarray(ptr, ptr + length));\n      return bytes;\n    }\n\n  };\n  var encodeUTF8;\n  var decodeUTF8;\n\n  if (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n    let encoder = new TextEncoder();\n    let decoder = new TextDecoder();\n\n    encodeUTF8 = text => encoder.encode(text);\n\n    decodeUTF8 = bytes => decoder.decode(bytes);\n  } else if (typeof Buffer !== \"undefined\") {\n    encodeUTF8 = text => {\n      let buffer = Buffer.from(text);\n\n      if (!(buffer instanceof Uint8Array)) {\n        buffer = new Uint8Array(buffer);\n      }\n\n      return buffer;\n    };\n\n    decodeUTF8 = bytes => {\n      let {\n        buffer,\n        byteOffset,\n        byteLength\n      } = bytes;\n      return Buffer.from(buffer, byteOffset, byteLength).toString();\n    };\n  } else {\n    throw new Error(\"No UTF-8 codec found\");\n  }\n\n  function readUInt32LE(buffer, offset) {\n    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n  }\n\n  function writeUInt32LE(buffer, value, offset) {\n    buffer[offset++] = value;\n    buffer[offset++] = value >> 8;\n    buffer[offset++] = value >> 16;\n    buffer[offset++] = value >> 24;\n  } // lib/shared/common.ts\n\n\n  function validateTarget(target) {\n    target += \"\";\n    if (target.indexOf(\",\") >= 0) throw new Error(`Invalid target: ${target}`);\n    return target;\n  }\n\n  var canBeAnything = () => null;\n\n  var mustBeBoolean = value => typeof value === \"boolean\" ? null : \"a boolean\";\n\n  var mustBeBooleanOrObject = value => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\n\n  var mustBeString = value => typeof value === \"string\" ? null : \"a string\";\n\n  var mustBeRegExp = value => value instanceof RegExp ? null : \"a RegExp object\";\n\n  var mustBeInteger = value => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\n\n  var mustBeFunction = value => typeof value === \"function\" ? null : \"a function\";\n\n  var mustBeArray = value => Array.isArray(value) ? null : \"an array\";\n\n  var mustBeObject = value => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\n\n  var mustBeArrayOrRecord = value => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\n\n  var mustBeObjectOrNull = value => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\n\n  var mustBeStringOrBoolean = value => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\n\n  var mustBeStringOrObject = value => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\n\n  var mustBeStringOrArray = value => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\n\n  var mustBeStringOrUint8Array = value => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\n\n  function getFlag(object, keys, key, mustBeFn) {\n    let value = object[key];\n    keys[key + \"\"] = true;\n    if (value === void 0) return void 0;\n    let mustBe = mustBeFn(value);\n    if (mustBe !== null) throw new Error(`\"${key}\" must be ${mustBe}`);\n    return value;\n  }\n\n  function checkForInvalidFlags(object, keys, where) {\n    for (let key in object) {\n      if (!(key in keys)) {\n        throw new Error(`Invalid option ${where}: \"${key}\"`);\n      }\n    }\n  }\n\n  function validateInitializeOptions(options) {\n    let keys = Object.create(null);\n    let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n    let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, \"in startService() call\");\n    return {\n      wasmURL,\n      worker\n    };\n  }\n\n  function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n    let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n    if (color !== void 0) flags.push(`--color=${color}`);else if (isTTY) flags.push(`--color=true`);\n    flags.push(`--log-level=${logLevel || logLevelDefault}`);\n    flags.push(`--log-limit=${logLimit || 0}`);\n  }\n\n  function pushCommonFlags(flags, options, keys) {\n    let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n    let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n    let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n    let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n    let format = getFlag(options, keys, \"format\", mustBeString);\n    let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n    let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n    let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n    let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n    let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n    let charset = getFlag(options, keys, \"charset\", mustBeString);\n    let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n    let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n    let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n    let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n    let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n    let define = getFlag(options, keys, \"define\", mustBeObject);\n    let pure = getFlag(options, keys, \"pure\", mustBeArray);\n    let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n    if (legalComments) flags.push(`--legal-comments=${legalComments}`);\n    if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);\n    if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);\n\n    if (target) {\n      if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);else flags.push(`--target=${validateTarget(target)}`);\n    }\n\n    if (format) flags.push(`--format=${format}`);\n    if (globalName) flags.push(`--global-name=${globalName}`);\n    if (minify) flags.push(\"--minify\");\n    if (minifySyntax) flags.push(\"--minify-syntax\");\n    if (minifyWhitespace) flags.push(\"--minify-whitespace\");\n    if (minifyIdentifiers) flags.push(\"--minify-identifiers\");\n    if (charset) flags.push(`--charset=${charset}`);\n    if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);\n    if (ignoreAnnotations) flags.push(`--ignore-annotations`);\n    if (jsx) flags.push(`--jsx=${jsx}`);\n    if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);\n    if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);\n\n    if (define) {\n      for (let key in define) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid define: ${key}`);\n        flags.push(`--define:${key}=${define[key]}`);\n      }\n    }\n\n    if (pure) for (let fn of pure) flags.push(`--pure:${fn}`);\n    if (keepNames) flags.push(`--keep-names`);\n  }\n\n  function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n    var _a;\n\n    let flags = [];\n    let entries = [];\n    let keys = Object.create(null);\n    let stdinContents = null;\n    let stdinResolveDir = null;\n    let watchMode = null;\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n    let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n    let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n    let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n    let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n    let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n    let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n    let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n    let platform = getFlag(options, keys, \"platform\", mustBeString);\n    let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n    let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n    let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n    let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n    let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n    let external = getFlag(options, keys, \"external\", mustBeArray);\n    let loader = getFlag(options, keys, \"loader\", mustBeObject);\n    let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n    let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n    let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n    let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n    let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n    let inject = getFlag(options, keys, \"inject\", mustBeArray);\n    let banner = getFlag(options, keys, \"banner\", mustBeObject);\n    let footer = getFlag(options, keys, \"footer\", mustBeObject);\n    let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n    let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n    let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n    let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n    let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n    let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n    keys.plugins = true;\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n    if (bundle) flags.push(\"--bundle\");\n    if (allowOverwrite) flags.push(\"--allow-overwrite\");\n\n    if (watch) {\n      flags.push(\"--watch\");\n\n      if (typeof watch === \"boolean\") {\n        watchMode = {};\n      } else {\n        let watchKeys = Object.create(null);\n        let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n        checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n        watchMode = {\n          onRebuild\n        };\n      }\n    }\n\n    if (splitting) flags.push(\"--splitting\");\n    if (preserveSymlinks) flags.push(\"--preserve-symlinks\");\n    if (metafile) flags.push(`--metafile`);\n    if (outfile) flags.push(`--outfile=${outfile}`);\n    if (outdir) flags.push(`--outdir=${outdir}`);\n    if (outbase) flags.push(`--outbase=${outbase}`);\n    if (platform) flags.push(`--platform=${platform}`);\n    if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);\n\n    if (resolveExtensions) {\n      let values = [];\n\n      for (let value of resolveExtensions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid resolve extension: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--resolve-extensions=${values.join(\",\")}`);\n    }\n\n    if (publicPath) flags.push(`--public-path=${publicPath}`);\n    if (entryNames) flags.push(`--entry-names=${entryNames}`);\n    if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);\n    if (assetNames) flags.push(`--asset-names=${assetNames}`);\n\n    if (mainFields) {\n      let values = [];\n\n      for (let value of mainFields) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid main field: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--main-fields=${values.join(\",\")}`);\n    }\n\n    if (conditions) {\n      let values = [];\n\n      for (let value of conditions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid condition: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--conditions=${values.join(\",\")}`);\n    }\n\n    if (external) for (let name of external) flags.push(`--external:${name}`);\n\n    if (banner) {\n      for (let type in banner) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid banner file type: ${type}`);\n        flags.push(`--banner:${type}=${banner[type]}`);\n      }\n    }\n\n    if (footer) {\n      for (let type in footer) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid footer file type: ${type}`);\n        flags.push(`--footer:${type}=${footer[type]}`);\n      }\n    }\n\n    if (inject) for (let path of inject) flags.push(`--inject:${path}`);\n\n    if (loader) {\n      for (let ext in loader) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid loader extension: ${ext}`);\n        flags.push(`--loader:${ext}=${loader[ext]}`);\n      }\n    }\n\n    if (outExtension) {\n      for (let ext in outExtension) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid out extension: ${ext}`);\n        flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n      }\n    }\n\n    if (entryPoints) {\n      if (Array.isArray(entryPoints)) {\n        for (let entryPoint of entryPoints) {\n          entries.push([\"\", entryPoint + \"\"]);\n        }\n      } else {\n        for (let [key, value] of Object.entries(entryPoints)) {\n          entries.push([key + \"\", value + \"\"]);\n        }\n      }\n    }\n\n    if (stdin) {\n      let stdinKeys = Object.create(null);\n      let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeString);\n      let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n      let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n      let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n      checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n      if (loader2) flags.push(`--loader=${loader2}`);\n      if (resolveDir) stdinResolveDir = resolveDir + \"\";\n      stdinContents = contents ? contents + \"\" : \"\";\n    }\n\n    let nodePaths = [];\n\n    if (nodePathsInput) {\n      for (let value of nodePathsInput) {\n        value += \"\";\n        nodePaths.push(value);\n      }\n    }\n\n    return {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch: watchMode\n    };\n  }\n\n  function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n    let flags = [];\n    let keys = Object.create(null);\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n    let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n    let loader = getFlag(options, keys, \"loader\", mustBeString);\n    let banner = getFlag(options, keys, \"banner\", mustBeString);\n    let footer = getFlag(options, keys, \"footer\", mustBeString);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n    if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n    if (loader) flags.push(`--loader=${loader}`);\n    if (banner) flags.push(`--banner=${banner}`);\n    if (footer) flags.push(`--footer=${footer}`);\n    return flags;\n  }\n\n  function createChannel(streamIn) {\n    let responseCallbacks = new Map();\n    let pluginCallbacks = new Map();\n    let watchCallbacks = new Map();\n    let serveCallbacks = new Map();\n    let nextServeID = 0;\n    let isClosed = false;\n    let nextRequestID = 0;\n    let nextBuildKey = 0;\n    let stdout = new Uint8Array(16 * 1024);\n    let stdoutUsed = 0;\n\n    let readFromStdout = chunk => {\n      let limit = stdoutUsed + chunk.length;\n\n      if (limit > stdout.length) {\n        let swap = new Uint8Array(limit * 2);\n        swap.set(stdout);\n        stdout = swap;\n      }\n\n      stdout.set(chunk, stdoutUsed);\n      stdoutUsed += chunk.length;\n      let offset = 0;\n\n      while (offset + 4 <= stdoutUsed) {\n        let length = readUInt32LE(stdout, offset);\n\n        if (offset + 4 + length > stdoutUsed) {\n          break;\n        }\n\n        offset += 4;\n        handleIncomingPacket(stdout.subarray(offset, offset + length));\n        offset += length;\n      }\n\n      if (offset > 0) {\n        stdout.copyWithin(0, offset, stdoutUsed);\n        stdoutUsed -= offset;\n      }\n    };\n\n    let afterClose = () => {\n      isClosed = true;\n\n      for (let callback of responseCallbacks.values()) {\n        callback(\"The service was stopped\", null);\n      }\n\n      responseCallbacks.clear();\n\n      for (let callbacks of serveCallbacks.values()) {\n        callbacks.onWait(\"The service was stopped\");\n      }\n\n      serveCallbacks.clear();\n\n      for (let callback of watchCallbacks.values()) {\n        try {\n          callback(new Error(\"The service was stopped\"), null);\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      watchCallbacks.clear();\n    };\n\n    let sendRequest = (refs, value, callback) => {\n      if (isClosed) return callback(\"The service is no longer running\", null);\n      let id = nextRequestID++;\n      responseCallbacks.set(id, (error, response) => {\n        try {\n          callback(error, response);\n        } finally {\n          if (refs) refs.unref();\n        }\n      });\n      if (refs) refs.ref();\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: true,\n        value\n      }));\n    };\n\n    let sendResponse = (id, value) => {\n      if (isClosed) throw new Error(\"The service is no longer running\");\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: false,\n        value\n      }));\n    };\n\n    let handleRequest = (id, request) => __async(this, null, function* () {\n      try {\n        switch (request.command) {\n          case \"ping\":\n            {\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"start\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"resolve\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"load\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"serve-request\":\n            {\n              let callbacks = serveCallbacks.get(request.serveID);\n              if (callbacks && callbacks.onRequest) callbacks.onRequest(request.args);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"serve-wait\":\n            {\n              let callbacks = serveCallbacks.get(request.serveID);\n              if (callbacks) callbacks.onWait(request.error);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"watch-rebuild\":\n            {\n              let callback = watchCallbacks.get(request.watchID);\n\n              try {\n                if (callback) callback(null, request.args);\n              } catch (err) {\n                console.error(err);\n              }\n\n              sendResponse(id, {});\n              break;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      } catch (e) {\n        sendResponse(id, {\n          errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")]\n        });\n      }\n    });\n\n    let isFirstPacket = true;\n\n    let handleIncomingPacket = bytes => {\n      if (isFirstPacket) {\n        isFirstPacket = false;\n        let binaryVersion = String.fromCharCode(...bytes);\n\n        if (binaryVersion !== \"0.13.13\") {\n          throw new Error(`Cannot start service: Host version \"${\"0.13.13\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n        }\n\n        return;\n      }\n\n      let packet = decodePacket(bytes);\n\n      if (packet.isRequest) {\n        handleRequest(packet.id, packet.value);\n      } else {\n        let callback = responseCallbacks.get(packet.id);\n        responseCallbacks.delete(packet.id);\n        if (packet.value.error) callback(packet.value.error, {});else callback(null, packet.value);\n      }\n    };\n\n    let handlePlugins = (initialOptions, plugins, buildKey, stash) => __async(this, null, function* () {\n      let onStartCallbacks = [];\n      let onEndCallbacks = [];\n      let onResolveCallbacks = {};\n      let onLoadCallbacks = {};\n      let nextCallbackID = 0;\n      let i = 0;\n      let requestPlugins = [];\n      plugins = [...plugins];\n\n      for (let item of plugins) {\n        let keys = {};\n        if (typeof item !== \"object\") throw new Error(`Plugin at index ${i} must be an object`);\n        let name = getFlag(item, keys, \"name\", mustBeString);\n        if (typeof name !== \"string\" || name === \"\") throw new Error(`Plugin at index ${i} is missing a name`);\n\n        try {\n          let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n          if (typeof setup !== \"function\") throw new Error(`Plugin is missing a setup function`);\n          checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n          let plugin = {\n            name,\n            onResolve: [],\n            onLoad: []\n          };\n          i++;\n          let promise = setup({\n            initialOptions,\n\n            onStart(callback2) {\n              let registeredText = `This error came from the \"onStart\" callback registered here`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n              onStartCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onEnd(callback2) {\n              let registeredText = `This error came from the \"onEnd\" callback registered here`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n              onEndCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onResolve(options, callback2) {\n              let registeredText = `This error came from the \"onResolve\" callback registered here`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onResolve() call is missing a filter`);\n              let id = nextCallbackID++;\n              onResolveCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onResolve.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            },\n\n            onLoad(options, callback2) {\n              let registeredText = `This error came from the \"onLoad\" callback registered here`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onLoad() call is missing a filter`);\n              let id = nextCallbackID++;\n              onLoadCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onLoad.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            }\n\n          });\n          if (promise) yield promise;\n          requestPlugins.push(plugin);\n        } catch (e) {\n          return {\n            ok: false,\n            error: e,\n            pluginName: name\n          };\n        }\n      }\n\n      const callback = request => __async(this, null, function* () {\n        switch (request.command) {\n          case \"start\":\n            {\n              let response = {\n                errors: [],\n                warnings: []\n              };\n              yield Promise.all(onStartCallbacks.map(_0 => __async(this, [_0], function* (_ref) {\n                let {\n                  name,\n                  callback: callback2,\n                  note\n                } = _ref;\n\n                try {\n                  let result = yield callback2();\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                    if (errors != null) response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                    if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n                  }\n                } catch (e) {\n                  response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n                }\n              })));\n              return response;\n            }\n\n          case \"resolve\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onResolveCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    importer: request.importer,\n                    namespace: request.namespace,\n                    resolveDir: request.resolveDir,\n                    kind: request.kind,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let path = getFlag(result, keys, \"path\", mustBeString);\n                    let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                    let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                    let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (path != null) response.path = path;\n                    if (namespace != null) response.namespace = namespace;\n                    if (external != null) response.external = external;\n                    if (sideEffects != null) response.sideEffects = sideEffects;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          case \"load\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onLoadCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    namespace: request.namespace,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                    let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let loader = getFlag(result, keys, \"loader\", mustBeString);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (contents instanceof Uint8Array) response.contents = contents;else if (contents != null) response.contents = encodeUTF8(contents);\n                    if (resolveDir != null) response.resolveDir = resolveDir;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (loader != null) response.loader = loader;\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      });\n\n      let runOnEndCallbacks = (result, logPluginError, done) => done();\n\n      if (onEndCallbacks.length > 0) {\n        runOnEndCallbacks = (result, logPluginError, done) => {\n          (() => __async(this, null, function* () {\n            for (const {\n              name,\n              callback: callback2,\n              note\n            } of onEndCallbacks) {\n              try {\n                yield callback2(result);\n              } catch (e) {\n                result.errors.push(yield new Promise(resolve => logPluginError(e, name, note && note(), resolve)));\n              }\n            }\n          }))().then(done);\n        };\n      }\n\n      let refCount = 0;\n      return {\n        ok: true,\n        requestPlugins,\n        runOnEndCallbacks,\n        pluginRefs: {\n          ref() {\n            if (++refCount === 1) pluginCallbacks.set(buildKey, callback);\n          },\n\n          unref() {\n            if (--refCount === 0) pluginCallbacks.delete(buildKey);\n          }\n\n        }\n      };\n    });\n\n    let buildServeData = (refs, options, request) => {\n      let keys = {};\n      let port = getFlag(options, keys, \"port\", mustBeInteger);\n      let host = getFlag(options, keys, \"host\", mustBeString);\n      let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n      let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n      let serveID = nextServeID++;\n      let onWait;\n      let wait = new Promise((resolve, reject) => {\n        onWait = error => {\n          serveCallbacks.delete(serveID);\n          if (error !== null) reject(new Error(error));else resolve();\n        };\n      });\n      request.serve = {\n        serveID\n      };\n      checkForInvalidFlags(options, keys, `in serve() call`);\n      if (port !== void 0) request.serve.port = port;\n      if (host !== void 0) request.serve.host = host;\n      if (servedir !== void 0) request.serve.servedir = servedir;\n      serveCallbacks.set(serveID, {\n        onRequest,\n        onWait\n      });\n      return {\n        wait,\n\n        stop() {\n          sendRequest(refs, {\n            command: \"serve-stop\",\n            serveID\n          }, () => {});\n        }\n\n      };\n    };\n\n    const buildLogLevelDefault = \"warning\";\n    const transformLogLevelDefault = \"silent\";\n\n    let buildOrServe = args => {\n      let key = nextBuildKey++;\n      const details = createObjectStash();\n      let plugins;\n      let {\n        refs,\n        options,\n        isTTY,\n        callback\n      } = args;\n\n      if (typeof options === \"object\") {\n        let value = options.plugins;\n\n        if (value !== void 0) {\n          if (!Array.isArray(value)) throw new Error(`\"plugins\" must be an array`);\n          plugins = value;\n        }\n      }\n\n      let logPluginError = (e, pluginName, note, done) => {\n        let flags = [];\n\n        try {\n          pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n        } catch (e2) {}\n\n        const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n        sendRequest(refs, {\n          command: \"error\",\n          flags,\n          error: message\n        }, () => {\n          message.detail = details.load(message.detail);\n          done(message);\n        });\n      };\n\n      let handleError = (e, pluginName) => {\n        logPluginError(e, pluginName, void 0, error => {\n          callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n        });\n      };\n\n      if (plugins && plugins.length > 0) {\n        if (streamIn.isSync) return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n        handlePlugins(options, plugins, key, details).then(result => {\n          if (!result.ok) {\n            handleError(result.error, result.pluginName);\n          } else {\n            try {\n              buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n                key,\n                details,\n                logPluginError,\n                requestPlugins: result.requestPlugins,\n                runOnEndCallbacks: result.runOnEndCallbacks,\n                pluginRefs: result.pluginRefs\n              }));\n            } catch (e) {\n              handleError(e, \"\");\n            }\n          }\n        }, e => handleError(e, \"\"));\n      } else {\n        try {\n          buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n            key,\n            details,\n            logPluginError,\n            requestPlugins: null,\n            runOnEndCallbacks: (result, logPluginError2, done) => done(),\n            pluginRefs: null\n          }));\n        } catch (e) {\n          handleError(e, \"\");\n        }\n      }\n    };\n\n    let buildOrServeContinue = _ref2 => {\n      let {\n        callName,\n        refs: callerRefs,\n        serveOptions,\n        options,\n        isTTY,\n        defaultWD,\n        callback,\n        key,\n        details,\n        logPluginError,\n        requestPlugins,\n        runOnEndCallbacks,\n        pluginRefs\n      } = _ref2;\n      const refs = {\n        ref() {\n          if (pluginRefs) pluginRefs.ref();\n          if (callerRefs) callerRefs.ref();\n        },\n\n        unref() {\n          if (pluginRefs) pluginRefs.unref();\n          if (callerRefs) callerRefs.unref();\n        }\n\n      };\n      let writeDefault = !streamIn.isBrowser;\n      let {\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir,\n        incremental,\n        nodePaths,\n        watch\n      } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n      let request = {\n        command: \"build\",\n        key,\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir: absWorkingDir || defaultWD,\n        incremental,\n        nodePaths\n      };\n      if (requestPlugins) request.plugins = requestPlugins;\n      let serve2 = serveOptions && buildServeData(refs, serveOptions, request);\n      let rebuild;\n      let stop;\n\n      let copyResponseToResult = (response, result) => {\n        if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);\n        if (response.metafile) result.metafile = JSON.parse(response.metafile);\n        if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n      };\n\n      let buildResponseToResult = (response, callback2) => {\n        let result = {\n          errors: replaceDetailsInMessages(response.errors, details),\n          warnings: replaceDetailsInMessages(response.warnings, details)\n        };\n        copyResponseToResult(response, result);\n        runOnEndCallbacks(result, logPluginError, () => {\n          if (result.errors.length > 0) {\n            return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n          }\n\n          if (response.rebuildID !== void 0) {\n            if (!rebuild) {\n              let isDisposed = false;\n\n              rebuild = () => new Promise((resolve, reject) => {\n                if (isDisposed || isClosed) throw new Error(\"Cannot rebuild\");\n                sendRequest(refs, {\n                  command: \"rebuild\",\n                  rebuildID: response.rebuildID\n                }, (error2, response2) => {\n                  if (error2) {\n                    const message = {\n                      pluginName: \"\",\n                      text: error2,\n                      location: null,\n                      notes: [],\n                      detail: void 0\n                    };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3) reject(error3);else resolve(result3);\n                  });\n                });\n              });\n\n              refs.ref();\n\n              rebuild.dispose = () => {\n                if (isDisposed) return;\n                isDisposed = true;\n                sendRequest(refs, {\n                  command: \"rebuild-dispose\",\n                  rebuildID: response.rebuildID\n                }, () => {});\n                refs.unref();\n              };\n            }\n\n            result.rebuild = rebuild;\n          }\n\n          if (response.watchID !== void 0) {\n            if (!stop) {\n              let isStopped = false;\n              refs.ref();\n\n              stop = () => {\n                if (isStopped) return;\n                isStopped = true;\n                watchCallbacks.delete(response.watchID);\n                sendRequest(refs, {\n                  command: \"watch-stop\",\n                  watchID: response.watchID\n                }, () => {});\n                refs.unref();\n              };\n\n              if (watch) {\n                watchCallbacks.set(response.watchID, (serviceStopError, watchResponse) => {\n                  if (serviceStopError) {\n                    if (watch.onRebuild) watch.onRebuild(serviceStopError, null);\n                    return;\n                  }\n\n                  let result2 = {\n                    errors: replaceDetailsInMessages(watchResponse.errors, details),\n                    warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                  };\n                  copyResponseToResult(watchResponse, result2);\n                  runOnEndCallbacks(result2, logPluginError, () => {\n                    if (result2.errors.length > 0) {\n                      if (watch.onRebuild) watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                      return;\n                    }\n\n                    if (watchResponse.rebuildID !== void 0) result2.rebuild = rebuild;\n                    result2.stop = stop;\n                    if (watch.onRebuild) watch.onRebuild(null, result2);\n                  });\n                });\n              }\n            }\n\n            result.stop = stop;\n          }\n\n          callback2(null, result);\n        });\n      };\n\n      if (write && streamIn.isBrowser) throw new Error(`Cannot enable \"write\" in the browser`);\n      if (incremental && streamIn.isSync) throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n      if (watch && streamIn.isSync) throw new Error(`Cannot use \"watch\" with a synchronous build`);\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n\n        if (serve2) {\n          let serveResponse = response;\n          let isStopped = false;\n          refs.ref();\n          let result = {\n            port: serveResponse.port,\n            host: serveResponse.host,\n            wait: serve2.wait,\n\n            stop() {\n              if (isStopped) return;\n              isStopped = true;\n              serve2.stop();\n              refs.unref();\n            }\n\n          };\n          refs.ref();\n          serve2.wait.then(refs.unref, refs.unref);\n          return callback(null, result);\n        }\n\n        return buildResponseToResult(response, callback);\n      });\n    };\n\n    let transform2 = _ref3 => {\n      let {\n        callName,\n        refs,\n        input,\n        options,\n        isTTY,\n        fs,\n        callback\n      } = _ref3;\n      const details = createObjectStash();\n\n      let start = inputPath => {\n        try {\n          if (typeof input !== \"string\") throw new Error('The input to \"transform\" must be a string');\n          let flags = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n          let request = {\n            command: \"transform\",\n            flags,\n            inputFS: inputPath !== null,\n            input: inputPath !== null ? inputPath : input\n          };\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            let errors = replaceDetailsInMessages(response.errors, details);\n            let warnings = replaceDetailsInMessages(response.warnings, details);\n            let outstanding = 1;\n\n            let next = () => --outstanding === 0 && callback(null, {\n              warnings,\n              code: response.code,\n              map: response.map\n            });\n\n            if (errors.length > 0) return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n\n            if (response.codeFS) {\n              outstanding++;\n              fs.readFile(response.code, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.code = contents;\n                  next();\n                }\n              });\n            }\n\n            if (response.mapFS) {\n              outstanding++;\n              fs.readFile(response.map, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.map = contents;\n                  next();\n                }\n              });\n            }\n\n            next();\n          });\n        } catch (e) {\n          let flags = [];\n\n          try {\n            pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n          } catch (e2) {}\n\n          const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n          sendRequest(refs, {\n            command: \"error\",\n            flags,\n            error\n          }, () => {\n            error.detail = details.load(error.detail);\n            callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n          });\n        }\n      };\n\n      if (typeof input === \"string\" && input.length > 1024 * 1024) {\n        let next = start;\n\n        start = () => fs.writeFile(input, next);\n      }\n\n      start(null);\n    };\n\n    let formatMessages2 = _ref4 => {\n      let {\n        callName,\n        refs,\n        messages,\n        options,\n        callback\n      } = _ref4;\n      let result = sanitizeMessages(messages, \"messages\", null, \"\");\n      if (!options) throw new Error(`Missing second argument in ${callName}() call`);\n      let keys = {};\n      let kind = getFlag(options, keys, \"kind\", mustBeString);\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      if (kind === void 0) throw new Error(`Missing \"kind\" in ${callName}() call`);\n      if (kind !== \"error\" && kind !== \"warning\") throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n      let request = {\n        command: \"format-msgs\",\n        messages: result,\n        isWarning: kind === \"warning\"\n      };\n      if (color !== void 0) request.color = color;\n      if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.messages);\n      });\n    };\n\n    let analyzeMetafile2 = _ref5 => {\n      let {\n        callName,\n        refs,\n        metafile,\n        options,\n        callback\n      } = _ref5;\n      if (options === void 0) options = {};\n      let keys = {};\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      let request = {\n        command: \"analyze-metafile\",\n        metafile\n      };\n      if (color !== void 0) request.color = color;\n      if (verbose !== void 0) request.verbose = verbose;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.result);\n      });\n    };\n\n    return {\n      readFromStdout,\n      afterClose,\n      service: {\n        buildOrServe,\n        transform: transform2,\n        formatMessages: formatMessages2,\n        analyzeMetafile: analyzeMetafile2\n      }\n    };\n  }\n\n  function createObjectStash() {\n    const map = new Map();\n    let nextID = 0;\n    return {\n      load(id) {\n        return map.get(id);\n      },\n\n      store(value) {\n        if (value === void 0) return -1;\n        const id = nextID++;\n        map.set(id, value);\n        return id;\n      }\n\n    };\n  }\n\n  function extractCallerV8(e, streamIn, ident) {\n    let note;\n    let tried = false;\n    return () => {\n      if (tried) return note;\n      tried = true;\n\n      try {\n        let lines = (e.stack + \"\").split(\"\\n\");\n        lines.splice(1, 1);\n        let location = parseStackLinesV8(streamIn, lines, ident);\n\n        if (location) {\n          note = {\n            text: e.message,\n            location\n          };\n          return note;\n        }\n      } catch (e2) {}\n    };\n  }\n\n  function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n    let text = \"Internal error\";\n    let location = null;\n\n    try {\n      text = (e && e.message || e) + \"\";\n    } catch (e2) {}\n\n    try {\n      location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n    } catch (e2) {}\n\n    return {\n      pluginName,\n      text,\n      location,\n      notes: note ? [note] : [],\n      detail: stash ? stash.store(e) : -1\n    };\n  }\n\n  function parseStackLinesV8(streamIn, lines, ident) {\n    let at = \"    at \";\n\n    if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n      for (let i = 1; i < lines.length; i++) {\n        let line = lines[i];\n        if (!line.startsWith(at)) continue;\n        line = line.slice(at.length);\n\n        while (true) {\n          let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n\n          if (match) {\n            let contents;\n\n            try {\n              contents = streamIn.readFileSync(match[1], \"utf8\");\n            } catch (e) {\n              break;\n            }\n\n            let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n            let column = +match[3] - 1;\n            let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n            return {\n              file: match[1],\n              namespace: \"file\",\n              line: +match[2],\n              column: encodeUTF8(lineText.slice(0, column)).length,\n              length: encodeUTF8(lineText.slice(column, column + length)).length,\n              lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n              suggestion: \"\"\n            };\n          }\n\n          break;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function failureErrorWithLog(text, errors, warnings) {\n    let limit = 5;\n    let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n      if (i === limit) return \"\\n...\";\n      if (!e.location) return `\nerror: ${e.text}`;\n      let {\n        file,\n        line,\n        column\n      } = e.location;\n      let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n      return `\n${file}:${line}:${column}: error: ${pluginText}${e.text}`;\n    }).join(\"\");\n    let error = new Error(`${text}${summary}`);\n    error.errors = errors;\n    error.warnings = warnings;\n    return error;\n  }\n\n  function replaceDetailsInMessages(messages, stash) {\n    for (const message of messages) {\n      message.detail = stash.load(message.detail);\n    }\n\n    return messages;\n  }\n\n  function sanitizeLocation(location, where) {\n    if (location == null) return null;\n    let keys = {};\n    let file = getFlag(location, keys, \"file\", mustBeString);\n    let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n    let line = getFlag(location, keys, \"line\", mustBeInteger);\n    let column = getFlag(location, keys, \"column\", mustBeInteger);\n    let length = getFlag(location, keys, \"length\", mustBeInteger);\n    let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n    let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n    checkForInvalidFlags(location, keys, where);\n    return {\n      file: file || \"\",\n      namespace: namespace || \"\",\n      line: line || 0,\n      column: column || 0,\n      length: length || 0,\n      lineText: lineText || \"\",\n      suggestion: suggestion || \"\"\n    };\n  }\n\n  function sanitizeMessages(messages, property, stash, fallbackPluginName) {\n    let messagesClone = [];\n    let index = 0;\n\n    for (const message of messages) {\n      let keys = {};\n      let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n      let text = getFlag(message, keys, \"text\", mustBeString);\n      let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n      let notes = getFlag(message, keys, \"notes\", mustBeArray);\n      let detail = getFlag(message, keys, \"detail\", canBeAnything);\n      let where = `in element ${index} of \"${property}\"`;\n      checkForInvalidFlags(message, keys, where);\n      let notesClone = [];\n\n      if (notes) {\n        for (const note of notes) {\n          let noteKeys = {};\n          let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n          let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n          checkForInvalidFlags(note, noteKeys, where);\n          notesClone.push({\n            text: noteText || \"\",\n            location: sanitizeLocation(noteLocation, where)\n          });\n        }\n      }\n\n      messagesClone.push({\n        pluginName: pluginName || fallbackPluginName,\n        text: text || \"\",\n        location: sanitizeLocation(location, where),\n        notes: notesClone,\n        detail: stash ? stash.store(detail) : -1\n      });\n      index++;\n    }\n\n    return messagesClone;\n  }\n\n  function sanitizeStringArray(values, property) {\n    const result = [];\n\n    for (const value of values) {\n      if (typeof value !== \"string\") throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n      result.push(value);\n    }\n\n    return result;\n  }\n\n  function convertOutputFiles(_ref6) {\n    let {\n      path,\n      contents\n    } = _ref6;\n    let text = null;\n    return {\n      path,\n      contents,\n\n      get text() {\n        if (text === null) text = decodeUTF8(contents);\n        return text;\n      }\n\n    };\n  } // lib/npm/browser.ts\n\n\n  var version = \"0.13.13\";\n\n  var build = options => ensureServiceIsRunning().build(options);\n\n  var serve = () => {\n    throw new Error(`The \"serve\" API only works in node`);\n  };\n\n  var transform = (input, options) => ensureServiceIsRunning().transform(input, options);\n\n  var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\n\n  var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\n\n  var buildSync = () => {\n    throw new Error(`The \"buildSync\" API only works in node`);\n  };\n\n  var transformSync = () => {\n    throw new Error(`The \"transformSync\" API only works in node`);\n  };\n\n  var formatMessagesSync = () => {\n    throw new Error(`The \"formatMessagesSync\" API only works in node`);\n  };\n\n  var analyzeMetafileSync = () => {\n    throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n  };\n\n  var initializePromise;\n  var longLivedService;\n\n  var ensureServiceIsRunning = () => {\n    if (longLivedService) return longLivedService;\n    if (initializePromise) throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n    throw new Error('You need to call \"initialize\" before calling this');\n  };\n\n  var initialize = options => {\n    options = validateInitializeOptions(options || {});\n    let wasmURL = options.wasmURL;\n    let useWorker = options.worker !== false;\n    if (!wasmURL) throw new Error('Must provide the \"wasmURL\" option');\n    wasmURL += \"\";\n    if (initializePromise) throw new Error('Cannot call \"initialize\" more than once');\n    initializePromise = startRunningService(wasmURL, useWorker);\n    initializePromise.catch(() => {\n      initializePromise = void 0;\n    });\n    return initializePromise;\n  };\n\n  var startRunningService = (wasmURL, useWorker) => __async(void 0, null, function* () {\n    let res = yield fetch(wasmURL);\n    if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n    let wasm = yield res.arrayBuffer();\n    let code = `{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\t// - Webpack\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tconst fs = require(\"fs\");\n\t\tif (typeof fs === \"object\" && fs !== null && Object.keys(fs).length !== 0) {\n\t\t\t\n    global.fs = Object.assign({}, fs, {\n      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550\n      write(fd, buf, offset, length, position, callback) {\n        if (offset === 0 && length === buf.length && position === null) {\n          if (fd === process.stdout.fd) {\n            try {\n              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n          if (fd === process.stderr.fd) {\n            try {\n              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n        }\n        fs.write(fd, buf, offset, length, position, callback);\n      },\n    });\n  \n\t\t}\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto && global.require) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\tif (!global.crypto) {\n\t\tthrow new Error(\"global.crypto is not available, polyfill required (getRandomValues only)\");\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder && global.require) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\tif (!global.TextEncoder) {\n\t\tthrow new Error(\"global.TextEncoder is not available, polyfill required\");\n\t}\n\n\tif (!global.TextDecoder && global.require) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\tif (!global.TextDecoder) {\n\t\tthrow new Error(\"global.TextDecoder is not available, polyfill required\");\n\t}\n\n\t// End of polyfills for common API.\n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis.argv = [\"js\"];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = (code) => {\n\t\t\t\tif (code !== 0) {\n\t\t\t\t\tconsole.warn(\"exit code:\", code);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise((resolve) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t});\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tthis.mem.setUint32(addr + 0, v, true);\n\t\t\t\tthis.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = this.mem.getUint32(addr + 0, true);\n\t\t\t\tconst high = this.mem.getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = this.mem.getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = this.mem.getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\" && v !== 0) {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tthis.mem.setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tthis.mem.setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.mem.setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tthis.mem.setFloat64(addr, 0, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tthis.mem.setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn new Uint8Array(this._inst.exports.mem.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (addr) => {\n\t\t\t\tconst saddr = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst code = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._goRefCounts;\n\t\t\t\t\t\tdelete this._ids;\n\t\t\t\t\t\tdelete this._idPool;\n\t\t\t\t\t\tthis.exit(code);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst fd = getInt64(sp + 8);\n\t\t\t\t\t\tconst p = getInt64(sp + 16);\n\t\t\t\t\t\tconst n = this.mem.getInt32(sp + 24, true);\n\t\t\t\t\t\tfs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func resetMemoryDataView()\n\t\t\t\t\t\"runtime.resetMemoryDataView\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime1() int64\n\t\t\t\t\t\"runtime.nanotime1\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst msec = (new Date).getTime();\n\t\t\t\t\t\tsetInt64(sp + 8, msec / 1000);\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set(id, setTimeout(\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\twhile (this._scheduledTimeouts.has(id)) {\n\t\t\t\t\t\t\t\t\t// for some reason Go failed to register the timeout event, log and try again\n\t\t\t\t\t\t\t\t\t// (temporary workaround for https://github.com/golang/go/issues/28975)\n\t\t\t\t\t\t\t\t\tconsole.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\t\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, id, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tclearTimeout(this._scheduledTimeouts.get(id));\n\t\t\t\t\t\tthis._scheduledTimeouts.delete(id);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getUint32(sp + 8, true);\n\t\t\t\t\t\tthis._goRefCounts[id]--;\n\t\t\t\t\t\tif (this._goRefCounts[id] === 0) {\n\t\t\t\t\t\t\tconst v = this._values[id];\n\t\t\t\t\t\t\tthis._values[id] = null;\n\t\t\t\t\t\t\tthis._ids.delete(v);\n\t\t\t\t\t\t\tthis._idPool.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, loadString(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\tstoreValue(sp + 32, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst m = Reflect.get(v, loadString(sp + 16));\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 32);\n\t\t\t\t\t\t\tconst result = Reflect.apply(m, v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.apply(v, undefined, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.construct(v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = encoder.encode(String(loadValue(sp + 8)));\n\t\t\t\t\t\tstoreValue(sp + 16, str);\n\t\t\t\t\t\tsetInt64(sp + 24, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = loadValue(sp + 8);\n\t\t\t\t\t\tloadSlice(sp + 16).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadSlice(sp + 8);\n\t\t\t\t\t\tconst src = loadValue(sp + 32);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadValue(sp + 8);\n\t\t\t\t\t\tconst src = loadSlice(sp + 16);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": (value) => {\n\t\t\t\t\t\tconsole.log(value);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tif (!(instance instanceof WebAssembly.Instance)) {\n\t\t\t\tthrow new Error(\"Go.run: WebAssembly.Instance expected\");\n\t\t\t}\n\t\t\tthis._inst = instance;\n\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map([ // mapping from JS values to reference ids\n\t\t\t\t[0, 1],\n\t\t\t\t[null, 2],\n\t\t\t\t[true, 3],\n\t\t\t\t[false, 4],\n\t\t\t\t[global, 5],\n\t\t\t\t[this, 6],\n\t\t\t]);\n\t\t\tthis._idPool = [];   // unused ids that have been garbage collected\n\t\t\tthis.exited = false; // whether the Go program has exited\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = (str) => {\n\t\t\t\tconst ptr = offset;\n\t\t\t\tconst bytes = encoder.encode(str + \"\\\\0\");\n\t\t\t\tnew Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n\t\t\t\toffset += bytes.length;\n\t\t\t\tif (offset % 8 !== 0) {\n\t\t\t\t\toffset += 8 - (offset % 8);\n\t\t\t\t}\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach((arg) => {\n\t\t\t\targvPtrs.push(strPtr(arg));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst keys = Object.keys(this.env).sort();\n\t\t\tkeys.forEach((key) => {\n\t\t\t\targvPtrs.push(strPtr(\\`\\${key}=\\${this.env[key]}\\`));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach((ptr) => {\n\t\t\t\tthis.mem.setUint32(offset, ptr, true);\n\t\t\t\tthis.mem.setUint32(offset + 4, 0, true);\n\t\t\t\toffset += 8;\n\t\t\t});\n\n\t\t\t// The linker guarantees global data starts from at least wasmMinDataAddr.\n\t\t\t// Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\t\t\tconst wasmMinDataAddr = 4096 + 4096;\n\t\t\tif (offset >= wasmMinDataAddr) {\n\t\t\t\tthrow new Error(\"command line too long\");\n\t\t\t}\n\n\t\t\tthis._inst.exports.run(argc, argv);\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\ttypeof module !== \"undefined\" &&\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length < 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tgo.argv = process.argv.slice(2);\n\t\tgo.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n\t\tgo.exit = process.exit;\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\tprocess.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n\t\t\t\tif (code === 0 && !go.exited) {\n\t\t\t\t\t// deadlock, make Go print error and stack traces\n\t\t\t\t\tgo._pendingEvent = { id: 0 };\n\t\t\t\t\tgo._resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();\nonmessage = ({ data: wasm }) => {\n  let decoder = new TextDecoder();\n  let fs = global.fs;\n  let stderr = \"\";\n  fs.writeSync = (fd, buffer) => {\n    if (fd === 1) {\n      postMessage(buffer);\n    } else if (fd === 2) {\n      stderr += decoder.decode(buffer);\n      let parts = stderr.split(\"\\\\n\");\n      if (parts.length > 1)\n        console.log(parts.slice(0, -1).join(\"\\\\n\"));\n      stderr = parts[parts.length - 1];\n    } else {\n      throw new Error(\"Bad write\");\n    }\n    return buffer.length;\n  };\n  let stdin = [];\n  let resumeStdin;\n  let stdinPos = 0;\n  onmessage = ({ data }) => {\n    if (data.length > 0) {\n      stdin.push(data);\n      if (resumeStdin)\n        resumeStdin();\n    }\n  };\n  fs.read = (fd, buffer, offset, length, position, callback) => {\n    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n      throw new Error(\"Bad read\");\n    }\n    if (stdin.length === 0) {\n      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n      return;\n    }\n    let first = stdin[0];\n    let count = Math.max(0, Math.min(length, first.length - stdinPos));\n    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n    stdinPos += count;\n    if (stdinPos === first.length) {\n      stdin.shift();\n      stdinPos = 0;\n    }\n    callback(null, count);\n  };\n  let go = new global.Go();\n  go.argv = [\"\", \\`--service=\\${\"0.13.13\"}\\`];\n  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n};}`;\n    let worker;\n\n    if (useWorker) {\n      let blob = new Blob([code], {\n        type: \"text/javascript\"\n      });\n      worker = new Worker(URL.createObjectURL(blob));\n    } else {\n      let fn = new Function(\"postMessage\", code + `var onmessage; return m => onmessage(m)`);\n      let onmessage = fn(data => worker.onmessage({\n        data\n      }));\n      worker = {\n        onmessage: null,\n        postMessage: data => onmessage({\n          data\n        }),\n\n        terminate() {}\n\n      };\n    }\n\n    worker.postMessage(wasm);\n\n    worker.onmessage = _ref7 => {\n      let {\n        data\n      } = _ref7;\n      return readFromStdout(data);\n    };\n\n    let {\n      readFromStdout,\n      service\n    } = createChannel({\n      writeToStdin(bytes) {\n        worker.postMessage(bytes);\n      },\n\n      isSync: false,\n      isBrowser: true\n    });\n    longLivedService = {\n      build: options => new Promise((resolve, reject) => service.buildOrServe({\n        callName: \"build\",\n        refs: null,\n        serveOptions: null,\n        options,\n        isTTY: false,\n        defaultWD: \"/\",\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      transform: (input, options) => new Promise((resolve, reject) => service.transform({\n        callName: \"transform\",\n        refs: null,\n        input,\n        options: options || {},\n        isTTY: false,\n        fs: {\n          readFile(_, callback) {\n            callback(new Error(\"Internal error\"), null);\n          },\n\n          writeFile(_, callback) {\n            callback(null);\n          }\n\n        },\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n        callName: \"formatMessages\",\n        refs: null,\n        messages,\n        options,\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n        callName: \"analyzeMetafile\",\n        refs: null,\n        metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n        options,\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      }))\n    };\n  });\n})(typeof exports === \"object\" ? exports : (typeof self !== \"undefined\" ? self : this).esbuild = {});","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/node_modules/esbuild-wasm/lib/browser.js"],"names":["exports","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","__markAsModule","target","__export","all","name","get","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","analyzeMetafile","analyzeMetafileSync","build","buildSync","formatMessages","formatMessagesSync","initialize","serve","transform","transformSync","version","encodePacket","packet","visit","bb","write8","write32","write","encodeUTF8","Uint8Array","Array","length","item","keys","ByteBuffer","id","isRequest","writeUInt32LE","buf","len","subarray","decodePacket","bytes","read8","read32","decodeUTF8","read","count","value2","i","push","Error","ptr","constructor","_write","delta","clone","set","offset","_read","readUInt32LE","TextEncoder","TextDecoder","encoder","decoder","text","encode","decode","Buffer","buffer","from","byteOffset","byteLength","toString","validateTarget","indexOf","canBeAnything","mustBeBoolean","mustBeBooleanOrObject","isArray","mustBeString","mustBeRegExp","RegExp","mustBeInteger","mustBeFunction","mustBeArray","mustBeObject","mustBeArrayOrRecord","mustBeObjectOrNull","mustBeStringOrBoolean","mustBeStringOrObject","mustBeStringOrArray","mustBeStringOrUint8Array","getFlag","object","mustBeFn","mustBe","checkForInvalidFlags","where","validateInitializeOptions","options","create","wasmURL","worker","pushLogFlags","flags","isTTY","logLevelDefault","color","logLevel","logLimit","pushCommonFlags","legalComments","sourceRoot","sourcesContent","format","globalName","minify","minifySyntax","minifyWhitespace","minifyIdentifiers","charset","treeShaking","ignoreAnnotations","jsx","jsxFactory","jsxFragment","define","pure","keepNames","map","join","fn","flagsForBuildOptions","callName","writeDefault","_a","entries","stdinContents","stdinResolveDir","watchMode","sourcemap","bundle","watch","splitting","preserveSymlinks","metafile","outfile","outdir","outbase","platform","tsconfig","resolveExtensions","nodePathsInput","mainFields","conditions","external","loader","outExtension","publicPath","entryNames","chunkNames","assetNames","inject","banner","footer","entryPoints","absWorkingDir","stdin","allowOverwrite","incremental","plugins","watchKeys","onRebuild","values","type","path","ext","entryPoint","stdinKeys","contents","resolveDir","sourcefile","loader2","nodePaths","flagsForTransformOptions","tsconfigRaw","JSON","stringify","createChannel","streamIn","responseCallbacks","Map","pluginCallbacks","watchCallbacks","serveCallbacks","nextServeID","isClosed","nextRequestID","nextBuildKey","stdout","stdoutUsed","readFromStdout","chunk","limit","swap","handleIncomingPacket","copyWithin","afterClose","callback","clear","callbacks","onWait","console","error","sendRequest","refs","response","unref","ref","writeToStdin","sendResponse","handleRequest","request","command","serveID","onRequest","args","watchID","err","errors","extractErrorMessageV8","isFirstPacket","binaryVersion","String","fromCharCode","delete","handlePlugins","initialOptions","buildKey","stash","onStartCallbacks","onEndCallbacks","onResolveCallbacks","onLoadCallbacks","nextCallbackID","requestPlugins","setup","plugin","onResolve","onLoad","promise","onStart","callback2","registeredText","registeredNote","extractCallerV8","note","onEnd","keys2","filter","namespace","source","ok","pluginName","warnings","_0","result","sanitizeMessages","ids","importer","kind","pluginData","load","sideEffects","watchFiles","watchDirs","store","sanitizeStringArray","runOnEndCallbacks","logPluginError","refCount","pluginRefs","buildServeData","port","host","servedir","wait","stop","buildLogLevelDefault","transformLogLevelDefault","buildOrServe","details","createObjectStash","e2","message","detail","handleError","failureErrorWithLog","isSync","buildOrServeContinue","logPluginError2","callerRefs","serveOptions","defaultWD","isBrowser","serve2","rebuild","copyResponseToResult","outputFiles","convertOutputFiles","parse","writeToStdout","log","replace","buildResponseToResult","replaceDetailsInMessages","rebuildID","isDisposed","error2","response2","location","notes","error3","result3","dispose","isStopped","serviceStopError","watchResponse","result2","serveResponse","transform2","input","fs","start","inputPath","inputFS","outstanding","code","codeFS","readFile","mapFS","writeFile","formatMessages2","messages","terminalWidth","isWarning","analyzeMetafile2","verbose","service","nextID","ident","tried","lines","stack","split","splice","parseStackLinesV8","at","readFileSync","startsWith","line","slice","match","exec","lineText","column","file","suggestion","summary","pluginText","sanitizeLocation","property","fallbackPluginName","messagesClone","index","notesClone","noteKeys","noteText","noteLocation","ensureServiceIsRunning","initializePromise","longLivedService","useWorker","startRunningService","catch","res","fetch","wasm","arrayBuffer","blob","Blob","Worker","URL","createObjectURL","Function","onmessage","data","postMessage","terminate","res2","_","self","esbuild"],"mappings":"AAAA,CAACA,OAAO,IAAE;AACV,MAAIC,SAAS,GAAGC,MAAM,CAACC,cAAvB;AACA,MAAIC,UAAU,GAAGF,MAAM,CAACG,gBAAxB;AACA,MAAIC,iBAAiB,GAAGJ,MAAM,CAACK,yBAA/B;AACA,MAAIC,mBAAmB,GAAGN,MAAM,CAACO,qBAAjC;AACA,MAAIC,YAAY,GAAGR,MAAM,CAACS,SAAP,CAAiBC,cAApC;AACA,MAAIC,YAAY,GAAGX,MAAM,CAACS,SAAP,CAAiBG,oBAApC;;AACA,MAAIC,eAAe,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqBD,GAAG,IAAID,GAAP,GAAaf,SAAS,CAACe,GAAD,EAAMC,GAAN,EAAW;AAAEE,IAAAA,UAAU,EAAE,IAAd;AAAoBC,IAAAA,YAAY,EAAE,IAAlC;AAAwCC,IAAAA,QAAQ,EAAE,IAAlD;AAAwDH,IAAAA;AAAxD,GAAX,CAAtB,GAAoGF,GAAG,CAACC,GAAD,CAAH,GAAWC,KAA1J;;AACA,MAAII,cAAc,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC7B,SAAK,IAAIC,IAAT,IAAiBD,CAAC,KAAKA,CAAC,GAAG,EAAT,CAAlB,EACE,IAAId,YAAY,CAACgB,IAAb,CAAkBF,CAAlB,EAAqBC,IAArB,CAAJ,EACEV,eAAe,CAACQ,CAAD,EAAIE,IAAJ,EAAUD,CAAC,CAACC,IAAD,CAAX,CAAf;;AACJ,QAAIjB,mBAAJ,EACE,KAAK,IAAIiB,IAAT,IAAiBjB,mBAAmB,CAACgB,CAAD,CAApC,EAAyC;AACvC,UAAIX,YAAY,CAACa,IAAb,CAAkBF,CAAlB,EAAqBC,IAArB,CAAJ,EACEV,eAAe,CAACQ,CAAD,EAAIE,IAAJ,EAAUD,CAAC,CAACC,IAAD,CAAX,CAAf;AACH;AACH,WAAOF,CAAP;AACD,GAVD;;AAWA,MAAII,aAAa,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAUpB,UAAU,CAACmB,CAAD,EAAIjB,iBAAiB,CAACkB,CAAD,CAArB,CAAxC;;AACA,MAAII,cAAc,GAAIC,MAAD,IAAY5B,SAAS,CAAC4B,MAAD,EAAS,YAAT,EAAuB;AAAEX,IAAAA,KAAK,EAAE;AAAT,GAAvB,CAA1C;;AACA,MAAIY,QAAQ,GAAG,CAACD,MAAD,EAASE,GAAT,KAAiB;AAC9BH,IAAAA,cAAc,CAACC,MAAD,CAAd;;AACA,SAAK,IAAIG,IAAT,IAAiBD,GAAjB,EACE9B,SAAS,CAAC4B,MAAD,EAASG,IAAT,EAAe;AAAEC,MAAAA,GAAG,EAAEF,GAAG,CAACC,IAAD,CAAV;AAAkBb,MAAAA,UAAU,EAAE;AAA9B,KAAf,CAAT;AACH,GAJD;;AAKA,MAAIe,OAAO,GAAG,CAACC,MAAD,EAASC,WAAT,EAAsBC,SAAtB,KAAoC;AAChD,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAIC,SAAS,GAAIvB,KAAD,IAAW;AACzB,YAAI;AACFwB,UAAAA,IAAI,CAACL,SAAS,CAACM,IAAV,CAAezB,KAAf,CAAD,CAAJ;AACD,SAFD,CAEE,OAAO0B,CAAP,EAAU;AACVJ,UAAAA,MAAM,CAACI,CAAD,CAAN;AACD;AACF,OAND;;AAOA,UAAIC,QAAQ,GAAI3B,KAAD,IAAW;AACxB,YAAI;AACFwB,UAAAA,IAAI,CAACL,SAAS,CAACS,KAAV,CAAgB5B,KAAhB,CAAD,CAAJ;AACD,SAFD,CAEE,OAAO0B,CAAP,EAAU;AACVJ,UAAAA,MAAM,CAACI,CAAD,CAAN;AACD;AACF,OAND;;AAOA,UAAIF,IAAI,GAAIK,CAAD,IAAOA,CAAC,CAACC,IAAF,GAAST,OAAO,CAACQ,CAAC,CAAC7B,KAAH,CAAhB,GAA4BoB,OAAO,CAACC,OAAR,CAAgBQ,CAAC,CAAC7B,KAAlB,EAAyB+B,IAAzB,CAA8BR,SAA9B,EAAyCI,QAAzC,CAA9C;;AACAH,MAAAA,IAAI,CAAC,CAACL,SAAS,GAAGA,SAAS,CAACa,KAAV,CAAgBf,MAAhB,EAAwBC,WAAxB,CAAb,EAAmDO,IAAnD,EAAD,CAAJ;AACD,KAjBM,CAAP;AAkBD,GAnBD,CA1BU,CA+CV;;;AACAb,EAAAA,QAAQ,CAAC9B,OAAD,EAAU;AAChBmD,IAAAA,eAAe,EAAE,MAAMA,eADP;AAEhBC,IAAAA,mBAAmB,EAAE,MAAMA,mBAFX;AAGhBC,IAAAA,KAAK,EAAE,MAAMA,KAHG;AAIhBC,IAAAA,SAAS,EAAE,MAAMA,SAJD;AAKhBC,IAAAA,cAAc,EAAE,MAAMA,cALN;AAMhBC,IAAAA,kBAAkB,EAAE,MAAMA,kBANV;AAOhBC,IAAAA,UAAU,EAAE,MAAMA,UAPF;AAQhBC,IAAAA,KAAK,EAAE,MAAMA,KARG;AAShBC,IAAAA,SAAS,EAAE,MAAMA,SATD;AAUhBC,IAAAA,aAAa,EAAE,MAAMA,aAVL;AAWhBC,IAAAA,OAAO,EAAE,MAAMA;AAXC,GAAV,CAAR,CAhDU,CA8DV;;;AACA,WAASC,YAAT,CAAsBC,MAAtB,EAA8B;AAC5B,QAAIC,KAAK,GAAI9C,KAAD,IAAW;AACrB,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB+C,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACD,OAFD,MAEO,IAAI,OAAOhD,KAAP,KAAiB,SAArB,EAAgC;AACrC+C,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAChD,KAAX;AACD,OAHM,MAGA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AACpC+C,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACE,OAAH,CAAWjD,KAAK,GAAG,CAAnB;AACD,OAHM,MAGA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AACpC+C,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACG,KAAH,CAASC,UAAU,CAACnD,KAAD,CAAnB;AACD,OAHM,MAGA,IAAIA,KAAK,YAAYoD,UAArB,EAAiC;AACtCL,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACG,KAAH,CAASlD,KAAT;AACD,OAHM,MAGA,IAAIA,KAAK,YAAYqD,KAArB,EAA4B;AACjCN,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACE,OAAH,CAAWjD,KAAK,CAACsD,MAAjB;;AACA,aAAK,IAAIC,IAAT,IAAiBvD,KAAjB,EAAwB;AACtB8C,UAAAA,KAAK,CAACS,IAAD,CAAL;AACD;AACF,OANM,MAMA;AACL,YAAIC,IAAI,GAAGxE,MAAM,CAACwE,IAAP,CAAYxD,KAAZ,CAAX;AACA+C,QAAAA,EAAE,CAACC,MAAH,CAAU,CAAV;AACAD,QAAAA,EAAE,CAACE,OAAH,CAAWO,IAAI,CAACF,MAAhB;;AACA,aAAK,IAAIvD,GAAT,IAAgByD,IAAhB,EAAsB;AACpBT,UAAAA,EAAE,CAACG,KAAH,CAASC,UAAU,CAACpD,GAAD,CAAnB;AACA+C,UAAAA,KAAK,CAAC9C,KAAK,CAACD,GAAD,CAAN,CAAL;AACD;AACF;AACF,KA9BD;;AA+BA,QAAIgD,EAAE,GAAG,IAAIU,UAAJ,EAAT;AACAV,IAAAA,EAAE,CAACE,OAAH,CAAW,CAAX;AACAF,IAAAA,EAAE,CAACE,OAAH,CAAWJ,MAAM,CAACa,EAAP,IAAa,CAAb,GAAiB,CAAC,CAACb,MAAM,CAACc,SAArC;AACAb,IAAAA,KAAK,CAACD,MAAM,CAAC7C,KAAR,CAAL;AACA4D,IAAAA,aAAa,CAACb,EAAE,CAACc,GAAJ,EAASd,EAAE,CAACe,GAAH,GAAS,CAAlB,EAAqB,CAArB,CAAb;AACA,WAAOf,EAAE,CAACc,GAAH,CAAOE,QAAP,CAAgB,CAAhB,EAAmBhB,EAAE,CAACe,GAAtB,CAAP;AACD;;AACD,WAASE,YAAT,CAAsBC,KAAtB,EAA6B;AAC3B,QAAInB,KAAK,GAAG,MAAM;AAChB,cAAQC,EAAE,CAACmB,KAAH,EAAR;AACE,aAAK,CAAL;AACE,iBAAO,IAAP;;AACF,aAAK,CAAL;AACE,iBAAO,CAAC,CAACnB,EAAE,CAACmB,KAAH,EAAT;;AACF,aAAK,CAAL;AACE,iBAAOnB,EAAE,CAACoB,MAAH,EAAP;;AACF,aAAK,CAAL;AACE,iBAAOC,UAAU,CAACrB,EAAE,CAACsB,IAAH,EAAD,CAAjB;;AACF,aAAK,CAAL;AACE,iBAAOtB,EAAE,CAACsB,IAAH,EAAP;;AACF,aAAK,CAAL;AAAQ;AACN,gBAAIC,KAAK,GAAGvB,EAAE,CAACoB,MAAH,EAAZ;AACA,gBAAII,MAAM,GAAG,EAAb;;AACA,iBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAApB,EAA2BE,CAAC,EAA5B,EAAgC;AAC9BD,cAAAA,MAAM,CAACE,IAAP,CAAY3B,KAAK,EAAjB;AACD;;AACD,mBAAOyB,MAAP;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,gBAAID,KAAK,GAAGvB,EAAE,CAACoB,MAAH,EAAZ;AACA,gBAAII,MAAM,GAAG,EAAb;;AACA,iBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAApB,EAA2BE,CAAC,EAA5B,EAAgC;AAC9BD,cAAAA,MAAM,CAACH,UAAU,CAACrB,EAAE,CAACsB,IAAH,EAAD,CAAX,CAAN,GAAgCvB,KAAK,EAArC;AACD;;AACD,mBAAOyB,MAAP;AACD;;AACD;AACE,gBAAM,IAAIG,KAAJ,CAAU,gBAAV,CAAN;AA5BJ;AA8BD,KA/BD;;AAgCA,QAAI3B,EAAE,GAAG,IAAIU,UAAJ,CAAeQ,KAAf,CAAT;AACA,QAAIP,EAAE,GAAGX,EAAE,CAACoB,MAAH,EAAT;AACA,QAAIR,SAAS,GAAG,CAACD,EAAE,GAAG,CAAN,MAAa,CAA7B;AACAA,IAAAA,EAAE,MAAM,CAAR;AACA,QAAI1D,KAAK,GAAG8C,KAAK,EAAjB;;AACA,QAAIC,EAAE,CAAC4B,GAAH,KAAWV,KAAK,CAACX,MAArB,EAA6B;AAC3B,YAAM,IAAIoB,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,WAAO;AAAEhB,MAAAA,EAAF;AAAMC,MAAAA,SAAN;AAAiB3D,MAAAA;AAAjB,KAAP;AACD;;AACD,MAAIyD,UAAU,GAAG,MAAM;AACrBmB,IAAAA,WAAW,GAA6B;AAAA,UAA5Bf,GAA4B,uEAAtB,IAAIT,UAAJ,CAAe,IAAf,CAAsB;AACtC,WAAKS,GAAL,GAAWA,GAAX;AACA,WAAKC,GAAL,GAAW,CAAX;AACA,WAAKa,GAAL,GAAW,CAAX;AACD;;AACDE,IAAAA,MAAM,CAACC,KAAD,EAAQ;AACZ,UAAI,KAAKhB,GAAL,GAAWgB,KAAX,GAAmB,KAAKjB,GAAL,CAASP,MAAhC,EAAwC;AACtC,YAAIyB,KAAK,GAAG,IAAI3B,UAAJ,CAAe,CAAC,KAAKU,GAAL,GAAWgB,KAAZ,IAAqB,CAApC,CAAZ;AACAC,QAAAA,KAAK,CAACC,GAAN,CAAU,KAAKnB,GAAf;AACA,aAAKA,GAAL,GAAWkB,KAAX;AACD;;AACD,WAAKjB,GAAL,IAAYgB,KAAZ;AACA,aAAO,KAAKhB,GAAL,GAAWgB,KAAlB;AACD;;AACD9B,IAAAA,MAAM,CAAChD,KAAD,EAAQ;AACZ,UAAIiF,MAAM,GAAG,KAAKJ,MAAL,CAAY,CAAZ,CAAb;;AACA,WAAKhB,GAAL,CAASoB,MAAT,IAAmBjF,KAAnB;AACD;;AACDiD,IAAAA,OAAO,CAACjD,KAAD,EAAQ;AACb,UAAIiF,MAAM,GAAG,KAAKJ,MAAL,CAAY,CAAZ,CAAb;;AACAjB,MAAAA,aAAa,CAAC,KAAKC,GAAN,EAAW7D,KAAX,EAAkBiF,MAAlB,CAAb;AACD;;AACD/B,IAAAA,KAAK,CAACe,KAAD,EAAQ;AACX,UAAIgB,MAAM,GAAG,KAAKJ,MAAL,CAAY,IAAIZ,KAAK,CAACX,MAAtB,CAAb;;AACAM,MAAAA,aAAa,CAAC,KAAKC,GAAN,EAAWI,KAAK,CAACX,MAAjB,EAAyB2B,MAAzB,CAAb;AACA,WAAKpB,GAAL,CAASmB,GAAT,CAAaf,KAAb,EAAoBgB,MAAM,GAAG,CAA7B;AACD;;AACDC,IAAAA,KAAK,CAACJ,KAAD,EAAQ;AACX,UAAI,KAAKH,GAAL,GAAWG,KAAX,GAAmB,KAAKjB,GAAL,CAASP,MAAhC,EAAwC;AACtC,cAAM,IAAIoB,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,WAAKC,GAAL,IAAYG,KAAZ;AACA,aAAO,KAAKH,GAAL,GAAWG,KAAlB;AACD;;AACDZ,IAAAA,KAAK,GAAG;AACN,aAAO,KAAKL,GAAL,CAAS,KAAKqB,KAAL,CAAW,CAAX,CAAT,CAAP;AACD;;AACDf,IAAAA,MAAM,GAAG;AACP,aAAOgB,YAAY,CAAC,KAAKtB,GAAN,EAAW,KAAKqB,KAAL,CAAW,CAAX,CAAX,CAAnB;AACD;;AACDb,IAAAA,IAAI,GAAG;AACL,UAAIf,MAAM,GAAG,KAAKa,MAAL,EAAb;AACA,UAAIF,KAAK,GAAG,IAAIb,UAAJ,CAAeE,MAAf,CAAZ;;AACA,UAAIqB,GAAG,GAAG,KAAKO,KAAL,CAAWjB,KAAK,CAACX,MAAjB,CAAV;;AACAW,MAAAA,KAAK,CAACe,GAAN,CAAU,KAAKnB,GAAL,CAASE,QAAT,CAAkBY,GAAlB,EAAuBA,GAAG,GAAGrB,MAA7B,CAAV;AACA,aAAOW,KAAP;AACD;;AA/CoB,GAAvB;AAiDA,MAAId,UAAJ;AACA,MAAIiB,UAAJ;;AACA,MAAI,OAAOgB,WAAP,KAAuB,WAAvB,IAAsC,OAAOC,WAAP,KAAuB,WAAjE,EAA8E;AAC5E,QAAIC,OAAO,GAAG,IAAIF,WAAJ,EAAd;AACA,QAAIG,OAAO,GAAG,IAAIF,WAAJ,EAAd;;AACAlC,IAAAA,UAAU,GAAIqC,IAAD,IAAUF,OAAO,CAACG,MAAR,CAAeD,IAAf,CAAvB;;AACApB,IAAAA,UAAU,GAAIH,KAAD,IAAWsB,OAAO,CAACG,MAAR,CAAezB,KAAf,CAAxB;AACD,GALD,MAKO,IAAI,OAAO0B,MAAP,KAAkB,WAAtB,EAAmC;AACxCxC,IAAAA,UAAU,GAAIqC,IAAD,IAAU;AACrB,UAAII,MAAM,GAAGD,MAAM,CAACE,IAAP,CAAYL,IAAZ,CAAb;;AACA,UAAI,EAAEI,MAAM,YAAYxC,UAApB,CAAJ,EAAqC;AACnCwC,QAAAA,MAAM,GAAG,IAAIxC,UAAJ,CAAewC,MAAf,CAAT;AACD;;AACD,aAAOA,MAAP;AACD,KAND;;AAOAxB,IAAAA,UAAU,GAAIH,KAAD,IAAW;AACtB,UAAI;AAAE2B,QAAAA,MAAF;AAAUE,QAAAA,UAAV;AAAsBC,QAAAA;AAAtB,UAAqC9B,KAAzC;AACA,aAAO0B,MAAM,CAACE,IAAP,CAAYD,MAAZ,EAAoBE,UAApB,EAAgCC,UAAhC,EAA4CC,QAA5C,EAAP;AACD,KAHD;AAID,GAZM,MAYA;AACL,UAAM,IAAItB,KAAJ,CAAU,sBAAV,CAAN;AACD;;AACD,WAASS,YAAT,CAAsBS,MAAtB,EAA8BX,MAA9B,EAAsC;AACpC,WAAOW,MAAM,CAACX,MAAM,EAAP,CAAN,GAAmBW,MAAM,CAACX,MAAM,EAAP,CAAN,IAAoB,CAAvC,GAA2CW,MAAM,CAACX,MAAM,EAAP,CAAN,IAAoB,EAA/D,GAAoEW,MAAM,CAACX,MAAM,EAAP,CAAN,IAAoB,EAA/F;AACD;;AACD,WAASrB,aAAT,CAAuBgC,MAAvB,EAA+B5F,KAA/B,EAAsCiF,MAAtC,EAA8C;AAC5CW,IAAAA,MAAM,CAACX,MAAM,EAAP,CAAN,GAAmBjF,KAAnB;AACA4F,IAAAA,MAAM,CAACX,MAAM,EAAP,CAAN,GAAmBjF,KAAK,IAAI,CAA5B;AACA4F,IAAAA,MAAM,CAACX,MAAM,EAAP,CAAN,GAAmBjF,KAAK,IAAI,EAA5B;AACA4F,IAAAA,MAAM,CAACX,MAAM,EAAP,CAAN,GAAmBjF,KAAK,IAAI,EAA5B;AACD,GAhOS,CAkOV;;;AACA,WAASiG,cAAT,CAAwBtF,MAAxB,EAAgC;AAC9BA,IAAAA,MAAM,IAAI,EAAV;AACA,QAAIA,MAAM,CAACuF,OAAP,CAAe,GAAf,KAAuB,CAA3B,EACE,MAAM,IAAIxB,KAAJ,CAAW,mBAAkB/D,MAAO,EAApC,CAAN;AACF,WAAOA,MAAP;AACD;;AACD,MAAIwF,aAAa,GAAG,MAAM,IAA1B;;AACA,MAAIC,aAAa,GAAIpG,KAAD,IAAW,OAAOA,KAAP,KAAiB,SAAjB,GAA6B,IAA7B,GAAoC,WAAnE;;AACA,MAAIqG,qBAAqB,GAAIrG,KAAD,IAAW,OAAOA,KAAP,KAAiB,SAAjB,IAA8B,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAA5D,GAAmF,IAAnF,GAA0F,wBAAjI;;AACA,MAAIuG,YAAY,GAAIvG,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,GAA4B,IAA5B,GAAmC,UAAjE;;AACA,MAAIwG,YAAY,GAAIxG,KAAD,IAAWA,KAAK,YAAYyG,MAAjB,GAA0B,IAA1B,GAAiC,iBAA/D;;AACA,MAAIC,aAAa,GAAI1G,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,MAAMA,KAAK,GAAG,CAAd,CAAlC,GAAqD,IAArD,GAA4D,YAA3F;;AACA,MAAI2G,cAAc,GAAI3G,KAAD,IAAW,OAAOA,KAAP,KAAiB,UAAjB,GAA8B,IAA9B,GAAqC,YAArE;;AACA,MAAI4G,WAAW,GAAI5G,KAAD,IAAWqD,KAAK,CAACiD,OAAN,CAActG,KAAd,IAAuB,IAAvB,GAA8B,UAA3D;;AACA,MAAI6G,YAAY,GAAI7G,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,CAACqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAAhD,GAAuE,IAAvE,GAA8E,WAA5G;;AACA,MAAI8G,mBAAmB,GAAI9G,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,GAA8C,IAA9C,GAAqD,uBAA1F;;AACA,MAAI+G,kBAAkB,GAAI/G,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAA9B,GAAqD,IAArD,GAA4D,mBAAhG;;AACA,MAAIgH,qBAAqB,GAAIhH,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,SAA9C,GAA0D,IAA1D,GAAiE,uBAAxG;;AACA,MAAIiH,oBAAoB,GAAIjH,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,CAACqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAA7E,GAAoG,IAApG,GAA2G,uBAAjJ;;AACA,MAAIkH,mBAAmB,GAAIlH,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAA7B,GAAoD,IAApD,GAA2D,sBAAhG;;AACA,MAAImH,wBAAwB,GAAInH,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,YAAYoD,UAA9C,GAA2D,IAA3D,GAAkE,0BAA5G;;AACA,WAASgE,OAAT,CAAiBC,MAAjB,EAAyB7D,IAAzB,EAA+BzD,GAA/B,EAAoCuH,QAApC,EAA8C;AAC5C,QAAItH,KAAK,GAAGqH,MAAM,CAACtH,GAAD,CAAlB;AACAyD,IAAAA,IAAI,CAACzD,GAAG,GAAG,EAAP,CAAJ,GAAiB,IAAjB;AACA,QAAIC,KAAK,KAAK,KAAK,CAAnB,EACE,OAAO,KAAK,CAAZ;AACF,QAAIuH,MAAM,GAAGD,QAAQ,CAACtH,KAAD,CAArB;AACA,QAAIuH,MAAM,KAAK,IAAf,EACE,MAAM,IAAI7C,KAAJ,CAAW,IAAG3E,GAAI,aAAYwH,MAAO,EAArC,CAAN;AACF,WAAOvH,KAAP;AACD;;AACD,WAASwH,oBAAT,CAA8BH,MAA9B,EAAsC7D,IAAtC,EAA4CiE,KAA5C,EAAmD;AACjD,SAAK,IAAI1H,GAAT,IAAgBsH,MAAhB,EAAwB;AACtB,UAAI,EAAEtH,GAAG,IAAIyD,IAAT,CAAJ,EAAoB;AAClB,cAAM,IAAIkB,KAAJ,CAAW,kBAAiB+C,KAAM,MAAK1H,GAAI,GAA3C,CAAN;AACD;AACF;AACF;;AACD,WAAS2H,yBAAT,CAAmCC,OAAnC,EAA4C;AAC1C,QAAInE,IAAI,GAAGxE,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAX;AACA,QAAIC,OAAO,GAAGT,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,SAAhB,EAA2B+C,YAA3B,CAArB;AACA,QAAIuB,MAAM,GAAGV,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B4C,aAA1B,CAApB;AACAoB,IAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAgB,wBAAhB,CAApB;AACA,WAAO;AACLqE,MAAAA,OADK;AAELC,MAAAA;AAFK,KAAP;AAID;;AACD,WAASC,YAAT,CAAsBC,KAAtB,EAA6BL,OAA7B,EAAsCnE,IAAtC,EAA4CyE,KAA5C,EAAmDC,eAAnD,EAAoE;AAClE,QAAIC,KAAK,GAAGf,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyB4C,aAAzB,CAAnB;AACA,QAAIgC,QAAQ,GAAGhB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4B+C,YAA5B,CAAtB;AACA,QAAI8B,QAAQ,GAAGjB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4BkD,aAA5B,CAAtB;AACA,QAAIyB,KAAK,KAAK,KAAK,CAAnB,EACEH,KAAK,CAACvD,IAAN,CAAY,WAAU0D,KAAM,EAA5B,EADF,KAEK,IAAIF,KAAJ,EACHD,KAAK,CAACvD,IAAN,CAAY,cAAZ;AACFuD,IAAAA,KAAK,CAACvD,IAAN,CAAY,eAAc2D,QAAQ,IAAIF,eAAgB,EAAtD;AACAF,IAAAA,KAAK,CAACvD,IAAN,CAAY,eAAc4D,QAAQ,IAAI,CAAE,EAAxC;AACD;;AACD,WAASC,eAAT,CAAyBN,KAAzB,EAAgCL,OAAhC,EAAyCnE,IAAzC,EAA+C;AAC7C,QAAI+E,aAAa,GAAGnB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,eAAhB,EAAiC+C,YAAjC,CAA3B;AACA,QAAIiC,UAAU,GAAGpB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAIkC,cAAc,GAAGrB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,gBAAhB,EAAkC4C,aAAlC,CAA5B;AACA,QAAIzF,MAAM,GAAGyG,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B0D,mBAA1B,CAApB;AACA,QAAIwB,MAAM,GAAGtB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B+C,YAA1B,CAApB;AACA,QAAIoC,UAAU,GAAGvB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAIqC,MAAM,GAAGxB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B4C,aAA1B,CAApB;AACA,QAAIyC,YAAY,GAAGzB,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,cAAhB,EAAgC4C,aAAhC,CAA1B;AACA,QAAI0C,gBAAgB,GAAG1B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,kBAAhB,EAAoC4C,aAApC,CAA9B;AACA,QAAI2C,iBAAiB,GAAG3B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,mBAAhB,EAAqC4C,aAArC,CAA/B;AACA,QAAI4C,OAAO,GAAG5B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,SAAhB,EAA2B+C,YAA3B,CAArB;AACA,QAAI0C,WAAW,GAAG7B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,aAAhB,EAA+B4C,aAA/B,CAAzB;AACA,QAAI8C,iBAAiB,GAAG9B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,mBAAhB,EAAqC4C,aAArC,CAA/B;AACA,QAAI+C,GAAG,GAAG/B,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,KAAhB,EAAuB+C,YAAvB,CAAjB;AACA,QAAI6C,UAAU,GAAGhC,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAI8C,WAAW,GAAGjC,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,aAAhB,EAA+B+C,YAA/B,CAAzB;AACA,QAAI+C,MAAM,GAAGlC,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0BqD,YAA1B,CAApB;AACA,QAAI0C,IAAI,GAAGnC,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,MAAhB,EAAwBoD,WAAxB,CAAlB;AACA,QAAI4C,SAAS,GAAGpC,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6B4C,aAA7B,CAAvB;AACA,QAAImC,aAAJ,EACEP,KAAK,CAACvD,IAAN,CAAY,oBAAmB8D,aAAc,EAA7C;AACF,QAAIC,UAAU,KAAK,KAAK,CAAxB,EACER,KAAK,CAACvD,IAAN,CAAY,iBAAgB+D,UAAW,EAAvC;AACF,QAAIC,cAAc,KAAK,KAAK,CAA5B,EACET,KAAK,CAACvD,IAAN,CAAY,qBAAoBgE,cAAe,EAA/C;;AACF,QAAI9H,MAAJ,EAAY;AACV,UAAI0C,KAAK,CAACiD,OAAN,CAAc3F,MAAd,CAAJ,EACEqH,KAAK,CAACvD,IAAN,CAAY,YAAWpB,KAAK,CAACwC,IAAN,CAAWlF,MAAX,EAAmB8I,GAAnB,CAAuBxD,cAAvB,EAAuCyD,IAAvC,CAA4C,GAA5C,CAAiD,EAAxE,EADF,KAGE1B,KAAK,CAACvD,IAAN,CAAY,YAAWwB,cAAc,CAACtF,MAAD,CAAS,EAA9C;AACH;;AACD,QAAI+H,MAAJ,EACEV,KAAK,CAACvD,IAAN,CAAY,YAAWiE,MAAO,EAA9B;AACF,QAAIC,UAAJ,EACEX,KAAK,CAACvD,IAAN,CAAY,iBAAgBkE,UAAW,EAAvC;AACF,QAAIC,MAAJ,EACEZ,KAAK,CAACvD,IAAN,CAAW,UAAX;AACF,QAAIoE,YAAJ,EACEb,KAAK,CAACvD,IAAN,CAAW,iBAAX;AACF,QAAIqE,gBAAJ,EACEd,KAAK,CAACvD,IAAN,CAAW,qBAAX;AACF,QAAIsE,iBAAJ,EACEf,KAAK,CAACvD,IAAN,CAAW,sBAAX;AACF,QAAIuE,OAAJ,EACEhB,KAAK,CAACvD,IAAN,CAAY,aAAYuE,OAAQ,EAAhC;AACF,QAAIC,WAAW,KAAK,KAAK,CAAzB,EACEjB,KAAK,CAACvD,IAAN,CAAY,kBAAiBwE,WAAY,EAAzC;AACF,QAAIC,iBAAJ,EACElB,KAAK,CAACvD,IAAN,CAAY,sBAAZ;AACF,QAAI0E,GAAJ,EACEnB,KAAK,CAACvD,IAAN,CAAY,SAAQ0E,GAAI,EAAxB;AACF,QAAIC,UAAJ,EACEpB,KAAK,CAACvD,IAAN,CAAY,iBAAgB2E,UAAW,EAAvC;AACF,QAAIC,WAAJ,EACErB,KAAK,CAACvD,IAAN,CAAY,kBAAiB4E,WAAY,EAAzC;;AACF,QAAIC,MAAJ,EAAY;AACV,WAAK,IAAIvJ,GAAT,IAAgBuJ,MAAhB,EAAwB;AACtB,YAAIvJ,GAAG,CAACmG,OAAJ,CAAY,GAAZ,KAAoB,CAAxB,EACE,MAAM,IAAIxB,KAAJ,CAAW,mBAAkB3E,GAAI,EAAjC,CAAN;AACFiI,QAAAA,KAAK,CAACvD,IAAN,CAAY,YAAW1E,GAAI,IAAGuJ,MAAM,CAACvJ,GAAD,CAAM,EAA1C;AACD;AACF;;AACD,QAAIwJ,IAAJ,EACE,KAAK,IAAII,EAAT,IAAeJ,IAAf,EACEvB,KAAK,CAACvD,IAAN,CAAY,UAASkF,EAAG,EAAxB;AACJ,QAAIH,SAAJ,EACExB,KAAK,CAACvD,IAAN,CAAY,cAAZ;AACH;;AACD,WAASmF,oBAAT,CAA8BC,QAA9B,EAAwClC,OAAxC,EAAiDM,KAAjD,EAAwDC,eAAxD,EAAyE4B,YAAzE,EAAuF;AACrF,QAAIC,EAAJ;;AACA,QAAI/B,KAAK,GAAG,EAAZ;AACA,QAAIgC,OAAO,GAAG,EAAd;AACA,QAAIxG,IAAI,GAAGxE,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAX;AACA,QAAIqC,aAAa,GAAG,IAApB;AACA,QAAIC,eAAe,GAAG,IAAtB;AACA,QAAIC,SAAS,GAAG,IAAhB;AACApC,IAAAA,YAAY,CAACC,KAAD,EAAQL,OAAR,EAAiBnE,IAAjB,EAAuByE,KAAvB,EAA8BC,eAA9B,CAAZ;AACAI,IAAAA,eAAe,CAACN,KAAD,EAAQL,OAAR,EAAiBnE,IAAjB,CAAf;AACA,QAAI4G,SAAS,GAAGhD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6BwD,qBAA7B,CAAvB;AACA,QAAIqD,MAAM,GAAGjD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B4C,aAA1B,CAApB;AACA,QAAIkE,KAAK,GAAGlD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyB6C,qBAAzB,CAAnB;AACA,QAAIkE,SAAS,GAAGnD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6B4C,aAA7B,CAAvB;AACA,QAAIoE,gBAAgB,GAAGpD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,kBAAhB,EAAoC4C,aAApC,CAA9B;AACA,QAAIqE,QAAQ,GAAGrD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4B4C,aAA5B,CAAtB;AACA,QAAIsE,OAAO,GAAGtD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,SAAhB,EAA2B+C,YAA3B,CAArB;AACA,QAAIoE,MAAM,GAAGvD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B+C,YAA1B,CAApB;AACA,QAAIqE,OAAO,GAAGxD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,SAAhB,EAA2B+C,YAA3B,CAArB;AACA,QAAIsE,QAAQ,GAAGzD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4B+C,YAA5B,CAAtB;AACA,QAAIuE,QAAQ,GAAG1D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4B+C,YAA5B,CAAtB;AACA,QAAIwE,iBAAiB,GAAG3D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,mBAAhB,EAAqCoD,WAArC,CAA/B;AACA,QAAIoE,cAAc,GAAG5D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6BoD,WAA7B,CAA5B;AACA,QAAIqE,UAAU,GAAG7D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8BoD,WAA9B,CAAxB;AACA,QAAIsE,UAAU,GAAG9D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8BoD,WAA9B,CAAxB;AACA,QAAIuE,QAAQ,GAAG/D,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4BoD,WAA5B,CAAtB;AACA,QAAIwE,MAAM,GAAGhE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0BqD,YAA1B,CAApB;AACA,QAAIwE,YAAY,GAAGjE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,cAAhB,EAAgCqD,YAAhC,CAA1B;AACA,QAAIyE,UAAU,GAAGlE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAIgF,UAAU,GAAGnE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAIiF,UAAU,GAAGpE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAIkF,UAAU,GAAGrE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAImF,MAAM,GAAGtE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0BoD,WAA1B,CAApB;AACA,QAAI+E,MAAM,GAAGvE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0BqD,YAA1B,CAApB;AACA,QAAI+E,MAAM,GAAGxE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0BqD,YAA1B,CAApB;AACA,QAAIgF,WAAW,GAAGzE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,aAAhB,EAA+BsD,mBAA/B,CAAzB;AACA,QAAIgF,aAAa,GAAG1E,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,eAAhB,EAAiC+C,YAAjC,CAA3B;AACA,QAAIwF,KAAK,GAAG3E,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyBqD,YAAzB,CAAnB;AACA,QAAI3D,KAAK,GAAG,CAAC6G,EAAE,GAAG3C,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyB4C,aAAzB,CAAb,KAAyD,IAAzD,GAAgE2D,EAAhE,GAAqED,YAAjF;AACA,QAAIkC,cAAc,GAAG5E,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,gBAAhB,EAAkC4C,aAAlC,CAA5B;AACA,QAAI6F,WAAW,GAAG7E,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,aAAhB,EAA+B4C,aAA/B,CAAP,KAAyD,IAA3E;AACA5C,IAAAA,IAAI,CAAC0I,OAAL,GAAe,IAAf;AACA1E,IAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAiB,MAAKqG,QAAS,SAA/B,CAApB;AACA,QAAIO,SAAJ,EACEpC,KAAK,CAACvD,IAAN,CAAY,cAAa2F,SAAS,KAAK,IAAd,GAAqB,EAArB,GAA2B,IAAGA,SAAU,EAAE,EAAnE;AACF,QAAIC,MAAJ,EACErC,KAAK,CAACvD,IAAN,CAAW,UAAX;AACF,QAAIuH,cAAJ,EACEhE,KAAK,CAACvD,IAAN,CAAW,mBAAX;;AACF,QAAI6F,KAAJ,EAAW;AACTtC,MAAAA,KAAK,CAACvD,IAAN,CAAW,SAAX;;AACA,UAAI,OAAO6F,KAAP,KAAiB,SAArB,EAAgC;AAC9BH,QAAAA,SAAS,GAAG,EAAZ;AACD,OAFD,MAEO;AACL,YAAIgC,SAAS,GAAGnN,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAhB;AACA,YAAIwE,SAAS,GAAGhF,OAAO,CAACkD,KAAD,EAAQ6B,SAAR,EAAmB,WAAnB,EAAgCxF,cAAhC,CAAvB;AACAa,QAAAA,oBAAoB,CAAC8C,KAAD,EAAQ6B,SAAR,EAAoB,iBAAgBtC,QAAS,SAA7C,CAApB;AACAM,QAAAA,SAAS,GAAG;AAAEiC,UAAAA;AAAF,SAAZ;AACD;AACF;;AACD,QAAI7B,SAAJ,EACEvC,KAAK,CAACvD,IAAN,CAAW,aAAX;AACF,QAAI+F,gBAAJ,EACExC,KAAK,CAACvD,IAAN,CAAW,qBAAX;AACF,QAAIgG,QAAJ,EACEzC,KAAK,CAACvD,IAAN,CAAY,YAAZ;AACF,QAAIiG,OAAJ,EACE1C,KAAK,CAACvD,IAAN,CAAY,aAAYiG,OAAQ,EAAhC;AACF,QAAIC,MAAJ,EACE3C,KAAK,CAACvD,IAAN,CAAY,YAAWkG,MAAO,EAA9B;AACF,QAAIC,OAAJ,EACE5C,KAAK,CAACvD,IAAN,CAAY,aAAYmG,OAAQ,EAAhC;AACF,QAAIC,QAAJ,EACE7C,KAAK,CAACvD,IAAN,CAAY,cAAaoG,QAAS,EAAlC;AACF,QAAIC,QAAJ,EACE9C,KAAK,CAACvD,IAAN,CAAY,cAAaqG,QAAS,EAAlC;;AACF,QAAIC,iBAAJ,EAAuB;AACrB,UAAIsB,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIrM,KAAT,IAAkB+K,iBAAlB,EAAqC;AACnC/K,QAAAA,KAAK,IAAI,EAAT;AACA,YAAIA,KAAK,CAACkG,OAAN,CAAc,GAAd,KAAsB,CAA1B,EACE,MAAM,IAAIxB,KAAJ,CAAW,8BAA6B1E,KAAM,EAA9C,CAAN;AACFqM,QAAAA,MAAM,CAAC5H,IAAP,CAAYzE,KAAZ;AACD;;AACDgI,MAAAA,KAAK,CAACvD,IAAN,CAAY,wBAAuB4H,MAAM,CAAC3C,IAAP,CAAY,GAAZ,CAAiB,EAApD;AACD;;AACD,QAAI4B,UAAJ,EACEtD,KAAK,CAACvD,IAAN,CAAY,iBAAgB6G,UAAW,EAAvC;AACF,QAAIC,UAAJ,EACEvD,KAAK,CAACvD,IAAN,CAAY,iBAAgB8G,UAAW,EAAvC;AACF,QAAIC,UAAJ,EACExD,KAAK,CAACvD,IAAN,CAAY,iBAAgB+G,UAAW,EAAvC;AACF,QAAIC,UAAJ,EACEzD,KAAK,CAACvD,IAAN,CAAY,iBAAgBgH,UAAW,EAAvC;;AACF,QAAIR,UAAJ,EAAgB;AACd,UAAIoB,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIrM,KAAT,IAAkBiL,UAAlB,EAA8B;AAC5BjL,QAAAA,KAAK,IAAI,EAAT;AACA,YAAIA,KAAK,CAACkG,OAAN,CAAc,GAAd,KAAsB,CAA1B,EACE,MAAM,IAAIxB,KAAJ,CAAW,uBAAsB1E,KAAM,EAAvC,CAAN;AACFqM,QAAAA,MAAM,CAAC5H,IAAP,CAAYzE,KAAZ;AACD;;AACDgI,MAAAA,KAAK,CAACvD,IAAN,CAAY,iBAAgB4H,MAAM,CAAC3C,IAAP,CAAY,GAAZ,CAAiB,EAA7C;AACD;;AACD,QAAIwB,UAAJ,EAAgB;AACd,UAAImB,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIrM,KAAT,IAAkBkL,UAAlB,EAA8B;AAC5BlL,QAAAA,KAAK,IAAI,EAAT;AACA,YAAIA,KAAK,CAACkG,OAAN,CAAc,GAAd,KAAsB,CAA1B,EACE,MAAM,IAAIxB,KAAJ,CAAW,sBAAqB1E,KAAM,EAAtC,CAAN;AACFqM,QAAAA,MAAM,CAAC5H,IAAP,CAAYzE,KAAZ;AACD;;AACDgI,MAAAA,KAAK,CAACvD,IAAN,CAAY,gBAAe4H,MAAM,CAAC3C,IAAP,CAAY,GAAZ,CAAiB,EAA5C;AACD;;AACD,QAAIyB,QAAJ,EACE,KAAK,IAAIrK,IAAT,IAAiBqK,QAAjB,EACEnD,KAAK,CAACvD,IAAN,CAAY,cAAa3D,IAAK,EAA9B;;AACJ,QAAI6K,MAAJ,EAAY;AACV,WAAK,IAAIW,IAAT,IAAiBX,MAAjB,EAAyB;AACvB,YAAIW,IAAI,CAACpG,OAAL,CAAa,GAAb,KAAqB,CAAzB,EACE,MAAM,IAAIxB,KAAJ,CAAW,6BAA4B4H,IAAK,EAA5C,CAAN;AACFtE,QAAAA,KAAK,CAACvD,IAAN,CAAY,YAAW6H,IAAK,IAAGX,MAAM,CAACW,IAAD,CAAO,EAA5C;AACD;AACF;;AACD,QAAIV,MAAJ,EAAY;AACV,WAAK,IAAIU,IAAT,IAAiBV,MAAjB,EAAyB;AACvB,YAAIU,IAAI,CAACpG,OAAL,CAAa,GAAb,KAAqB,CAAzB,EACE,MAAM,IAAIxB,KAAJ,CAAW,6BAA4B4H,IAAK,EAA5C,CAAN;AACFtE,QAAAA,KAAK,CAACvD,IAAN,CAAY,YAAW6H,IAAK,IAAGV,MAAM,CAACU,IAAD,CAAO,EAA5C;AACD;AACF;;AACD,QAAIZ,MAAJ,EACE,KAAK,IAAIa,IAAT,IAAiBb,MAAjB,EACE1D,KAAK,CAACvD,IAAN,CAAY,YAAW8H,IAAK,EAA5B;;AACJ,QAAInB,MAAJ,EAAY;AACV,WAAK,IAAIoB,GAAT,IAAgBpB,MAAhB,EAAwB;AACtB,YAAIoB,GAAG,CAACtG,OAAJ,CAAY,GAAZ,KAAoB,CAAxB,EACE,MAAM,IAAIxB,KAAJ,CAAW,6BAA4B8H,GAAI,EAA3C,CAAN;AACFxE,QAAAA,KAAK,CAACvD,IAAN,CAAY,YAAW+H,GAAI,IAAGpB,MAAM,CAACoB,GAAD,CAAM,EAA1C;AACD;AACF;;AACD,QAAInB,YAAJ,EAAkB;AAChB,WAAK,IAAImB,GAAT,IAAgBnB,YAAhB,EAA8B;AAC5B,YAAImB,GAAG,CAACtG,OAAJ,CAAY,GAAZ,KAAoB,CAAxB,EACE,MAAM,IAAIxB,KAAJ,CAAW,0BAAyB8H,GAAI,EAAxC,CAAN;AACFxE,QAAAA,KAAK,CAACvD,IAAN,CAAY,mBAAkB+H,GAAI,IAAGnB,YAAY,CAACmB,GAAD,CAAM,EAAvD;AACD;AACF;;AACD,QAAIX,WAAJ,EAAiB;AACf,UAAIxI,KAAK,CAACiD,OAAN,CAAcuF,WAAd,CAAJ,EAAgC;AAC9B,aAAK,IAAIY,UAAT,IAAuBZ,WAAvB,EAAoC;AAClC7B,UAAAA,OAAO,CAACvF,IAAR,CAAa,CAAC,EAAD,EAAKgI,UAAU,GAAG,EAAlB,CAAb;AACD;AACF,OAJD,MAIO;AACL,aAAK,IAAI,CAAC1M,GAAD,EAAMC,KAAN,CAAT,IAAyBhB,MAAM,CAACgL,OAAP,CAAe6B,WAAf,CAAzB,EAAsD;AACpD7B,UAAAA,OAAO,CAACvF,IAAR,CAAa,CAAC1E,GAAG,GAAG,EAAP,EAAWC,KAAK,GAAG,EAAnB,CAAb;AACD;AACF;AACF;;AACD,QAAI+L,KAAJ,EAAW;AACT,UAAIW,SAAS,GAAG1N,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAhB;AACA,UAAI+E,QAAQ,GAAGvF,OAAO,CAAC2E,KAAD,EAAQW,SAAR,EAAmB,UAAnB,EAA+BnG,YAA/B,CAAtB;AACA,UAAIqG,UAAU,GAAGxF,OAAO,CAAC2E,KAAD,EAAQW,SAAR,EAAmB,YAAnB,EAAiCnG,YAAjC,CAAxB;AACA,UAAIsG,UAAU,GAAGzF,OAAO,CAAC2E,KAAD,EAAQW,SAAR,EAAmB,YAAnB,EAAiCnG,YAAjC,CAAxB;AACA,UAAIuG,OAAO,GAAG1F,OAAO,CAAC2E,KAAD,EAAQW,SAAR,EAAmB,QAAnB,EAA6BnG,YAA7B,CAArB;AACAiB,MAAAA,oBAAoB,CAACuE,KAAD,EAAQW,SAAR,EAAmB,mBAAnB,CAApB;AACA,UAAIG,UAAJ,EACE7E,KAAK,CAACvD,IAAN,CAAY,gBAAeoI,UAAW,EAAtC;AACF,UAAIC,OAAJ,EACE9E,KAAK,CAACvD,IAAN,CAAY,YAAWqI,OAAQ,EAA/B;AACF,UAAIF,UAAJ,EACE1C,eAAe,GAAG0C,UAAU,GAAG,EAA/B;AACF3C,MAAAA,aAAa,GAAG0C,QAAQ,GAAGA,QAAQ,GAAG,EAAd,GAAmB,EAA3C;AACD;;AACD,QAAII,SAAS,GAAG,EAAhB;;AACA,QAAI/B,cAAJ,EAAoB;AAClB,WAAK,IAAIhL,KAAT,IAAkBgL,cAAlB,EAAkC;AAChChL,QAAAA,KAAK,IAAI,EAAT;AACA+M,QAAAA,SAAS,CAACtI,IAAV,CAAezE,KAAf;AACD;AACF;;AACD,WAAO;AACLgK,MAAAA,OADK;AAELhC,MAAAA,KAFK;AAGL9E,MAAAA,KAHK;AAIL+G,MAAAA,aAJK;AAKLC,MAAAA,eALK;AAML4B,MAAAA,aANK;AAOLG,MAAAA,WAPK;AAQLc,MAAAA,SARK;AASLzC,MAAAA,KAAK,EAAEH;AATF,KAAP;AAWD;;AACD,WAAS6C,wBAAT,CAAkCnD,QAAlC,EAA4ClC,OAA5C,EAAqDM,KAArD,EAA4DC,eAA5D,EAA6E;AAC3E,QAAIF,KAAK,GAAG,EAAZ;AACA,QAAIxE,IAAI,GAAGxE,MAAM,CAAC4I,MAAP,CAAc,IAAd,CAAX;AACAG,IAAAA,YAAY,CAACC,KAAD,EAAQL,OAAR,EAAiBnE,IAAjB,EAAuByE,KAAvB,EAA8BC,eAA9B,CAAZ;AACAI,IAAAA,eAAe,CAACN,KAAD,EAAQL,OAAR,EAAiBnE,IAAjB,CAAf;AACA,QAAI4G,SAAS,GAAGhD,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6BwD,qBAA7B,CAAvB;AACA,QAAIiG,WAAW,GAAG7F,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,aAAhB,EAA+ByD,oBAA/B,CAAzB;AACA,QAAI4F,UAAU,GAAGzF,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,QAAI6E,MAAM,GAAGhE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B+C,YAA1B,CAApB;AACA,QAAIoF,MAAM,GAAGvE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B+C,YAA1B,CAApB;AACA,QAAIqF,MAAM,GAAGxE,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,QAAhB,EAA0B+C,YAA1B,CAApB;AACAiB,IAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAiB,MAAKqG,QAAS,SAA/B,CAApB;AACA,QAAIO,SAAJ,EACEpC,KAAK,CAACvD,IAAN,CAAY,eAAc2F,SAAS,KAAK,IAAd,GAAqB,UAArB,GAAkCA,SAAU,EAAtE;AACF,QAAI6C,WAAJ,EACEjF,KAAK,CAACvD,IAAN,CAAY,kBAAiB,OAAOwI,WAAP,KAAuB,QAAvB,GAAkCA,WAAlC,GAAgDC,IAAI,CAACC,SAAL,CAAeF,WAAf,CAA4B,EAAzG;AACF,QAAIJ,UAAJ,EACE7E,KAAK,CAACvD,IAAN,CAAY,gBAAeoI,UAAW,EAAtC;AACF,QAAIzB,MAAJ,EACEpD,KAAK,CAACvD,IAAN,CAAY,YAAW2G,MAAO,EAA9B;AACF,QAAIO,MAAJ,EACE3D,KAAK,CAACvD,IAAN,CAAY,YAAWkH,MAAO,EAA9B;AACF,QAAIC,MAAJ,EACE5D,KAAK,CAACvD,IAAN,CAAY,YAAWmH,MAAO,EAA9B;AACF,WAAO5D,KAAP;AACD;;AACD,WAASoF,aAAT,CAAuBC,QAAvB,EAAiC;AAC/B,QAAIC,iBAAiB,GAAG,IAAIC,GAAJ,EAAxB;AACA,QAAIC,eAAe,GAAG,IAAID,GAAJ,EAAtB;AACA,QAAIE,cAAc,GAAG,IAAIF,GAAJ,EAArB;AACA,QAAIG,cAAc,GAAG,IAAIH,GAAJ,EAArB;AACA,QAAII,WAAW,GAAG,CAAlB;AACA,QAAIC,QAAQ,GAAG,KAAf;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,MAAM,GAAG,IAAI3K,UAAJ,CAAe,KAAK,IAApB,CAAb;AACA,QAAI4K,UAAU,GAAG,CAAjB;;AACA,QAAIC,cAAc,GAAIC,KAAD,IAAW;AAC9B,UAAIC,KAAK,GAAGH,UAAU,GAAGE,KAAK,CAAC5K,MAA/B;;AACA,UAAI6K,KAAK,GAAGJ,MAAM,CAACzK,MAAnB,EAA2B;AACzB,YAAI8K,IAAI,GAAG,IAAIhL,UAAJ,CAAe+K,KAAK,GAAG,CAAvB,CAAX;AACAC,QAAAA,IAAI,CAACpJ,GAAL,CAAS+I,MAAT;AACAA,QAAAA,MAAM,GAAGK,IAAT;AACD;;AACDL,MAAAA,MAAM,CAAC/I,GAAP,CAAWkJ,KAAX,EAAkBF,UAAlB;AACAA,MAAAA,UAAU,IAAIE,KAAK,CAAC5K,MAApB;AACA,UAAI2B,MAAM,GAAG,CAAb;;AACA,aAAOA,MAAM,GAAG,CAAT,IAAc+I,UAArB,EAAiC;AAC/B,YAAI1K,MAAM,GAAG6B,YAAY,CAAC4I,MAAD,EAAS9I,MAAT,CAAzB;;AACA,YAAIA,MAAM,GAAG,CAAT,GAAa3B,MAAb,GAAsB0K,UAA1B,EAAsC;AACpC;AACD;;AACD/I,QAAAA,MAAM,IAAI,CAAV;AACAoJ,QAAAA,oBAAoB,CAACN,MAAM,CAAChK,QAAP,CAAgBkB,MAAhB,EAAwBA,MAAM,GAAG3B,MAAjC,CAAD,CAApB;AACA2B,QAAAA,MAAM,IAAI3B,MAAV;AACD;;AACD,UAAI2B,MAAM,GAAG,CAAb,EAAgB;AACd8I,QAAAA,MAAM,CAACO,UAAP,CAAkB,CAAlB,EAAqBrJ,MAArB,EAA6B+I,UAA7B;AACAA,QAAAA,UAAU,IAAI/I,MAAd;AACD;AACF,KAvBD;;AAwBA,QAAIsJ,UAAU,GAAG,MAAM;AACrBX,MAAAA,QAAQ,GAAG,IAAX;;AACA,WAAK,IAAIY,QAAT,IAAqBlB,iBAAiB,CAACjB,MAAlB,EAArB,EAAiD;AAC/CmC,QAAAA,QAAQ,CAAC,yBAAD,EAA4B,IAA5B,CAAR;AACD;;AACDlB,MAAAA,iBAAiB,CAACmB,KAAlB;;AACA,WAAK,IAAIC,SAAT,IAAsBhB,cAAc,CAACrB,MAAf,EAAtB,EAA+C;AAC7CqC,QAAAA,SAAS,CAACC,MAAV,CAAiB,yBAAjB;AACD;;AACDjB,MAAAA,cAAc,CAACe,KAAf;;AACA,WAAK,IAAID,QAAT,IAAqBf,cAAc,CAACpB,MAAf,EAArB,EAA8C;AAC5C,YAAI;AACFmC,UAAAA,QAAQ,CAAC,IAAI9J,KAAJ,CAAU,yBAAV,CAAD,EAAuC,IAAvC,CAAR;AACD,SAFD,CAEE,OAAOhD,CAAP,EAAU;AACVkN,UAAAA,OAAO,CAACC,KAAR,CAAcnN,CAAd;AACD;AACF;;AACD+L,MAAAA,cAAc,CAACgB,KAAf;AACD,KAlBD;;AAmBA,QAAIK,WAAW,GAAG,CAACC,IAAD,EAAO/O,KAAP,EAAcwO,QAAd,KAA2B;AAC3C,UAAIZ,QAAJ,EACE,OAAOY,QAAQ,CAAC,kCAAD,EAAqC,IAArC,CAAf;AACF,UAAI9K,EAAE,GAAGmK,aAAa,EAAtB;AACAP,MAAAA,iBAAiB,CAACtI,GAAlB,CAAsBtB,EAAtB,EAA0B,CAACmL,KAAD,EAAQG,QAAR,KAAqB;AAC7C,YAAI;AACFR,UAAAA,QAAQ,CAACK,KAAD,EAAQG,QAAR,CAAR;AACD,SAFD,SAEU;AACR,cAAID,IAAJ,EACEA,IAAI,CAACE,KAAL;AACH;AACF,OAPD;AAQA,UAAIF,IAAJ,EACEA,IAAI,CAACG,GAAL;AACF7B,MAAAA,QAAQ,CAAC8B,YAAT,CAAsBvM,YAAY,CAAC;AAAEc,QAAAA,EAAF;AAAMC,QAAAA,SAAS,EAAE,IAAjB;AAAuB3D,QAAAA;AAAvB,OAAD,CAAlC;AACD,KAfD;;AAgBA,QAAIoP,YAAY,GAAG,CAAC1L,EAAD,EAAK1D,KAAL,KAAe;AAChC,UAAI4N,QAAJ,EACE,MAAM,IAAIlJ,KAAJ,CAAU,kCAAV,CAAN;AACF2I,MAAAA,QAAQ,CAAC8B,YAAT,CAAsBvM,YAAY,CAAC;AAAEc,QAAAA,EAAF;AAAMC,QAAAA,SAAS,EAAE,KAAjB;AAAwB3D,QAAAA;AAAxB,OAAD,CAAlC;AACD,KAJD;;AAKA,QAAIqP,aAAa,GAAG,CAAC3L,EAAD,EAAK4L,OAAL,KAAiBtO,OAAO,CAAC,IAAD,EAAO,IAAP,EAAa,aAAa;AACpE,UAAI;AACF,gBAAQsO,OAAO,CAACC,OAAhB;AACE,eAAK,MAAL;AAAa;AACXH,cAAAA,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ;AACA;AACD;;AACD,eAAK,OAAL;AAAc;AACZ,kBAAI8K,QAAQ,GAAGhB,eAAe,CAACzM,GAAhB,CAAoBuO,OAAO,CAACvP,GAA5B,CAAf;AACA,kBAAI,CAACyO,QAAL,EACEY,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ,CADF,KAGE0L,YAAY,CAAC1L,EAAD,EAAK,MAAM8K,QAAQ,CAACc,OAAD,CAAnB,CAAZ;AACF;AACD;;AACD,eAAK,SAAL;AAAgB;AACd,kBAAId,QAAQ,GAAGhB,eAAe,CAACzM,GAAhB,CAAoBuO,OAAO,CAACvP,GAA5B,CAAf;AACA,kBAAI,CAACyO,QAAL,EACEY,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ,CADF,KAGE0L,YAAY,CAAC1L,EAAD,EAAK,MAAM8K,QAAQ,CAACc,OAAD,CAAnB,CAAZ;AACF;AACD;;AACD,eAAK,MAAL;AAAa;AACX,kBAAId,QAAQ,GAAGhB,eAAe,CAACzM,GAAhB,CAAoBuO,OAAO,CAACvP,GAA5B,CAAf;AACA,kBAAI,CAACyO,QAAL,EACEY,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ,CADF,KAGE0L,YAAY,CAAC1L,EAAD,EAAK,MAAM8K,QAAQ,CAACc,OAAD,CAAnB,CAAZ;AACF;AACD;;AACD,eAAK,eAAL;AAAsB;AACpB,kBAAIZ,SAAS,GAAGhB,cAAc,CAAC3M,GAAf,CAAmBuO,OAAO,CAACE,OAA3B,CAAhB;AACA,kBAAId,SAAS,IAAIA,SAAS,CAACe,SAA3B,EACEf,SAAS,CAACe,SAAV,CAAoBH,OAAO,CAACI,IAA5B;AACFN,cAAAA,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ;AACA;AACD;;AACD,eAAK,YAAL;AAAmB;AACjB,kBAAIgL,SAAS,GAAGhB,cAAc,CAAC3M,GAAf,CAAmBuO,OAAO,CAACE,OAA3B,CAAhB;AACA,kBAAId,SAAJ,EACEA,SAAS,CAACC,MAAV,CAAiBW,OAAO,CAACT,KAAzB;AACFO,cAAAA,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ;AACA;AACD;;AACD,eAAK,eAAL;AAAsB;AACpB,kBAAI8K,QAAQ,GAAGf,cAAc,CAAC1M,GAAf,CAAmBuO,OAAO,CAACK,OAA3B,CAAf;;AACA,kBAAI;AACF,oBAAInB,QAAJ,EACEA,QAAQ,CAAC,IAAD,EAAOc,OAAO,CAACI,IAAf,CAAR;AACH,eAHD,CAGE,OAAOE,GAAP,EAAY;AACZhB,gBAAAA,OAAO,CAACC,KAAR,CAAce,GAAd;AACD;;AACDR,cAAAA,YAAY,CAAC1L,EAAD,EAAK,EAAL,CAAZ;AACA;AACD;;AACD;AACE,kBAAM,IAAIgB,KAAJ,CAAW,mBAAD,GAAsB4K,OAAO,CAACC,OAAxC,CAAN;AAvDJ;AAyDD,OA1DD,CA0DE,OAAO7N,CAAP,EAAU;AACV0N,QAAAA,YAAY,CAAC1L,EAAD,EAAK;AAAEmM,UAAAA,MAAM,EAAE,CAACC,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAc,IAAd,EAAoB,KAAK,CAAzB,EAA4B,EAA5B,CAAtB;AAAV,SAAL,CAAZ;AACD;AACF,KA9D2C,CAA5C;;AA+DA,QAAI0C,aAAa,GAAG,IAApB;;AACA,QAAI1B,oBAAoB,GAAIpK,KAAD,IAAW;AACpC,UAAI8L,aAAJ,EAAmB;AACjBA,QAAAA,aAAa,GAAG,KAAhB;AACA,YAAIC,aAAa,GAAGC,MAAM,CAACC,YAAP,CAAoB,GAAGjM,KAAvB,CAApB;;AACA,YAAI+L,aAAa,KAAK,SAAtB,EAAiC;AAC/B,gBAAM,IAAItL,KAAJ,CAAW,uCAAsC,SAAU,mCAAkCwI,IAAI,CAACC,SAAL,CAAe6C,aAAf,CAA8B,EAA3H,CAAN;AACD;;AACD;AACD;;AACD,UAAInN,MAAM,GAAGmB,YAAY,CAACC,KAAD,CAAzB;;AACA,UAAIpB,MAAM,CAACc,SAAX,EAAsB;AACpB0L,QAAAA,aAAa,CAACxM,MAAM,CAACa,EAAR,EAAYb,MAAM,CAAC7C,KAAnB,CAAb;AACD,OAFD,MAEO;AACL,YAAIwO,QAAQ,GAAGlB,iBAAiB,CAACvM,GAAlB,CAAsB8B,MAAM,CAACa,EAA7B,CAAf;AACA4J,QAAAA,iBAAiB,CAAC6C,MAAlB,CAAyBtN,MAAM,CAACa,EAAhC;AACA,YAAIb,MAAM,CAAC7C,KAAP,CAAa6O,KAAjB,EACEL,QAAQ,CAAC3L,MAAM,CAAC7C,KAAP,CAAa6O,KAAd,EAAqB,EAArB,CAAR,CADF,KAGEL,QAAQ,CAAC,IAAD,EAAO3L,MAAM,CAAC7C,KAAd,CAAR;AACH;AACF,KApBD;;AAqBA,QAAIoQ,aAAa,GAAG,CAACC,cAAD,EAAiBnE,OAAjB,EAA0BoE,QAA1B,EAAoCC,KAApC,KAA8CvP,OAAO,CAAC,IAAD,EAAO,IAAP,EAAa,aAAa;AACjG,UAAIwP,gBAAgB,GAAG,EAAvB;AACA,UAAIC,cAAc,GAAG,EAArB;AACA,UAAIC,kBAAkB,GAAG,EAAzB;AACA,UAAIC,eAAe,GAAG,EAAtB;AACA,UAAIC,cAAc,GAAG,CAArB;AACA,UAAIpM,CAAC,GAAG,CAAR;AACA,UAAIqM,cAAc,GAAG,EAArB;AACA3E,MAAAA,OAAO,GAAG,CAAC,GAAGA,OAAJ,CAAV;;AACA,WAAK,IAAI3I,IAAT,IAAiB2I,OAAjB,EAA0B;AACxB,YAAI1I,IAAI,GAAG,EAAX;AACA,YAAI,OAAOD,IAAP,KAAgB,QAApB,EACE,MAAM,IAAImB,KAAJ,CAAW,mBAAkBF,CAAE,oBAA/B,CAAN;AACF,YAAI1D,IAAI,GAAGsG,OAAO,CAAC7D,IAAD,EAAOC,IAAP,EAAa,MAAb,EAAqB+C,YAArB,CAAlB;AACA,YAAI,OAAOzF,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,EAAzC,EACE,MAAM,IAAI4D,KAAJ,CAAW,mBAAkBF,CAAE,oBAA/B,CAAN;;AACF,YAAI;AACF,cAAIsM,KAAK,GAAG1J,OAAO,CAAC7D,IAAD,EAAOC,IAAP,EAAa,OAAb,EAAsBmD,cAAtB,CAAnB;AACA,cAAI,OAAOmK,KAAP,KAAiB,UAArB,EACE,MAAM,IAAIpM,KAAJ,CAAW,oCAAX,CAAN;AACF8C,UAAAA,oBAAoB,CAACjE,IAAD,EAAOC,IAAP,EAAc,aAAY0J,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAA/C,CAApB;AACA,cAAIiQ,MAAM,GAAG;AACXjQ,YAAAA,IADW;AAEXkQ,YAAAA,SAAS,EAAE,EAFA;AAGXC,YAAAA,MAAM,EAAE;AAHG,WAAb;AAKAzM,UAAAA,CAAC;AACD,cAAI0M,OAAO,GAAGJ,KAAK,CAAC;AAClBT,YAAAA,cADkB;;AAElBc,YAAAA,OAAO,CAACC,SAAD,EAAY;AACjB,kBAAIC,cAAc,GAAI,6DAAtB;AACA,kBAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI7M,KAAJ,CAAU2M,cAAV,CAAD,EAA4BhE,QAA5B,EAAsC,SAAtC,CAApC;AACAmD,cAAAA,gBAAgB,CAAC/L,IAAjB,CAAsB;AAAE3D,gBAAAA,IAAF;AAAQ0N,gBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,gBAAAA,IAAI,EAAEF;AAAnC,eAAtB;AACD,aANiB;;AAOlBG,YAAAA,KAAK,CAACL,SAAD,EAAY;AACf,kBAAIC,cAAc,GAAI,2DAAtB;AACA,kBAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI7M,KAAJ,CAAU2M,cAAV,CAAD,EAA4BhE,QAA5B,EAAsC,OAAtC,CAApC;AACAoD,cAAAA,cAAc,CAAChM,IAAf,CAAoB;AAAE3D,gBAAAA,IAAF;AAAQ0N,gBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,gBAAAA,IAAI,EAAEF;AAAnC,eAApB;AACD,aAXiB;;AAYlBN,YAAAA,SAAS,CAACrJ,OAAD,EAAUyJ,SAAV,EAAqB;AAC5B,kBAAIC,cAAc,GAAI,+DAAtB;AACA,kBAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI7M,KAAJ,CAAU2M,cAAV,CAAD,EAA4BhE,QAA5B,EAAsC,WAAtC,CAApC;AACA,kBAAIqE,KAAK,GAAG,EAAZ;AACA,kBAAIC,MAAM,GAAGvK,OAAO,CAACO,OAAD,EAAU+J,KAAV,EAAiB,QAAjB,EAA2BlL,YAA3B,CAApB;AACA,kBAAIoL,SAAS,GAAGxK,OAAO,CAACO,OAAD,EAAU+J,KAAV,EAAiB,WAAjB,EAA8BnL,YAA9B,CAAvB;AACAiB,cAAAA,oBAAoB,CAACG,OAAD,EAAU+J,KAAV,EAAkB,kCAAiCxE,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAAxE,CAApB;AACA,kBAAI6Q,MAAM,IAAI,IAAd,EACE,MAAM,IAAIjN,KAAJ,CAAW,sCAAX,CAAN;AACF,kBAAIhB,EAAE,GAAGkN,cAAc,EAAvB;AACAF,cAAAA,kBAAkB,CAAChN,EAAD,CAAlB,GAAyB;AAAE5C,gBAAAA,IAAF;AAAQ0N,gBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,gBAAAA,IAAI,EAAEF;AAAnC,eAAzB;AACAP,cAAAA,MAAM,CAACC,SAAP,CAAiBvM,IAAjB,CAAsB;AAAEf,gBAAAA,EAAF;AAAMiO,gBAAAA,MAAM,EAAEA,MAAM,CAACE,MAArB;AAA6BD,gBAAAA,SAAS,EAAEA,SAAS,IAAI;AAArD,eAAtB;AACD,aAxBiB;;AAyBlBX,YAAAA,MAAM,CAACtJ,OAAD,EAAUyJ,SAAV,EAAqB;AACzB,kBAAIC,cAAc,GAAI,4DAAtB;AACA,kBAAIC,cAAc,GAAGC,eAAe,CAAC,IAAI7M,KAAJ,CAAU2M,cAAV,CAAD,EAA4BhE,QAA5B,EAAsC,QAAtC,CAApC;AACA,kBAAIqE,KAAK,GAAG,EAAZ;AACA,kBAAIC,MAAM,GAAGvK,OAAO,CAACO,OAAD,EAAU+J,KAAV,EAAiB,QAAjB,EAA2BlL,YAA3B,CAApB;AACA,kBAAIoL,SAAS,GAAGxK,OAAO,CAACO,OAAD,EAAU+J,KAAV,EAAiB,WAAjB,EAA8BnL,YAA9B,CAAvB;AACAiB,cAAAA,oBAAoB,CAACG,OAAD,EAAU+J,KAAV,EAAkB,+BAA8BxE,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAArE,CAApB;AACA,kBAAI6Q,MAAM,IAAI,IAAd,EACE,MAAM,IAAIjN,KAAJ,CAAW,mCAAX,CAAN;AACF,kBAAIhB,EAAE,GAAGkN,cAAc,EAAvB;AACAD,cAAAA,eAAe,CAACjN,EAAD,CAAf,GAAsB;AAAE5C,gBAAAA,IAAF;AAAQ0N,gBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,gBAAAA,IAAI,EAAEF;AAAnC,eAAtB;AACAP,cAAAA,MAAM,CAACE,MAAP,CAAcxM,IAAd,CAAmB;AAAEf,gBAAAA,EAAF;AAAMiO,gBAAAA,MAAM,EAAEA,MAAM,CAACE,MAArB;AAA6BD,gBAAAA,SAAS,EAAEA,SAAS,IAAI;AAArD,eAAnB;AACD;;AArCiB,WAAD,CAAnB;AAuCA,cAAIV,OAAJ,EACE,MAAMA,OAAN;AACFL,UAAAA,cAAc,CAACpM,IAAf,CAAoBsM,MAApB;AACD,SArDD,CAqDE,OAAOrP,CAAP,EAAU;AACV,iBAAO;AAAEoQ,YAAAA,EAAE,EAAE,KAAN;AAAajD,YAAAA,KAAK,EAAEnN,CAApB;AAAuBqQ,YAAAA,UAAU,EAAEjR;AAAnC,WAAP;AACD;AACF;;AACD,YAAM0N,QAAQ,GAAIc,OAAD,IAAatO,OAAO,CAAC,IAAD,EAAO,IAAP,EAAa,aAAa;AAC7D,gBAAQsO,OAAO,CAACC,OAAhB;AACE,eAAK,OAAL;AAAc;AACZ,kBAAIP,QAAQ,GAAG;AAAEa,gBAAAA,MAAM,EAAE,EAAV;AAAcmC,gBAAAA,QAAQ,EAAE;AAAxB,eAAf;AACA,oBAAM5Q,OAAO,CAACP,GAAR,CAAY2P,gBAAgB,CAAC/G,GAAjB,CAAsBwI,EAAD,IAAQjR,OAAO,CAAC,IAAD,EAAO,CAACiR,EAAD,CAAP,EAAa,iBAAgD;AAAA,oBAArC;AAAEnR,kBAAAA,IAAF;AAAQ0N,kBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,kBAAAA;AAA7B,iBAAqC;;AACjH,oBAAI;AACF,sBAAIU,MAAM,GAAG,MAAMd,SAAS,EAA5B;;AACA,sBAAIc,MAAM,IAAI,IAAd,EAAoB;AAClB,wBAAI,OAAOA,MAAP,KAAkB,QAAtB,EACE,MAAM,IAAIxN,KAAJ,CAAW,yCAAwCwI,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,sBAAxE,CAAN;AACF,wBAAI0C,IAAI,GAAG,EAAX;AACA,wBAAIqM,MAAM,GAAGzI,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,QAAf,EAAyBoD,WAAzB,CAApB;AACA,wBAAIoL,QAAQ,GAAG5K,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,UAAf,EAA2BoD,WAA3B,CAAtB;AACAY,oBAAAA,oBAAoB,CAAC0K,MAAD,EAAS1O,IAAT,EAAgB,qCAAoC0J,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAAzE,CAApB;AACA,wBAAI+O,MAAM,IAAI,IAAd,EACEb,QAAQ,CAACa,MAAT,CAAgBpL,IAAhB,CAAqB,GAAG0N,gBAAgB,CAACtC,MAAD,EAAS,QAAT,EAAmBU,KAAnB,EAA0BzP,IAA1B,CAAxC;AACF,wBAAIkR,QAAQ,IAAI,IAAhB,EACEhD,QAAQ,CAACgD,QAAT,CAAkBvN,IAAlB,CAAuB,GAAG0N,gBAAgB,CAACH,QAAD,EAAW,UAAX,EAAuBzB,KAAvB,EAA8BzP,IAA9B,CAA1C;AACH;AACF,iBAdD,CAcE,OAAOY,CAAP,EAAU;AACVsN,kBAAAA,QAAQ,CAACa,MAAT,CAAgBpL,IAAhB,CAAqBqL,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAckD,KAAd,EAAqBiB,IAAI,IAAIA,IAAI,EAAjC,EAAqC1Q,IAArC,CAA1C;AACD;AACF,eAlBqD,CAApC,CAAZ,CAAN;AAmBA,qBAAOkO,QAAP;AACD;;AACD,eAAK,SAAL;AAAgB;AACd,kBAAIA,QAAQ,GAAG,EAAf;AAAA,kBAAmBlO,IAAI,GAAG,EAA1B;AAAA,kBAA8BsQ,SAA9B;AAAA,kBAAyCI,IAAzC;;AACA,mBAAK,IAAI9N,EAAT,IAAe4L,OAAO,CAAC8C,GAAvB,EAA4B;AAC1B,oBAAI;AACF,mBAAC;AAAEtR,oBAAAA,IAAF;AAAQ0N,oBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,oBAAAA;AAA7B,sBAAsCd,kBAAkB,CAAChN,EAAD,CAAzD;AACA,sBAAIwO,MAAM,GAAG,MAAMd,SAAS,CAAC;AAC3B7E,oBAAAA,IAAI,EAAE+C,OAAO,CAAC/C,IADa;AAE3B8F,oBAAAA,QAAQ,EAAE/C,OAAO,CAAC+C,QAFS;AAG3BT,oBAAAA,SAAS,EAAEtC,OAAO,CAACsC,SAHQ;AAI3BhF,oBAAAA,UAAU,EAAE0C,OAAO,CAAC1C,UAJO;AAK3B0F,oBAAAA,IAAI,EAAEhD,OAAO,CAACgD,IALa;AAM3BC,oBAAAA,UAAU,EAAEhC,KAAK,CAACiC,IAAN,CAAWlD,OAAO,CAACiD,UAAnB;AANe,mBAAD,CAA5B;;AAQA,sBAAIL,MAAM,IAAI,IAAd,EAAoB;AAClB,wBAAI,OAAOA,MAAP,KAAkB,QAAtB,EACE,MAAM,IAAIxN,KAAJ,CAAW,2CAA0CwI,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,sBAA1E,CAAN;AACF,wBAAI0C,IAAI,GAAG,EAAX;AACA,wBAAIuO,UAAU,GAAG3K,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6B+C,YAA7B,CAAxB;AACA,wBAAIgG,IAAI,GAAGnF,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,MAAf,EAAuB+C,YAAvB,CAAlB;AACA,wBAAIqL,SAAS,GAAGxK,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,WAAf,EAA4B+C,YAA5B,CAAvB;AACA,wBAAI4E,QAAQ,GAAG/D,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,UAAf,EAA2B4C,aAA3B,CAAtB;AACA,wBAAIqM,WAAW,GAAGrL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,aAAf,EAA8B4C,aAA9B,CAAzB;AACA,wBAAImM,UAAU,GAAGnL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6B2C,aAA7B,CAAxB;AACA,wBAAI0J,MAAM,GAAGzI,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,QAAf,EAAyBoD,WAAzB,CAApB;AACA,wBAAIoL,QAAQ,GAAG5K,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,UAAf,EAA2BoD,WAA3B,CAAtB;AACA,wBAAI8L,UAAU,GAAGtL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6BoD,WAA7B,CAAxB;AACA,wBAAI+L,SAAS,GAAGvL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,WAAf,EAA4BoD,WAA5B,CAAvB;AACAY,oBAAAA,oBAAoB,CAAC0K,MAAD,EAAS1O,IAAT,EAAgB,uCAAsC0J,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAA3E,CAApB;AACAkO,oBAAAA,QAAQ,CAACtL,EAAT,GAAcA,EAAd;AACA,wBAAIqO,UAAU,IAAI,IAAlB,EACE/C,QAAQ,CAAC+C,UAAT,GAAsBA,UAAtB;AACF,wBAAIxF,IAAI,IAAI,IAAZ,EACEyC,QAAQ,CAACzC,IAAT,GAAgBA,IAAhB;AACF,wBAAIqF,SAAS,IAAI,IAAjB,EACE5C,QAAQ,CAAC4C,SAAT,GAAqBA,SAArB;AACF,wBAAIzG,QAAQ,IAAI,IAAhB,EACE6D,QAAQ,CAAC7D,QAAT,GAAoBA,QAApB;AACF,wBAAIsH,WAAW,IAAI,IAAnB,EACEzD,QAAQ,CAACyD,WAAT,GAAuBA,WAAvB;AACF,wBAAIF,UAAU,IAAI,IAAlB,EACEvD,QAAQ,CAACuD,UAAT,GAAsBhC,KAAK,CAACqC,KAAN,CAAYL,UAAZ,CAAtB;AACF,wBAAI1C,MAAM,IAAI,IAAd,EACEb,QAAQ,CAACa,MAAT,GAAkBsC,gBAAgB,CAACtC,MAAD,EAAS,QAAT,EAAmBU,KAAnB,EAA0BzP,IAA1B,CAAlC;AACF,wBAAIkR,QAAQ,IAAI,IAAhB,EACEhD,QAAQ,CAACgD,QAAT,GAAoBG,gBAAgB,CAACH,QAAD,EAAW,UAAX,EAAuBzB,KAAvB,EAA8BzP,IAA9B,CAApC;AACF,wBAAI4R,UAAU,IAAI,IAAlB,EACE1D,QAAQ,CAAC0D,UAAT,GAAsBG,mBAAmB,CAACH,UAAD,EAAa,YAAb,CAAzC;AACF,wBAAIC,SAAS,IAAI,IAAjB,EACE3D,QAAQ,CAAC2D,SAAT,GAAqBE,mBAAmB,CAACF,SAAD,EAAY,WAAZ,CAAxC;AACF;AACD;AACF,iBAhDD,CAgDE,OAAOjR,CAAP,EAAU;AACV,yBAAO;AAAEgC,oBAAAA,EAAF;AAAMmM,oBAAAA,MAAM,EAAE,CAACC,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAckD,KAAd,EAAqBiB,IAAI,IAAIA,IAAI,EAAjC,EAAqC1Q,IAArC,CAAtB;AAAd,mBAAP;AACD;AACF;;AACD,qBAAOkO,QAAP;AACD;;AACD,eAAK,MAAL;AAAa;AACX,kBAAIA,QAAQ,GAAG,EAAf;AAAA,kBAAmBlO,IAAI,GAAG,EAA1B;AAAA,kBAA8BsQ,SAA9B;AAAA,kBAAyCI,IAAzC;;AACA,mBAAK,IAAI9N,EAAT,IAAe4L,OAAO,CAAC8C,GAAvB,EAA4B;AAC1B,oBAAI;AACF,mBAAC;AAAEtR,oBAAAA,IAAF;AAAQ0N,oBAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,oBAAAA;AAA7B,sBAAsCb,eAAe,CAACjN,EAAD,CAAtD;AACA,sBAAIwO,MAAM,GAAG,MAAMd,SAAS,CAAC;AAC3B7E,oBAAAA,IAAI,EAAE+C,OAAO,CAAC/C,IADa;AAE3BqF,oBAAAA,SAAS,EAAEtC,OAAO,CAACsC,SAFQ;AAG3BW,oBAAAA,UAAU,EAAEhC,KAAK,CAACiC,IAAN,CAAWlD,OAAO,CAACiD,UAAnB;AAHe,mBAAD,CAA5B;;AAKA,sBAAIL,MAAM,IAAI,IAAd,EAAoB;AAClB,wBAAI,OAAOA,MAAP,KAAkB,QAAtB,EACE,MAAM,IAAIxN,KAAJ,CAAW,wCAAuCwI,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,sBAAvE,CAAN;AACF,wBAAI0C,IAAI,GAAG,EAAX;AACA,wBAAIuO,UAAU,GAAG3K,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6B+C,YAA7B,CAAxB;AACA,wBAAIoG,QAAQ,GAAGvF,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,UAAf,EAA2B2D,wBAA3B,CAAtB;AACA,wBAAIyF,UAAU,GAAGxF,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6B+C,YAA7B,CAAxB;AACA,wBAAIgM,UAAU,GAAGnL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6B2C,aAA7B,CAAxB;AACA,wBAAIiF,MAAM,GAAGhE,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,QAAf,EAAyB+C,YAAzB,CAApB;AACA,wBAAIsJ,MAAM,GAAGzI,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,QAAf,EAAyBoD,WAAzB,CAApB;AACA,wBAAIoL,QAAQ,GAAG5K,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,UAAf,EAA2BoD,WAA3B,CAAtB;AACA,wBAAI8L,UAAU,GAAGtL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,YAAf,EAA6BoD,WAA7B,CAAxB;AACA,wBAAI+L,SAAS,GAAGvL,OAAO,CAAC8K,MAAD,EAAS1O,IAAT,EAAe,WAAf,EAA4BoD,WAA5B,CAAvB;AACAY,oBAAAA,oBAAoB,CAAC0K,MAAD,EAAS1O,IAAT,EAAgB,oCAAmC0J,IAAI,CAACC,SAAL,CAAerM,IAAf,CAAqB,EAAxE,CAApB;AACAkO,oBAAAA,QAAQ,CAACtL,EAAT,GAAcA,EAAd;AACA,wBAAIqO,UAAU,IAAI,IAAlB,EACE/C,QAAQ,CAAC+C,UAAT,GAAsBA,UAAtB;AACF,wBAAIpF,QAAQ,YAAYvJ,UAAxB,EACE4L,QAAQ,CAACrC,QAAT,GAAoBA,QAApB,CADF,KAEK,IAAIA,QAAQ,IAAI,IAAhB,EACHqC,QAAQ,CAACrC,QAAT,GAAoBxJ,UAAU,CAACwJ,QAAD,CAA9B;AACF,wBAAIC,UAAU,IAAI,IAAlB,EACEoC,QAAQ,CAACpC,UAAT,GAAsBA,UAAtB;AACF,wBAAI2F,UAAU,IAAI,IAAlB,EACEvD,QAAQ,CAACuD,UAAT,GAAsBhC,KAAK,CAACqC,KAAN,CAAYL,UAAZ,CAAtB;AACF,wBAAInH,MAAM,IAAI,IAAd,EACE4D,QAAQ,CAAC5D,MAAT,GAAkBA,MAAlB;AACF,wBAAIyE,MAAM,IAAI,IAAd,EACEb,QAAQ,CAACa,MAAT,GAAkBsC,gBAAgB,CAACtC,MAAD,EAAS,QAAT,EAAmBU,KAAnB,EAA0BzP,IAA1B,CAAlC;AACF,wBAAIkR,QAAQ,IAAI,IAAhB,EACEhD,QAAQ,CAACgD,QAAT,GAAoBG,gBAAgB,CAACH,QAAD,EAAW,UAAX,EAAuBzB,KAAvB,EAA8BzP,IAA9B,CAApC;AACF,wBAAI4R,UAAU,IAAI,IAAlB,EACE1D,QAAQ,CAAC0D,UAAT,GAAsBG,mBAAmB,CAACH,UAAD,EAAa,YAAb,CAAzC;AACF,wBAAIC,SAAS,IAAI,IAAjB,EACE3D,QAAQ,CAAC2D,SAAT,GAAqBE,mBAAmB,CAACF,SAAD,EAAY,WAAZ,CAAxC;AACF;AACD;AACF,iBA5CD,CA4CE,OAAOjR,CAAP,EAAU;AACV,yBAAO;AAAEgC,oBAAAA,EAAF;AAAMmM,oBAAAA,MAAM,EAAE,CAACC,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAckD,KAAd,EAAqBiB,IAAI,IAAIA,IAAI,EAAjC,EAAqC1Q,IAArC,CAAtB;AAAd,mBAAP;AACD;AACF;;AACD,qBAAOkO,QAAP;AACD;;AACD;AACE,kBAAM,IAAItK,KAAJ,CAAW,mBAAD,GAAsB4K,OAAO,CAACC,OAAxC,CAAN;AAvIJ;AAyID,OA1IoC,CAArC;;AA2IA,UAAIuD,iBAAiB,GAAG,CAACZ,MAAD,EAASa,cAAT,EAAyBjR,IAAzB,KAAkCA,IAAI,EAA9D;;AACA,UAAI2O,cAAc,CAACnN,MAAf,GAAwB,CAA5B,EAA+B;AAC7BwP,QAAAA,iBAAiB,GAAG,CAACZ,MAAD,EAASa,cAAT,EAAyBjR,IAAzB,KAAkC;AACpD,WAAC,MAAMd,OAAO,CAAC,IAAD,EAAO,IAAP,EAAa,aAAa;AACtC,iBAAK,MAAM;AAAEF,cAAAA,IAAF;AAAQ0N,cAAAA,QAAQ,EAAE4C,SAAlB;AAA6BI,cAAAA;AAA7B,aAAX,IAAkDf,cAAlD,EAAkE;AAChE,kBAAI;AACF,sBAAMW,SAAS,CAACc,MAAD,CAAf;AACD,eAFD,CAEE,OAAOxQ,CAAP,EAAU;AACVwQ,gBAAAA,MAAM,CAACrC,MAAP,CAAcpL,IAAd,CAAmB,MAAM,IAAIrD,OAAJ,CAAaC,OAAD,IAAa0R,cAAc,CAACrR,CAAD,EAAIZ,IAAJ,EAAU0Q,IAAI,IAAIA,IAAI,EAAtB,EAA0BnQ,OAA1B,CAAvC,CAAzB;AACD;AACF;AACF,WARa,CAAd,IAQMU,IARN,CAQWD,IARX;AASD,SAVD;AAWD;;AACD,UAAIkR,QAAQ,GAAG,CAAf;AACA,aAAO;AACLlB,QAAAA,EAAE,EAAE,IADC;AAELjB,QAAAA,cAFK;AAGLiC,QAAAA,iBAHK;AAILG,QAAAA,UAAU,EAAE;AACV/D,UAAAA,GAAG,GAAG;AACJ,gBAAI,EAAE8D,QAAF,KAAe,CAAnB,EACExF,eAAe,CAACxI,GAAhB,CAAoBsL,QAApB,EAA8B9B,QAA9B;AACH,WAJS;;AAKVS,UAAAA,KAAK,GAAG;AACN,gBAAI,EAAE+D,QAAF,KAAe,CAAnB,EACExF,eAAe,CAAC2C,MAAhB,CAAuBG,QAAvB;AACH;;AARS;AAJP,OAAP;AAeD,KAlPwE,CAAzE;;AAmPA,QAAI4C,cAAc,GAAG,CAACnE,IAAD,EAAOpH,OAAP,EAAgB2H,OAAhB,KAA4B;AAC/C,UAAI9L,IAAI,GAAG,EAAX;AACA,UAAI2P,IAAI,GAAG/L,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,MAAhB,EAAwBkD,aAAxB,CAAlB;AACA,UAAI0M,IAAI,GAAGhM,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,MAAhB,EAAwB+C,YAAxB,CAAlB;AACA,UAAI8M,QAAQ,GAAGjM,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,UAAhB,EAA4B+C,YAA5B,CAAtB;AACA,UAAIkJ,SAAS,GAAGrI,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,WAAhB,EAA6BmD,cAA7B,CAAvB;AACA,UAAI6I,OAAO,GAAG7B,WAAW,EAAzB;AACA,UAAIgB,MAAJ;AACA,UAAI2E,IAAI,GAAG,IAAIlS,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC1CqN,QAAAA,MAAM,GAAIE,KAAD,IAAW;AAClBnB,UAAAA,cAAc,CAACyC,MAAf,CAAsBX,OAAtB;AACA,cAAIX,KAAK,KAAK,IAAd,EACEvN,MAAM,CAAC,IAAIoD,KAAJ,CAAUmK,KAAV,CAAD,CAAN,CADF,KAGExN,OAAO;AACV,SAND;AAOD,OARU,CAAX;AASAiO,MAAAA,OAAO,CAAC9M,KAAR,GAAgB;AAAEgN,QAAAA;AAAF,OAAhB;AACAhI,MAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAiB,iBAAjB,CAApB;AACA,UAAI2P,IAAI,KAAK,KAAK,CAAlB,EACE7D,OAAO,CAAC9M,KAAR,CAAc2Q,IAAd,GAAqBA,IAArB;AACF,UAAIC,IAAI,KAAK,KAAK,CAAlB,EACE9D,OAAO,CAAC9M,KAAR,CAAc4Q,IAAd,GAAqBA,IAArB;AACF,UAAIC,QAAQ,KAAK,KAAK,CAAtB,EACE/D,OAAO,CAAC9M,KAAR,CAAc6Q,QAAd,GAAyBA,QAAzB;AACF3F,MAAAA,cAAc,CAAC1I,GAAf,CAAmBwK,OAAnB,EAA4B;AAC1BC,QAAAA,SAD0B;AAE1Bd,QAAAA;AAF0B,OAA5B;AAIA,aAAO;AACL2E,QAAAA,IADK;;AAELC,QAAAA,IAAI,GAAG;AACLzE,UAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,YAAAA,OAAO,EAAE,YAAX;AAAyBC,YAAAA;AAAzB,WAAP,EAA2C,MAAM,CAC3D,CADU,CAAX;AAED;;AALI,OAAP;AAOD,KApCD;;AAqCA,UAAMgE,oBAAoB,GAAG,SAA7B;AACA,UAAMC,wBAAwB,GAAG,QAAjC;;AACA,QAAIC,YAAY,GAAIhE,IAAD,IAAU;AAC3B,UAAI3P,GAAG,GAAG+N,YAAY,EAAtB;AACA,YAAM6F,OAAO,GAAGC,iBAAiB,EAAjC;AACA,UAAI1H,OAAJ;AACA,UAAI;AAAE6C,QAAAA,IAAF;AAAQpH,QAAAA,OAAR;AAAiBM,QAAAA,KAAjB;AAAwBuG,QAAAA;AAAxB,UAAqCkB,IAAzC;;AACA,UAAI,OAAO/H,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,YAAI3H,KAAK,GAAG2H,OAAO,CAACuE,OAApB;;AACA,YAAIlM,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpB,cAAI,CAACqD,KAAK,CAACiD,OAAN,CAActG,KAAd,CAAL,EACE,MAAM,IAAI0E,KAAJ,CAAW,4BAAX,CAAN;AACFwH,UAAAA,OAAO,GAAGlM,KAAV;AACD;AACF;;AACD,UAAI+S,cAAc,GAAG,CAACrR,CAAD,EAAIqQ,UAAJ,EAAgBP,IAAhB,EAAsB1P,IAAtB,KAA+B;AAClD,YAAIkG,KAAK,GAAG,EAAZ;;AACA,YAAI;AACFD,UAAAA,YAAY,CAACC,KAAD,EAAQL,OAAR,EAAiB,EAAjB,EAAqBM,KAArB,EAA4BuL,oBAA5B,CAAZ;AACD,SAFD,CAEE,OAAOK,EAAP,EAAW,CACZ;;AACD,cAAMC,OAAO,GAAGhE,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAcsG,OAAd,EAAuBnC,IAAvB,EAA6BO,UAA7B,CAArC;AACAjD,QAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,UAAAA,OAAO,EAAE,OAAX;AAAoBvH,UAAAA,KAApB;AAA2B6G,UAAAA,KAAK,EAAEiF;AAAlC,SAAP,EAAoD,MAAM;AACnEA,UAAAA,OAAO,CAACC,MAAR,GAAiBJ,OAAO,CAACnB,IAAR,CAAasB,OAAO,CAACC,MAArB,CAAjB;AACAjS,UAAAA,IAAI,CAACgS,OAAD,CAAJ;AACD,SAHU,CAAX;AAID,OAXD;;AAYA,UAAIE,WAAW,GAAG,CAACtS,CAAD,EAAIqQ,UAAJ,KAAmB;AACnCgB,QAAAA,cAAc,CAACrR,CAAD,EAAIqQ,UAAJ,EAAgB,KAAK,CAArB,EAAyBlD,KAAD,IAAW;AAC/CL,UAAAA,QAAQ,CAACyF,mBAAmB,CAAC,cAAD,EAAiB,CAACpF,KAAD,CAAjB,EAA0B,EAA1B,CAApB,EAAmD,IAAnD,CAAR;AACD,SAFa,CAAd;AAGD,OAJD;;AAKA,UAAI3C,OAAO,IAAIA,OAAO,CAAC5I,MAAR,GAAiB,CAAhC,EAAmC;AACjC,YAAI+J,QAAQ,CAAC6G,MAAb,EACE,OAAOF,WAAW,CAAC,IAAItP,KAAJ,CAAU,6CAAV,CAAD,EAA2D,EAA3D,CAAlB;AACF0L,QAAAA,aAAa,CAACzI,OAAD,EAAUuE,OAAV,EAAmBnM,GAAnB,EAAwB4T,OAAxB,CAAb,CAA8C5R,IAA9C,CAAoDmQ,MAAD,IAAY;AAC7D,cAAI,CAACA,MAAM,CAACJ,EAAZ,EAAgB;AACdkC,YAAAA,WAAW,CAAC9B,MAAM,CAACrD,KAAR,EAAeqD,MAAM,CAACH,UAAtB,CAAX;AACD,WAFD,MAEO;AACL,gBAAI;AACFoC,cAAAA,oBAAoB,CAAC1T,aAAa,CAACL,cAAc,CAAC,EAAD,EAAKsP,IAAL,CAAf,EAA2B;AAC3D3P,gBAAAA,GAD2D;AAE3D4T,gBAAAA,OAF2D;AAG3DZ,gBAAAA,cAH2D;AAI3DlC,gBAAAA,cAAc,EAAEqB,MAAM,CAACrB,cAJoC;AAK3DiC,gBAAAA,iBAAiB,EAAEZ,MAAM,CAACY,iBALiC;AAM3DG,gBAAAA,UAAU,EAAEf,MAAM,CAACe;AANwC,eAA3B,CAAd,CAApB;AAQD,aATD,CASE,OAAOvR,CAAP,EAAU;AACVsS,cAAAA,WAAW,CAACtS,CAAD,EAAI,EAAJ,CAAX;AACD;AACF;AACF,SAjBD,EAiBIA,CAAD,IAAOsS,WAAW,CAACtS,CAAD,EAAI,EAAJ,CAjBrB;AAkBD,OArBD,MAqBO;AACL,YAAI;AACFyS,UAAAA,oBAAoB,CAAC1T,aAAa,CAACL,cAAc,CAAC,EAAD,EAAKsP,IAAL,CAAf,EAA2B;AAC3D3P,YAAAA,GAD2D;AAE3D4T,YAAAA,OAF2D;AAG3DZ,YAAAA,cAH2D;AAI3DlC,YAAAA,cAAc,EAAE,IAJ2C;AAK3DiC,YAAAA,iBAAiB,EAAE,CAACZ,MAAD,EAASkC,eAAT,EAA0BtS,IAA1B,KAAmCA,IAAI,EALC;AAM3DmR,YAAAA,UAAU,EAAE;AAN+C,WAA3B,CAAd,CAApB;AAQD,SATD,CASE,OAAOvR,CAAP,EAAU;AACVsS,UAAAA,WAAW,CAACtS,CAAD,EAAI,EAAJ,CAAX;AACD;AACF;AACF,KAjED;;AAkEA,QAAIyS,oBAAoB,GAAG,SAcrB;AAAA,UAdsB;AAC1BtK,QAAAA,QAD0B;AAE1BkF,QAAAA,IAAI,EAAEsF,UAFoB;AAG1BC,QAAAA,YAH0B;AAI1B3M,QAAAA,OAJ0B;AAK1BM,QAAAA,KAL0B;AAM1BsM,QAAAA,SAN0B;AAO1B/F,QAAAA,QAP0B;AAQ1BzO,QAAAA,GAR0B;AAS1B4T,QAAAA,OAT0B;AAU1BZ,QAAAA,cAV0B;AAW1BlC,QAAAA,cAX0B;AAY1BiC,QAAAA,iBAZ0B;AAa1BG,QAAAA;AAb0B,OActB;AACJ,YAAMlE,IAAI,GAAG;AACXG,QAAAA,GAAG,GAAG;AACJ,cAAI+D,UAAJ,EACEA,UAAU,CAAC/D,GAAX;AACF,cAAImF,UAAJ,EACEA,UAAU,CAACnF,GAAX;AACH,SANU;;AAOXD,QAAAA,KAAK,GAAG;AACN,cAAIgE,UAAJ,EACEA,UAAU,CAAChE,KAAX;AACF,cAAIoF,UAAJ,EACEA,UAAU,CAACpF,KAAX;AACH;;AAZU,OAAb;AAcA,UAAInF,YAAY,GAAG,CAACuD,QAAQ,CAACmH,SAA7B;AACA,UAAI;AACFxK,QAAAA,OADE;AAEFhC,QAAAA,KAFE;AAGF9E,QAAAA,KAHE;AAIF+G,QAAAA,aAJE;AAKFC,QAAAA,eALE;AAMF4B,QAAAA,aANE;AAOFG,QAAAA,WAPE;AAQFc,QAAAA,SARE;AASFzC,QAAAA;AATE,UAUAV,oBAAoB,CAACC,QAAD,EAAWlC,OAAX,EAAoBM,KAApB,EAA2BuL,oBAA3B,EAAiD1J,YAAjD,CAVxB;AAWA,UAAIwF,OAAO,GAAG;AACZC,QAAAA,OAAO,EAAE,OADG;AAEZxP,QAAAA,GAFY;AAGZiK,QAAAA,OAHY;AAIZhC,QAAAA,KAJY;AAKZ9E,QAAAA,KALY;AAMZ+G,QAAAA,aANY;AAOZC,QAAAA,eAPY;AAQZ4B,QAAAA,aAAa,EAAEA,aAAa,IAAIyI,SARpB;AASZtI,QAAAA,WATY;AAUZc,QAAAA;AAVY,OAAd;AAYA,UAAI8D,cAAJ,EACEvB,OAAO,CAACpD,OAAR,GAAkB2E,cAAlB;AACF,UAAI4D,MAAM,GAAGH,YAAY,IAAIpB,cAAc,CAACnE,IAAD,EAAOuF,YAAP,EAAqBhF,OAArB,CAA3C;AACA,UAAIoF,OAAJ;AACA,UAAInB,IAAJ;;AACA,UAAIoB,oBAAoB,GAAG,CAAC3F,QAAD,EAAWkD,MAAX,KAAsB;AAC/C,YAAIlD,QAAQ,CAAC4F,WAAb,EACE1C,MAAM,CAAC0C,WAAP,GAAqB5F,QAAQ,CAAC4F,WAAT,CAAqBnL,GAArB,CAAyBoL,kBAAzB,CAArB;AACF,YAAI7F,QAAQ,CAACvE,QAAb,EACEyH,MAAM,CAACzH,QAAP,GAAkByC,IAAI,CAAC4H,KAAL,CAAW9F,QAAQ,CAACvE,QAApB,CAAlB;AACF,YAAIuE,QAAQ,CAAC+F,aAAT,KAA2B,KAAK,CAApC,EACEnG,OAAO,CAACoG,GAAR,CAAY5Q,UAAU,CAAC4K,QAAQ,CAAC+F,aAAV,CAAV,CAAmCE,OAAnC,CAA2C,KAA3C,EAAkD,EAAlD,CAAZ;AACH,OAPD;;AAQA,UAAIC,qBAAqB,GAAG,CAAClG,QAAD,EAAWoC,SAAX,KAAyB;AACnD,YAAIc,MAAM,GAAG;AACXrC,UAAAA,MAAM,EAAEsF,wBAAwB,CAACnG,QAAQ,CAACa,MAAV,EAAkB8D,OAAlB,CADrB;AAEX3B,UAAAA,QAAQ,EAAEmD,wBAAwB,CAACnG,QAAQ,CAACgD,QAAV,EAAoB2B,OAApB;AAFvB,SAAb;AAIAgB,QAAAA,oBAAoB,CAAC3F,QAAD,EAAWkD,MAAX,CAApB;AACAY,QAAAA,iBAAiB,CAACZ,MAAD,EAASa,cAAT,EAAyB,MAAM;AAC9C,cAAIb,MAAM,CAACrC,MAAP,CAAcvM,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,mBAAO8N,SAAS,CAAC6C,mBAAmB,CAAC,cAAD,EAAiB/B,MAAM,CAACrC,MAAxB,EAAgCqC,MAAM,CAACF,QAAvC,CAApB,EAAsE,IAAtE,CAAhB;AACD;;AACD,cAAIhD,QAAQ,CAACoG,SAAT,KAAuB,KAAK,CAAhC,EAAmC;AACjC,gBAAI,CAACV,OAAL,EAAc;AACZ,kBAAIW,UAAU,GAAG,KAAjB;;AACAX,cAAAA,OAAO,GAAG,MAAM,IAAItT,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/C,oBAAI+T,UAAU,IAAIzH,QAAlB,EACE,MAAM,IAAIlJ,KAAJ,CAAU,gBAAV,CAAN;AACFoK,gBAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,kBAAAA,OAAO,EAAE,SAAX;AAAsB6F,kBAAAA,SAAS,EAAEpG,QAAQ,CAACoG;AAA1C,iBAAP,EAA8D,CAACE,MAAD,EAASC,SAAT,KAAuB;AAC9F,sBAAID,MAAJ,EAAY;AACV,0BAAMxB,OAAO,GAAG;AAAE/B,sBAAAA,UAAU,EAAE,EAAd;AAAkBvM,sBAAAA,IAAI,EAAE8P,MAAxB;AAAgCE,sBAAAA,QAAQ,EAAE,IAA1C;AAAgDC,sBAAAA,KAAK,EAAE,EAAvD;AAA2D1B,sBAAAA,MAAM,EAAE,KAAK;AAAxE,qBAAhB;AACA,2BAAO3C,SAAS,CAAC6C,mBAAmB,CAAC,cAAD,EAAiB,CAACH,OAAD,CAAjB,EAA4B,EAA5B,CAApB,EAAqD,IAArD,CAAhB;AACD;;AACDoB,kBAAAA,qBAAqB,CAACK,SAAD,EAAY,CAACG,MAAD,EAASC,OAAT,KAAqB;AACpD,wBAAID,MAAJ,EACEpU,MAAM,CAACoU,MAAD,CAAN,CADF,KAGErU,OAAO,CAACsU,OAAD,CAAP;AACH,mBALoB,CAArB;AAMD,iBAXU,CAAX;AAYD,eAfe,CAAhB;;AAgBA5G,cAAAA,IAAI,CAACG,GAAL;;AACAwF,cAAAA,OAAO,CAACkB,OAAR,GAAkB,MAAM;AACtB,oBAAIP,UAAJ,EACE;AACFA,gBAAAA,UAAU,GAAG,IAAb;AACAvG,gBAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,kBAAAA,OAAO,EAAE,iBAAX;AAA8B6F,kBAAAA,SAAS,EAAEpG,QAAQ,CAACoG;AAAlD,iBAAP,EAAsE,MAAM,CACtF,CADU,CAAX;AAEArG,gBAAAA,IAAI,CAACE,KAAL;AACD,eAPD;AAQD;;AACDiD,YAAAA,MAAM,CAACwC,OAAP,GAAiBA,OAAjB;AACD;;AACD,cAAI1F,QAAQ,CAACW,OAAT,KAAqB,KAAK,CAA9B,EAAiC;AAC/B,gBAAI,CAAC4D,IAAL,EAAW;AACT,kBAAIsC,SAAS,GAAG,KAAhB;AACA9G,cAAAA,IAAI,CAACG,GAAL;;AACAqE,cAAAA,IAAI,GAAG,MAAM;AACX,oBAAIsC,SAAJ,EACE;AACFA,gBAAAA,SAAS,GAAG,IAAZ;AACApI,gBAAAA,cAAc,CAAC0C,MAAf,CAAsBnB,QAAQ,CAACW,OAA/B;AACAb,gBAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,kBAAAA,OAAO,EAAE,YAAX;AAAyBI,kBAAAA,OAAO,EAAEX,QAAQ,CAACW;AAA3C,iBAAP,EAA6D,MAAM,CAC7E,CADU,CAAX;AAEAZ,gBAAAA,IAAI,CAACE,KAAL;AACD,eARD;;AASA,kBAAI3E,KAAJ,EAAW;AACTmD,gBAAAA,cAAc,CAACzI,GAAf,CAAmBgK,QAAQ,CAACW,OAA5B,EAAqC,CAACmG,gBAAD,EAAmBC,aAAnB,KAAqC;AACxE,sBAAID,gBAAJ,EAAsB;AACpB,wBAAIxL,KAAK,CAAC8B,SAAV,EACE9B,KAAK,CAAC8B,SAAN,CAAgB0J,gBAAhB,EAAkC,IAAlC;AACF;AACD;;AACD,sBAAIE,OAAO,GAAG;AACZnG,oBAAAA,MAAM,EAAEsF,wBAAwB,CAACY,aAAa,CAAClG,MAAf,EAAuB8D,OAAvB,CADpB;AAEZ3B,oBAAAA,QAAQ,EAAEmD,wBAAwB,CAACY,aAAa,CAAC/D,QAAf,EAAyB2B,OAAzB;AAFtB,mBAAd;AAIAgB,kBAAAA,oBAAoB,CAACoB,aAAD,EAAgBC,OAAhB,CAApB;AACAlD,kBAAAA,iBAAiB,CAACkD,OAAD,EAAUjD,cAAV,EAA0B,MAAM;AAC/C,wBAAIiD,OAAO,CAACnG,MAAR,CAAevM,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,0BAAIgH,KAAK,CAAC8B,SAAV,EACE9B,KAAK,CAAC8B,SAAN,CAAgB6H,mBAAmB,CAAC,cAAD,EAAiB+B,OAAO,CAACnG,MAAzB,EAAiCmG,OAAO,CAAChE,QAAzC,CAAnC,EAAuF,IAAvF;AACF;AACD;;AACD,wBAAI+D,aAAa,CAACX,SAAd,KAA4B,KAAK,CAArC,EACEY,OAAO,CAACtB,OAAR,GAAkBA,OAAlB;AACFsB,oBAAAA,OAAO,CAACzC,IAAR,GAAeA,IAAf;AACA,wBAAIjJ,KAAK,CAAC8B,SAAV,EACE9B,KAAK,CAAC8B,SAAN,CAAgB,IAAhB,EAAsB4J,OAAtB;AACH,mBAXgB,CAAjB;AAYD,iBAvBD;AAwBD;AACF;;AACD9D,YAAAA,MAAM,CAACqB,IAAP,GAAcA,IAAd;AACD;;AACDnC,UAAAA,SAAS,CAAC,IAAD,EAAOc,MAAP,CAAT;AACD,SA9EgB,CAAjB;AA+ED,OArFD;;AAsFA,UAAIhP,KAAK,IAAImK,QAAQ,CAACmH,SAAtB,EACE,MAAM,IAAI9P,KAAJ,CAAW,sCAAX,CAAN;AACF,UAAIuH,WAAW,IAAIoB,QAAQ,CAAC6G,MAA5B,EACE,MAAM,IAAIxP,KAAJ,CAAW,mDAAX,CAAN;AACF,UAAI4F,KAAK,IAAI+C,QAAQ,CAAC6G,MAAtB,EACE,MAAM,IAAIxP,KAAJ,CAAW,6CAAX,CAAN;AACFoK,MAAAA,WAAW,CAACC,IAAD,EAAOO,OAAP,EAAgB,CAACT,KAAD,EAAQG,QAAR,KAAqB;AAC9C,YAAIH,KAAJ,EACE,OAAOL,QAAQ,CAAC,IAAI9J,KAAJ,CAAUmK,KAAV,CAAD,EAAmB,IAAnB,CAAf;;AACF,YAAI4F,MAAJ,EAAY;AACV,cAAIwB,aAAa,GAAGjH,QAApB;AACA,cAAI6G,SAAS,GAAG,KAAhB;AACA9G,UAAAA,IAAI,CAACG,GAAL;AACA,cAAIgD,MAAM,GAAG;AACXiB,YAAAA,IAAI,EAAE8C,aAAa,CAAC9C,IADT;AAEXC,YAAAA,IAAI,EAAE6C,aAAa,CAAC7C,IAFT;AAGXE,YAAAA,IAAI,EAAEmB,MAAM,CAACnB,IAHF;;AAIXC,YAAAA,IAAI,GAAG;AACL,kBAAIsC,SAAJ,EACE;AACFA,cAAAA,SAAS,GAAG,IAAZ;AACApB,cAAAA,MAAM,CAAClB,IAAP;AACAxE,cAAAA,IAAI,CAACE,KAAL;AACD;;AAVU,WAAb;AAYAF,UAAAA,IAAI,CAACG,GAAL;AACAuF,UAAAA,MAAM,CAACnB,IAAP,CAAYvR,IAAZ,CAAiBgN,IAAI,CAACE,KAAtB,EAA6BF,IAAI,CAACE,KAAlC;AACA,iBAAOT,QAAQ,CAAC,IAAD,EAAO0D,MAAP,CAAf;AACD;;AACD,eAAOgD,qBAAqB,CAAClG,QAAD,EAAWR,QAAX,CAA5B;AACD,OAxBU,CAAX;AAyBD,KAvLD;;AAwLA,QAAI0H,UAAU,GAAG,SAA6D;AAAA,UAA5D;AAAErM,QAAAA,QAAF;AAAYkF,QAAAA,IAAZ;AAAkBoH,QAAAA,KAAlB;AAAyBxO,QAAAA,OAAzB;AAAkCM,QAAAA,KAAlC;AAAyCmO,QAAAA,EAAzC;AAA6C5H,QAAAA;AAA7C,OAA4D;AAC5E,YAAMmF,OAAO,GAAGC,iBAAiB,EAAjC;;AACA,UAAIyC,KAAK,GAAIC,SAAD,IAAe;AACzB,YAAI;AACF,cAAI,OAAOH,KAAP,KAAiB,QAArB,EACE,MAAM,IAAIzR,KAAJ,CAAU,2CAAV,CAAN;AACF,cAAIsD,KAAK,GAAGgF,wBAAwB,CAACnD,QAAD,EAAWlC,OAAX,EAAoBM,KAApB,EAA2BwL,wBAA3B,CAApC;AACA,cAAInE,OAAO,GAAG;AACZC,YAAAA,OAAO,EAAE,WADG;AAEZvH,YAAAA,KAFY;AAGZuO,YAAAA,OAAO,EAAED,SAAS,KAAK,IAHX;AAIZH,YAAAA,KAAK,EAAEG,SAAS,KAAK,IAAd,GAAqBA,SAArB,GAAiCH;AAJ5B,WAAd;AAMArH,UAAAA,WAAW,CAACC,IAAD,EAAOO,OAAP,EAAgB,CAACT,KAAD,EAAQG,QAAR,KAAqB;AAC9C,gBAAIH,KAAJ,EACE,OAAOL,QAAQ,CAAC,IAAI9J,KAAJ,CAAUmK,KAAV,CAAD,EAAmB,IAAnB,CAAf;AACF,gBAAIgB,MAAM,GAAGsF,wBAAwB,CAACnG,QAAQ,CAACa,MAAV,EAAkB8D,OAAlB,CAArC;AACA,gBAAI3B,QAAQ,GAAGmD,wBAAwB,CAACnG,QAAQ,CAACgD,QAAV,EAAoB2B,OAApB,CAAvC;AACA,gBAAI6C,WAAW,GAAG,CAAlB;;AACA,gBAAI/U,IAAI,GAAG,MAAM,EAAE+U,WAAF,KAAkB,CAAlB,IAAuBhI,QAAQ,CAAC,IAAD,EAAO;AAAEwD,cAAAA,QAAF;AAAYyE,cAAAA,IAAI,EAAEzH,QAAQ,CAACyH,IAA3B;AAAiChN,cAAAA,GAAG,EAAEuF,QAAQ,CAACvF;AAA/C,aAAP,CAAhD;;AACA,gBAAIoG,MAAM,CAACvM,MAAP,GAAgB,CAApB,EACE,OAAOkL,QAAQ,CAACyF,mBAAmB,CAAC,kBAAD,EAAqBpE,MAArB,EAA6BmC,QAA7B,CAApB,EAA4D,IAA5D,CAAf;;AACF,gBAAIhD,QAAQ,CAAC0H,MAAb,EAAqB;AACnBF,cAAAA,WAAW;AACXJ,cAAAA,EAAE,CAACO,QAAH,CAAY3H,QAAQ,CAACyH,IAArB,EAA2B,CAAC7G,GAAD,EAAMjD,QAAN,KAAmB;AAC5C,oBAAIiD,GAAG,KAAK,IAAZ,EAAkB;AAChBpB,kBAAAA,QAAQ,CAACoB,GAAD,EAAM,IAAN,CAAR;AACD,iBAFD,MAEO;AACLZ,kBAAAA,QAAQ,CAACyH,IAAT,GAAgB9J,QAAhB;AACAlL,kBAAAA,IAAI;AACL;AACF,eAPD;AAQD;;AACD,gBAAIuN,QAAQ,CAAC4H,KAAb,EAAoB;AAClBJ,cAAAA,WAAW;AACXJ,cAAAA,EAAE,CAACO,QAAH,CAAY3H,QAAQ,CAACvF,GAArB,EAA0B,CAACmG,GAAD,EAAMjD,QAAN,KAAmB;AAC3C,oBAAIiD,GAAG,KAAK,IAAZ,EAAkB;AAChBpB,kBAAAA,QAAQ,CAACoB,GAAD,EAAM,IAAN,CAAR;AACD,iBAFD,MAEO;AACLZ,kBAAAA,QAAQ,CAACvF,GAAT,GAAekD,QAAf;AACAlL,kBAAAA,IAAI;AACL;AACF,eAPD;AAQD;;AACDA,YAAAA,IAAI;AACL,WAhCU,CAAX;AAiCD,SA3CD,CA2CE,OAAOC,CAAP,EAAU;AACV,cAAIsG,KAAK,GAAG,EAAZ;;AACA,cAAI;AACFD,YAAAA,YAAY,CAACC,KAAD,EAAQL,OAAR,EAAiB,EAAjB,EAAqBM,KAArB,EAA4BwL,wBAA5B,CAAZ;AACD,WAFD,CAEE,OAAOI,EAAP,EAAW,CACZ;;AACD,gBAAMhF,KAAK,GAAGiB,qBAAqB,CAACpO,CAAD,EAAI2L,QAAJ,EAAcsG,OAAd,EAAuB,KAAK,CAA5B,EAA+B,EAA/B,CAAnC;AACA7E,UAAAA,WAAW,CAACC,IAAD,EAAO;AAAEQ,YAAAA,OAAO,EAAE,OAAX;AAAoBvH,YAAAA,KAApB;AAA2B6G,YAAAA;AAA3B,WAAP,EAA2C,MAAM;AAC1DA,YAAAA,KAAK,CAACkF,MAAN,GAAeJ,OAAO,CAACnB,IAAR,CAAa3D,KAAK,CAACkF,MAAnB,CAAf;AACAvF,YAAAA,QAAQ,CAACyF,mBAAmB,CAAC,kBAAD,EAAqB,CAACpF,KAAD,CAArB,EAA8B,EAA9B,CAApB,EAAuD,IAAvD,CAAR;AACD,WAHU,CAAX;AAID;AACF,OAxDD;;AAyDA,UAAI,OAAOsH,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAAC7S,MAAN,GAAe,OAAO,IAAvD,EAA6D;AAC3D,YAAI7B,IAAI,GAAG4U,KAAX;;AACAA,QAAAA,KAAK,GAAG,MAAMD,EAAE,CAACS,SAAH,CAAaV,KAAb,EAAoB1U,IAApB,CAAd;AACD;;AACD4U,MAAAA,KAAK,CAAC,IAAD,CAAL;AACD,KAhED;;AAiEA,QAAIS,eAAe,GAAG,SAAqD;AAAA,UAApD;AAAEjN,QAAAA,QAAF;AAAYkF,QAAAA,IAAZ;AAAkBgI,QAAAA,QAAlB;AAA4BpP,QAAAA,OAA5B;AAAqC6G,QAAAA;AAArC,OAAoD;AACzE,UAAI0D,MAAM,GAAGC,gBAAgB,CAAC4E,QAAD,EAAW,UAAX,EAAuB,IAAvB,EAA6B,EAA7B,CAA7B;AACA,UAAI,CAACpP,OAAL,EACE,MAAM,IAAIjD,KAAJ,CAAW,8BAA6BmF,QAAS,SAAjD,CAAN;AACF,UAAIrG,IAAI,GAAG,EAAX;AACA,UAAI8O,IAAI,GAAGlL,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,MAAhB,EAAwB+C,YAAxB,CAAlB;AACA,UAAI4B,KAAK,GAAGf,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyB4C,aAAzB,CAAnB;AACA,UAAI4Q,aAAa,GAAG5P,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,eAAhB,EAAiCkD,aAAjC,CAA3B;AACAc,MAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAiB,MAAKqG,QAAS,SAA/B,CAApB;AACA,UAAIyI,IAAI,KAAK,KAAK,CAAlB,EACE,MAAM,IAAI5N,KAAJ,CAAW,qBAAoBmF,QAAS,SAAxC,CAAN;AACF,UAAIyI,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,SAAjC,EACE,MAAM,IAAI5N,KAAJ,CAAW,iDAAgDmF,QAAS,SAApE,CAAN;AACF,UAAIyF,OAAO,GAAG;AACZC,QAAAA,OAAO,EAAE,aADG;AAEZwH,QAAAA,QAAQ,EAAE7E,MAFE;AAGZ+E,QAAAA,SAAS,EAAE3E,IAAI,KAAK;AAHR,OAAd;AAKA,UAAInK,KAAK,KAAK,KAAK,CAAnB,EACEmH,OAAO,CAACnH,KAAR,GAAgBA,KAAhB;AACF,UAAI6O,aAAa,KAAK,KAAK,CAA3B,EACE1H,OAAO,CAAC0H,aAAR,GAAwBA,aAAxB;AACFlI,MAAAA,WAAW,CAACC,IAAD,EAAOO,OAAP,EAAgB,CAACT,KAAD,EAAQG,QAAR,KAAqB;AAC9C,YAAIH,KAAJ,EACE,OAAOL,QAAQ,CAAC,IAAI9J,KAAJ,CAAUmK,KAAV,CAAD,EAAmB,IAAnB,CAAf;AACFL,QAAAA,QAAQ,CAAC,IAAD,EAAOQ,QAAQ,CAAC+H,QAAhB,CAAR;AACD,OAJU,CAAX;AAKD,KA3BD;;AA4BA,QAAIG,gBAAgB,GAAG,SAAqD;AAAA,UAApD;AAAErN,QAAAA,QAAF;AAAYkF,QAAAA,IAAZ;AAAkBtE,QAAAA,QAAlB;AAA4B9C,QAAAA,OAA5B;AAAqC6G,QAAAA;AAArC,OAAoD;AAC1E,UAAI7G,OAAO,KAAK,KAAK,CAArB,EACEA,OAAO,GAAG,EAAV;AACF,UAAInE,IAAI,GAAG,EAAX;AACA,UAAI2E,KAAK,GAAGf,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,OAAhB,EAAyB4C,aAAzB,CAAnB;AACA,UAAI+Q,OAAO,GAAG/P,OAAO,CAACO,OAAD,EAAUnE,IAAV,EAAgB,SAAhB,EAA2B4C,aAA3B,CAArB;AACAoB,MAAAA,oBAAoB,CAACG,OAAD,EAAUnE,IAAV,EAAiB,MAAKqG,QAAS,SAA/B,CAApB;AACA,UAAIyF,OAAO,GAAG;AACZC,QAAAA,OAAO,EAAE,kBADG;AAEZ9E,QAAAA;AAFY,OAAd;AAIA,UAAItC,KAAK,KAAK,KAAK,CAAnB,EACEmH,OAAO,CAACnH,KAAR,GAAgBA,KAAhB;AACF,UAAIgP,OAAO,KAAK,KAAK,CAArB,EACE7H,OAAO,CAAC6H,OAAR,GAAkBA,OAAlB;AACFrI,MAAAA,WAAW,CAACC,IAAD,EAAOO,OAAP,EAAgB,CAACT,KAAD,EAAQG,QAAR,KAAqB;AAC9C,YAAIH,KAAJ,EACE,OAAOL,QAAQ,CAAC,IAAI9J,KAAJ,CAAUmK,KAAV,CAAD,EAAmB,IAAnB,CAAf;AACFL,QAAAA,QAAQ,CAAC,IAAD,EAAOQ,QAAQ,CAACkD,MAAhB,CAAR;AACD,OAJU,CAAX;AAKD,KApBD;;AAqBA,WAAO;AACLjE,MAAAA,cADK;AAELM,MAAAA,UAFK;AAGL6I,MAAAA,OAAO,EAAE;AACP1D,QAAAA,YADO;AAEPjR,QAAAA,SAAS,EAAEyT,UAFJ;AAGP7T,QAAAA,cAAc,EAAEyU,eAHT;AAIP7U,QAAAA,eAAe,EAAEiV;AAJV;AAHJ,KAAP;AAUD;;AACD,WAAStD,iBAAT,GAA6B;AAC3B,UAAMnK,GAAG,GAAG,IAAI8D,GAAJ,EAAZ;AACA,QAAI8J,MAAM,GAAG,CAAb;AACA,WAAO;AACL7E,MAAAA,IAAI,CAAC9O,EAAD,EAAK;AACP,eAAO+F,GAAG,CAAC1I,GAAJ,CAAQ2C,EAAR,CAAP;AACD,OAHI;;AAILkP,MAAAA,KAAK,CAAC5S,KAAD,EAAQ;AACX,YAAIA,KAAK,KAAK,KAAK,CAAnB,EACE,OAAO,CAAC,CAAR;AACF,cAAM0D,EAAE,GAAG2T,MAAM,EAAjB;AACA5N,QAAAA,GAAG,CAACzE,GAAJ,CAAQtB,EAAR,EAAY1D,KAAZ;AACA,eAAO0D,EAAP;AACD;;AAVI,KAAP;AAYD;;AACD,WAAS6N,eAAT,CAAyB7P,CAAzB,EAA4B2L,QAA5B,EAAsCiK,KAAtC,EAA6C;AAC3C,QAAI9F,IAAJ;AACA,QAAI+F,KAAK,GAAG,KAAZ;AACA,WAAO,MAAM;AACX,UAAIA,KAAJ,EACE,OAAO/F,IAAP;AACF+F,MAAAA,KAAK,GAAG,IAAR;;AACA,UAAI;AACF,YAAIC,KAAK,GAAG,CAAC9V,CAAC,CAAC+V,KAAF,GAAU,EAAX,EAAeC,KAAf,CAAqB,IAArB,CAAZ;AACAF,QAAAA,KAAK,CAACG,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACA,YAAInC,QAAQ,GAAGoC,iBAAiB,CAACvK,QAAD,EAAWmK,KAAX,EAAkBF,KAAlB,CAAhC;;AACA,YAAI9B,QAAJ,EAAc;AACZhE,UAAAA,IAAI,GAAG;AAAEhM,YAAAA,IAAI,EAAE9D,CAAC,CAACoS,OAAV;AAAmB0B,YAAAA;AAAnB,WAAP;AACA,iBAAOhE,IAAP;AACD;AACF,OARD,CAQE,OAAOqC,EAAP,EAAW,CACZ;AACF,KAdD;AAeD;;AACD,WAAS/D,qBAAT,CAA+BpO,CAA/B,EAAkC2L,QAAlC,EAA4CkD,KAA5C,EAAmDiB,IAAnD,EAAyDO,UAAzD,EAAqE;AACnE,QAAIvM,IAAI,GAAG,gBAAX;AACA,QAAIgQ,QAAQ,GAAG,IAAf;;AACA,QAAI;AACFhQ,MAAAA,IAAI,GAAG,CAAC9D,CAAC,IAAIA,CAAC,CAACoS,OAAP,IAAkBpS,CAAnB,IAAwB,EAA/B;AACD,KAFD,CAEE,OAAOmS,EAAP,EAAW,CACZ;;AACD,QAAI;AACF2B,MAAAA,QAAQ,GAAGoC,iBAAiB,CAACvK,QAAD,EAAW,CAAC3L,CAAC,CAAC+V,KAAF,GAAU,EAAX,EAAeC,KAAf,CAAqB,IAArB,CAAX,EAAuC,EAAvC,CAA5B;AACD,KAFD,CAEE,OAAO7D,EAAP,EAAW,CACZ;;AACD,WAAO;AAAE9B,MAAAA,UAAF;AAAcvM,MAAAA,IAAd;AAAoBgQ,MAAAA,QAApB;AAA8BC,MAAAA,KAAK,EAAEjE,IAAI,GAAG,CAACA,IAAD,CAAH,GAAY,EAArD;AAAyDuC,MAAAA,MAAM,EAAExD,KAAK,GAAGA,KAAK,CAACqC,KAAN,CAAYlR,CAAZ,CAAH,GAAoB,CAAC;AAA3F,KAAP;AACD;;AACD,WAASkW,iBAAT,CAA2BvK,QAA3B,EAAqCmK,KAArC,EAA4CF,KAA5C,EAAmD;AACjD,QAAIO,EAAE,GAAG,SAAT;;AACA,QAAIxK,QAAQ,CAACyK,YAAT,IAAyB,CAACN,KAAK,CAAC,CAAD,CAAL,CAASO,UAAT,CAAoBF,EAApB,CAA1B,IAAqDL,KAAK,CAAC,CAAD,CAAL,CAASO,UAAT,CAAoBF,EAApB,CAAzD,EAAkF;AAChF,WAAK,IAAIrT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgT,KAAK,CAAClU,MAA1B,EAAkCkB,CAAC,EAAnC,EAAuC;AACrC,YAAIwT,IAAI,GAAGR,KAAK,CAAChT,CAAD,CAAhB;AACA,YAAI,CAACwT,IAAI,CAACD,UAAL,CAAgBF,EAAhB,CAAL,EACE;AACFG,QAAAA,IAAI,GAAGA,IAAI,CAACC,KAAL,CAAWJ,EAAE,CAACvU,MAAd,CAAP;;AACA,eAAO,IAAP,EAAa;AACX,cAAI4U,KAAK,GAAG,iCAAiCC,IAAjC,CAAsCH,IAAtC,CAAZ;;AACA,cAAIE,KAAJ,EAAW;AACTF,YAAAA,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAZ;AACA;AACD;;AACDA,UAAAA,KAAK,GAAG,2CAA2CC,IAA3C,CAAgDH,IAAhD,CAAR;;AACA,cAAIE,KAAJ,EAAW;AACTF,YAAAA,IAAI,GAAGE,KAAK,CAAC,CAAD,CAAZ;AACA;AACD;;AACDA,UAAAA,KAAK,GAAG,sBAAsBC,IAAtB,CAA2BH,IAA3B,CAAR;;AACA,cAAIE,KAAJ,EAAW;AACT,gBAAIvL,QAAJ;;AACA,gBAAI;AACFA,cAAAA,QAAQ,GAAGU,QAAQ,CAACyK,YAAT,CAAsBI,KAAK,CAAC,CAAD,CAA3B,EAAgC,MAAhC,CAAX;AACD,aAFD,CAEE,OAAOxW,CAAP,EAAU;AACV;AACD;;AACD,gBAAI0W,QAAQ,GAAGzL,QAAQ,CAAC+K,KAAT,CAAe,0BAAf,EAA2C,CAACQ,KAAK,CAAC,CAAD,CAAN,GAAY,CAAvD,KAA6D,EAA5E;AACA,gBAAIG,MAAM,GAAG,CAACH,KAAK,CAAC,CAAD,CAAN,GAAY,CAAzB;AACA,gBAAI5U,MAAM,GAAG8U,QAAQ,CAACH,KAAT,CAAeI,MAAf,EAAuBA,MAAM,GAAGf,KAAK,CAAChU,MAAtC,MAAkDgU,KAAlD,GAA0DA,KAAK,CAAChU,MAAhE,GAAyE,CAAtF;AACA,mBAAO;AACLgV,cAAAA,IAAI,EAAEJ,KAAK,CAAC,CAAD,CADN;AAELtG,cAAAA,SAAS,EAAE,MAFN;AAGLoG,cAAAA,IAAI,EAAE,CAACE,KAAK,CAAC,CAAD,CAHP;AAILG,cAAAA,MAAM,EAAElV,UAAU,CAACiV,QAAQ,CAACH,KAAT,CAAe,CAAf,EAAkBI,MAAlB,CAAD,CAAV,CAAsC/U,MAJzC;AAKLA,cAAAA,MAAM,EAAEH,UAAU,CAACiV,QAAQ,CAACH,KAAT,CAAeI,MAAf,EAAuBA,MAAM,GAAG/U,MAAhC,CAAD,CAAV,CAAoDA,MALvD;AAML8U,cAAAA,QAAQ,EAAEA,QAAQ,GAAG,IAAX,GAAkBZ,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAevO,IAAf,CAAoB,IAApB,CANvB;AAOL6O,cAAAA,UAAU,EAAE;AAPP,aAAP;AASD;;AACD;AACD;AACF;AACF;;AACD,WAAO,IAAP;AACD;;AACD,WAAStE,mBAAT,CAA6BzO,IAA7B,EAAmCqK,MAAnC,EAA2CmC,QAA3C,EAAqD;AACnD,QAAI7D,KAAK,GAAG,CAAZ;AACA,QAAIqK,OAAO,GAAG3I,MAAM,CAACvM,MAAP,GAAgB,CAAhB,GAAoB,EAApB,GAA0B,SAAQuM,MAAM,CAACvM,MAAO,SAAQuM,MAAM,CAACvM,MAAP,GAAgB,CAAhB,GAAoB,EAApB,GAAyB,GAAI,GAA5D,GAAiEuM,MAAM,CAACoI,KAAP,CAAa,CAAb,EAAgB9J,KAAK,GAAG,CAAxB,EAA2B1E,GAA3B,CAA+B,CAAC/H,CAAD,EAAI8C,CAAJ,KAAU;AAC/I,UAAIA,CAAC,KAAK2J,KAAV,EACE,OAAO,OAAP;AACF,UAAI,CAACzM,CAAC,CAAC8T,QAAP,EACE,OAAQ;AACd,SAAS9T,CAAC,CAAC8D,IAAK,EADV;AAEF,UAAI;AAAE8S,QAAAA,IAAF;AAAQN,QAAAA,IAAR;AAAcK,QAAAA;AAAd,UAAyB3W,CAAC,CAAC8T,QAA/B;AACA,UAAIiD,UAAU,GAAG/W,CAAC,CAACqQ,UAAF,GAAgB,YAAWrQ,CAAC,CAACqQ,UAAW,IAAxC,GAA8C,EAA/D;AACA,aAAQ;AACZ,EAAEuG,IAAK,IAAGN,IAAK,IAAGK,MAAO,YAAWI,UAAW,GAAE/W,CAAC,CAAC8D,IAAK,EADpD;AAED,KAVuG,EAUrGkE,IAVqG,CAUhG,EAVgG,CAAxG;AAWA,QAAImF,KAAK,GAAG,IAAInK,KAAJ,CAAW,GAAEc,IAAK,GAAEgT,OAAQ,EAA5B,CAAZ;AACA3J,IAAAA,KAAK,CAACgB,MAAN,GAAeA,MAAf;AACAhB,IAAAA,KAAK,CAACmD,QAAN,GAAiBA,QAAjB;AACA,WAAOnD,KAAP;AACD;;AACD,WAASsG,wBAAT,CAAkC4B,QAAlC,EAA4CxG,KAA5C,EAAmD;AACjD,SAAK,MAAMuD,OAAX,IAAsBiD,QAAtB,EAAgC;AAC9BjD,MAAAA,OAAO,CAACC,MAAR,GAAiBxD,KAAK,CAACiC,IAAN,CAAWsB,OAAO,CAACC,MAAnB,CAAjB;AACD;;AACD,WAAOgD,QAAP;AACD;;AACD,WAAS2B,gBAAT,CAA0BlD,QAA1B,EAAoC/N,KAApC,EAA2C;AACzC,QAAI+N,QAAQ,IAAI,IAAhB,EACE,OAAO,IAAP;AACF,QAAIhS,IAAI,GAAG,EAAX;AACA,QAAI8U,IAAI,GAAGlR,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,MAAjB,EAAyB+C,YAAzB,CAAlB;AACA,QAAIqL,SAAS,GAAGxK,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,WAAjB,EAA8B+C,YAA9B,CAAvB;AACA,QAAIyR,IAAI,GAAG5Q,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,MAAjB,EAAyBkD,aAAzB,CAAlB;AACA,QAAI2R,MAAM,GAAGjR,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,QAAjB,EAA2BkD,aAA3B,CAApB;AACA,QAAIpD,MAAM,GAAG8D,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,QAAjB,EAA2BkD,aAA3B,CAApB;AACA,QAAI0R,QAAQ,GAAGhR,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,UAAjB,EAA6B+C,YAA7B,CAAtB;AACA,QAAIgS,UAAU,GAAGnR,OAAO,CAACoO,QAAD,EAAWhS,IAAX,EAAiB,YAAjB,EAA+B+C,YAA/B,CAAxB;AACAiB,IAAAA,oBAAoB,CAACgO,QAAD,EAAWhS,IAAX,EAAiBiE,KAAjB,CAApB;AACA,WAAO;AACL6Q,MAAAA,IAAI,EAAEA,IAAI,IAAI,EADT;AAEL1G,MAAAA,SAAS,EAAEA,SAAS,IAAI,EAFnB;AAGLoG,MAAAA,IAAI,EAAEA,IAAI,IAAI,CAHT;AAILK,MAAAA,MAAM,EAAEA,MAAM,IAAI,CAJb;AAKL/U,MAAAA,MAAM,EAAEA,MAAM,IAAI,CALb;AAML8U,MAAAA,QAAQ,EAAEA,QAAQ,IAAI,EANjB;AAOLG,MAAAA,UAAU,EAAEA,UAAU,IAAI;AAPrB,KAAP;AASD;;AACD,WAASpG,gBAAT,CAA0B4E,QAA1B,EAAoC4B,QAApC,EAA8CpI,KAA9C,EAAqDqI,kBAArD,EAAyE;AACvE,QAAIC,aAAa,GAAG,EAApB;AACA,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,MAAMhF,OAAX,IAAsBiD,QAAtB,EAAgC;AAC9B,UAAIvT,IAAI,GAAG,EAAX;AACA,UAAIuO,UAAU,GAAG3K,OAAO,CAAC0M,OAAD,EAAUtQ,IAAV,EAAgB,YAAhB,EAA8B+C,YAA9B,CAAxB;AACA,UAAIf,IAAI,GAAG4B,OAAO,CAAC0M,OAAD,EAAUtQ,IAAV,EAAgB,MAAhB,EAAwB+C,YAAxB,CAAlB;AACA,UAAIiP,QAAQ,GAAGpO,OAAO,CAAC0M,OAAD,EAAUtQ,IAAV,EAAgB,UAAhB,EAA4BuD,kBAA5B,CAAtB;AACA,UAAI0O,KAAK,GAAGrO,OAAO,CAAC0M,OAAD,EAAUtQ,IAAV,EAAgB,OAAhB,EAAyBoD,WAAzB,CAAnB;AACA,UAAImN,MAAM,GAAG3M,OAAO,CAAC0M,OAAD,EAAUtQ,IAAV,EAAgB,QAAhB,EAA0B2C,aAA1B,CAApB;AACA,UAAIsB,KAAK,GAAI,cAAaqR,KAAM,QAAOH,QAAS,GAAhD;AACAnR,MAAAA,oBAAoB,CAACsM,OAAD,EAAUtQ,IAAV,EAAgBiE,KAAhB,CAApB;AACA,UAAIsR,UAAU,GAAG,EAAjB;;AACA,UAAItD,KAAJ,EAAW;AACT,aAAK,MAAMjE,IAAX,IAAmBiE,KAAnB,EAA0B;AACxB,cAAIuD,QAAQ,GAAG,EAAf;AACA,cAAIC,QAAQ,GAAG7R,OAAO,CAACoK,IAAD,EAAOwH,QAAP,EAAiB,MAAjB,EAAyBzS,YAAzB,CAAtB;AACA,cAAI2S,YAAY,GAAG9R,OAAO,CAACoK,IAAD,EAAOwH,QAAP,EAAiB,UAAjB,EAA6BjS,kBAA7B,CAA1B;AACAS,UAAAA,oBAAoB,CAACgK,IAAD,EAAOwH,QAAP,EAAiBvR,KAAjB,CAApB;AACAsR,UAAAA,UAAU,CAACtU,IAAX,CAAgB;AACde,YAAAA,IAAI,EAAEyT,QAAQ,IAAI,EADJ;AAEdzD,YAAAA,QAAQ,EAAEkD,gBAAgB,CAACQ,YAAD,EAAezR,KAAf;AAFZ,WAAhB;AAID;AACF;;AACDoR,MAAAA,aAAa,CAACpU,IAAd,CAAmB;AACjBsN,QAAAA,UAAU,EAAEA,UAAU,IAAI6G,kBADT;AAEjBpT,QAAAA,IAAI,EAAEA,IAAI,IAAI,EAFG;AAGjBgQ,QAAAA,QAAQ,EAAEkD,gBAAgB,CAAClD,QAAD,EAAW/N,KAAX,CAHT;AAIjBgO,QAAAA,KAAK,EAAEsD,UAJU;AAKjBhF,QAAAA,MAAM,EAAExD,KAAK,GAAGA,KAAK,CAACqC,KAAN,CAAYmB,MAAZ,CAAH,GAAyB,CAAC;AALtB,OAAnB;AAOA+E,MAAAA,KAAK;AACN;;AACD,WAAOD,aAAP;AACD;;AACD,WAAShG,mBAAT,CAA6BxG,MAA7B,EAAqCsM,QAArC,EAA+C;AAC7C,UAAMzG,MAAM,GAAG,EAAf;;AACA,SAAK,MAAMlS,KAAX,IAAoBqM,MAApB,EAA4B;AAC1B,UAAI,OAAOrM,KAAP,KAAiB,QAArB,EACE,MAAM,IAAI0E,KAAJ,CAAW,GAAEwI,IAAI,CAACC,SAAL,CAAewL,QAAf,CAAyB,8BAAtC,CAAN;AACFzG,MAAAA,MAAM,CAACzN,IAAP,CAAYzE,KAAZ;AACD;;AACD,WAAOkS,MAAP;AACD;;AACD,WAAS2C,kBAAT,QAAgD;AAAA,QAApB;AAAEtI,MAAAA,IAAF;AAAQI,MAAAA;AAAR,KAAoB;AAC9C,QAAInH,IAAI,GAAG,IAAX;AACA,WAAO;AACL+G,MAAAA,IADK;AAELI,MAAAA,QAFK;;AAGL,UAAInH,IAAJ,GAAW;AACT,YAAIA,IAAI,KAAK,IAAb,EACEA,IAAI,GAAGpB,UAAU,CAACuI,QAAD,CAAjB;AACF,eAAOnH,IAAP;AACD;;AAPI,KAAP;AASD,GAnjDS,CAqjDV;;;AACA,MAAI7C,OAAO,GAAG,SAAd;;AACA,MAAIR,KAAK,GAAIwF,OAAD,IAAawR,sBAAsB,GAAGhX,KAAzB,CAA+BwF,OAA/B,CAAzB;;AACA,MAAInF,KAAK,GAAG,MAAM;AAChB,UAAM,IAAIkC,KAAJ,CAAW,oCAAX,CAAN;AACD,GAFD;;AAGA,MAAIjC,SAAS,GAAG,CAAC0T,KAAD,EAAQxO,OAAR,KAAoBwR,sBAAsB,GAAG1W,SAAzB,CAAmC0T,KAAnC,EAA0CxO,OAA1C,CAApC;;AACA,MAAItF,cAAc,GAAG,CAAC0U,QAAD,EAAWpP,OAAX,KAAuBwR,sBAAsB,GAAG9W,cAAzB,CAAwC0U,QAAxC,EAAkDpP,OAAlD,CAA5C;;AACA,MAAI1F,eAAe,GAAG,CAACwI,QAAD,EAAW9C,OAAX,KAAuBwR,sBAAsB,GAAGlX,eAAzB,CAAyCwI,QAAzC,EAAmD9C,OAAnD,CAA7C;;AACA,MAAIvF,SAAS,GAAG,MAAM;AACpB,UAAM,IAAIsC,KAAJ,CAAW,wCAAX,CAAN;AACD,GAFD;;AAGA,MAAIhC,aAAa,GAAG,MAAM;AACxB,UAAM,IAAIgC,KAAJ,CAAW,4CAAX,CAAN;AACD,GAFD;;AAGA,MAAIpC,kBAAkB,GAAG,MAAM;AAC7B,UAAM,IAAIoC,KAAJ,CAAW,iDAAX,CAAN;AACD,GAFD;;AAGA,MAAIxC,mBAAmB,GAAG,MAAM;AAC9B,UAAM,IAAIwC,KAAJ,CAAW,kDAAX,CAAN;AACD,GAFD;;AAGA,MAAI0U,iBAAJ;AACA,MAAIC,gBAAJ;;AACA,MAAIF,sBAAsB,GAAG,MAAM;AACjC,QAAIE,gBAAJ,EACE,OAAOA,gBAAP;AACF,QAAID,iBAAJ,EACE,MAAM,IAAI1U,KAAJ,CAAU,gGAAV,CAAN;AACF,UAAM,IAAIA,KAAJ,CAAU,mDAAV,CAAN;AACD,GAND;;AAOA,MAAInC,UAAU,GAAIoF,OAAD,IAAa;AAC5BA,IAAAA,OAAO,GAAGD,yBAAyB,CAACC,OAAO,IAAI,EAAZ,CAAnC;AACA,QAAIE,OAAO,GAAGF,OAAO,CAACE,OAAtB;AACA,QAAIyR,SAAS,GAAG3R,OAAO,CAACG,MAAR,KAAmB,KAAnC;AACA,QAAI,CAACD,OAAL,EACE,MAAM,IAAInD,KAAJ,CAAU,mCAAV,CAAN;AACFmD,IAAAA,OAAO,IAAI,EAAX;AACA,QAAIuR,iBAAJ,EACE,MAAM,IAAI1U,KAAJ,CAAU,yCAAV,CAAN;AACF0U,IAAAA,iBAAiB,GAAGG,mBAAmB,CAAC1R,OAAD,EAAUyR,SAAV,CAAvC;AACAF,IAAAA,iBAAiB,CAACI,KAAlB,CAAwB,MAAM;AAC5BJ,MAAAA,iBAAiB,GAAG,KAAK,CAAzB;AACD,KAFD;AAGA,WAAOA,iBAAP;AACD,GAdD;;AAeA,MAAIG,mBAAmB,GAAG,CAAC1R,OAAD,EAAUyR,SAAV,KAAwBtY,OAAO,CAAC,KAAK,CAAN,EAAS,IAAT,EAAe,aAAa;AACnF,QAAIyY,GAAG,GAAG,MAAMC,KAAK,CAAC7R,OAAD,CAArB;AACA,QAAI,CAAC4R,GAAG,CAAC3H,EAAT,EACE,MAAM,IAAIpN,KAAJ,CAAW,sBAAqBwI,IAAI,CAACC,SAAL,CAAetF,OAAf,CAAwB,EAAxD,CAAN;AACF,QAAI8R,IAAI,GAAG,MAAMF,GAAG,CAACG,WAAJ,EAAjB;AACA,QAAInD,IAAI,GAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAtsBE;AAusBA,QAAI3O,MAAJ;;AACA,QAAIwR,SAAJ,EAAe;AACb,UAAIO,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACrD,IAAD,CAAT,EAAiB;AAAEnK,QAAAA,IAAI,EAAE;AAAR,OAAjB,CAAX;AACAxE,MAAAA,MAAM,GAAG,IAAIiS,MAAJ,CAAWC,GAAG,CAACC,eAAJ,CAAoBJ,IAApB,CAAX,CAAT;AACD,KAHD,MAGO;AACL,UAAIlQ,EAAE,GAAG,IAAIuQ,QAAJ,CAAa,aAAb,EAA4BzD,IAAI,GAAI,yCAApC,CAAT;AACA,UAAI0D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","sourcesContent":["(exports=>{\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// lib/npm/browser.ts\n__export(exports, {\n  analyzeMetafile: () => analyzeMetafile,\n  analyzeMetafileSync: () => analyzeMetafileSync,\n  build: () => build,\n  buildSync: () => buildSync,\n  formatMessages: () => formatMessages,\n  formatMessagesSync: () => formatMessagesSync,\n  initialize: () => initialize,\n  serve: () => serve,\n  transform: () => transform,\n  transformSync: () => transformSync,\n  version: () => version\n});\n\n// lib/shared/stdio_protocol.ts\nfunction encodePacket(packet) {\n  let visit = (value) => {\n    if (value === null) {\n      bb.write8(0);\n    } else if (typeof value === \"boolean\") {\n      bb.write8(1);\n      bb.write8(+value);\n    } else if (typeof value === \"number\") {\n      bb.write8(2);\n      bb.write32(value | 0);\n    } else if (typeof value === \"string\") {\n      bb.write8(3);\n      bb.write(encodeUTF8(value));\n    } else if (value instanceof Uint8Array) {\n      bb.write8(4);\n      bb.write(value);\n    } else if (value instanceof Array) {\n      bb.write8(5);\n      bb.write32(value.length);\n      for (let item of value) {\n        visit(item);\n      }\n    } else {\n      let keys = Object.keys(value);\n      bb.write8(6);\n      bb.write32(keys.length);\n      for (let key of keys) {\n        bb.write(encodeUTF8(key));\n        visit(value[key]);\n      }\n    }\n  };\n  let bb = new ByteBuffer();\n  bb.write32(0);\n  bb.write32(packet.id << 1 | +!packet.isRequest);\n  visit(packet.value);\n  writeUInt32LE(bb.buf, bb.len - 4, 0);\n  return bb.buf.subarray(0, bb.len);\n}\nfunction decodePacket(bytes) {\n  let visit = () => {\n    switch (bb.read8()) {\n      case 0:\n        return null;\n      case 1:\n        return !!bb.read8();\n      case 2:\n        return bb.read32();\n      case 3:\n        return decodeUTF8(bb.read());\n      case 4:\n        return bb.read();\n      case 5: {\n        let count = bb.read32();\n        let value2 = [];\n        for (let i = 0; i < count; i++) {\n          value2.push(visit());\n        }\n        return value2;\n      }\n      case 6: {\n        let count = bb.read32();\n        let value2 = {};\n        for (let i = 0; i < count; i++) {\n          value2[decodeUTF8(bb.read())] = visit();\n        }\n        return value2;\n      }\n      default:\n        throw new Error(\"Invalid packet\");\n    }\n  };\n  let bb = new ByteBuffer(bytes);\n  let id = bb.read32();\n  let isRequest = (id & 1) === 0;\n  id >>>= 1;\n  let value = visit();\n  if (bb.ptr !== bytes.length) {\n    throw new Error(\"Invalid packet\");\n  }\n  return { id, isRequest, value };\n}\nvar ByteBuffer = class {\n  constructor(buf = new Uint8Array(1024)) {\n    this.buf = buf;\n    this.len = 0;\n    this.ptr = 0;\n  }\n  _write(delta) {\n    if (this.len + delta > this.buf.length) {\n      let clone = new Uint8Array((this.len + delta) * 2);\n      clone.set(this.buf);\n      this.buf = clone;\n    }\n    this.len += delta;\n    return this.len - delta;\n  }\n  write8(value) {\n    let offset = this._write(1);\n    this.buf[offset] = value;\n  }\n  write32(value) {\n    let offset = this._write(4);\n    writeUInt32LE(this.buf, value, offset);\n  }\n  write(bytes) {\n    let offset = this._write(4 + bytes.length);\n    writeUInt32LE(this.buf, bytes.length, offset);\n    this.buf.set(bytes, offset + 4);\n  }\n  _read(delta) {\n    if (this.ptr + delta > this.buf.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    this.ptr += delta;\n    return this.ptr - delta;\n  }\n  read8() {\n    return this.buf[this._read(1)];\n  }\n  read32() {\n    return readUInt32LE(this.buf, this._read(4));\n  }\n  read() {\n    let length = this.read32();\n    let bytes = new Uint8Array(length);\n    let ptr = this._read(bytes.length);\n    bytes.set(this.buf.subarray(ptr, ptr + length));\n    return bytes;\n  }\n};\nvar encodeUTF8;\nvar decodeUTF8;\nif (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  encodeUTF8 = (text) => encoder.encode(text);\n  decodeUTF8 = (bytes) => decoder.decode(bytes);\n} else if (typeof Buffer !== \"undefined\") {\n  encodeUTF8 = (text) => {\n    let buffer = Buffer.from(text);\n    if (!(buffer instanceof Uint8Array)) {\n      buffer = new Uint8Array(buffer);\n    }\n    return buffer;\n  };\n  decodeUTF8 = (bytes) => {\n    let { buffer, byteOffset, byteLength } = bytes;\n    return Buffer.from(buffer, byteOffset, byteLength).toString();\n  };\n} else {\n  throw new Error(\"No UTF-8 codec found\");\n}\nfunction readUInt32LE(buffer, offset) {\n  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  buffer[offset++] = value;\n  buffer[offset++] = value >> 8;\n  buffer[offset++] = value >> 16;\n  buffer[offset++] = value >> 24;\n}\n\n// lib/shared/common.ts\nfunction validateTarget(target) {\n  target += \"\";\n  if (target.indexOf(\",\") >= 0)\n    throw new Error(`Invalid target: ${target}`);\n  return target;\n}\nvar canBeAnything = () => null;\nvar mustBeBoolean = (value) => typeof value === \"boolean\" ? null : \"a boolean\";\nvar mustBeBooleanOrObject = (value) => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\nvar mustBeString = (value) => typeof value === \"string\" ? null : \"a string\";\nvar mustBeRegExp = (value) => value instanceof RegExp ? null : \"a RegExp object\";\nvar mustBeInteger = (value) => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\nvar mustBeFunction = (value) => typeof value === \"function\" ? null : \"a function\";\nvar mustBeArray = (value) => Array.isArray(value) ? null : \"an array\";\nvar mustBeObject = (value) => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\nvar mustBeArrayOrRecord = (value) => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\nvar mustBeObjectOrNull = (value) => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\nvar mustBeStringOrBoolean = (value) => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\nvar mustBeStringOrObject = (value) => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\nvar mustBeStringOrArray = (value) => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\nvar mustBeStringOrUint8Array = (value) => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\nfunction getFlag(object, keys, key, mustBeFn) {\n  let value = object[key];\n  keys[key + \"\"] = true;\n  if (value === void 0)\n    return void 0;\n  let mustBe = mustBeFn(value);\n  if (mustBe !== null)\n    throw new Error(`\"${key}\" must be ${mustBe}`);\n  return value;\n}\nfunction checkForInvalidFlags(object, keys, where) {\n  for (let key in object) {\n    if (!(key in keys)) {\n      throw new Error(`Invalid option ${where}: \"${key}\"`);\n    }\n  }\n}\nfunction validateInitializeOptions(options) {\n  let keys = Object.create(null);\n  let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n  let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n  checkForInvalidFlags(options, keys, \"in startService() call\");\n  return {\n    wasmURL,\n    worker\n  };\n}\nfunction pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n  let color = getFlag(options, keys, \"color\", mustBeBoolean);\n  let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n  let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n  if (color !== void 0)\n    flags.push(`--color=${color}`);\n  else if (isTTY)\n    flags.push(`--color=true`);\n  flags.push(`--log-level=${logLevel || logLevelDefault}`);\n  flags.push(`--log-limit=${logLimit || 0}`);\n}\nfunction pushCommonFlags(flags, options, keys) {\n  let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n  let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n  let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n  let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n  let format = getFlag(options, keys, \"format\", mustBeString);\n  let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n  let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n  let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n  let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n  let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n  let charset = getFlag(options, keys, \"charset\", mustBeString);\n  let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n  let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n  let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n  let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n  let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n  let define = getFlag(options, keys, \"define\", mustBeObject);\n  let pure = getFlag(options, keys, \"pure\", mustBeArray);\n  let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n  if (legalComments)\n    flags.push(`--legal-comments=${legalComments}`);\n  if (sourceRoot !== void 0)\n    flags.push(`--source-root=${sourceRoot}`);\n  if (sourcesContent !== void 0)\n    flags.push(`--sources-content=${sourcesContent}`);\n  if (target) {\n    if (Array.isArray(target))\n      flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);\n    else\n      flags.push(`--target=${validateTarget(target)}`);\n  }\n  if (format)\n    flags.push(`--format=${format}`);\n  if (globalName)\n    flags.push(`--global-name=${globalName}`);\n  if (minify)\n    flags.push(\"--minify\");\n  if (minifySyntax)\n    flags.push(\"--minify-syntax\");\n  if (minifyWhitespace)\n    flags.push(\"--minify-whitespace\");\n  if (minifyIdentifiers)\n    flags.push(\"--minify-identifiers\");\n  if (charset)\n    flags.push(`--charset=${charset}`);\n  if (treeShaking !== void 0)\n    flags.push(`--tree-shaking=${treeShaking}`);\n  if (ignoreAnnotations)\n    flags.push(`--ignore-annotations`);\n  if (jsx)\n    flags.push(`--jsx=${jsx}`);\n  if (jsxFactory)\n    flags.push(`--jsx-factory=${jsxFactory}`);\n  if (jsxFragment)\n    flags.push(`--jsx-fragment=${jsxFragment}`);\n  if (define) {\n    for (let key in define) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid define: ${key}`);\n      flags.push(`--define:${key}=${define[key]}`);\n    }\n  }\n  if (pure)\n    for (let fn of pure)\n      flags.push(`--pure:${fn}`);\n  if (keepNames)\n    flags.push(`--keep-names`);\n}\nfunction flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n  var _a;\n  let flags = [];\n  let entries = [];\n  let keys = Object.create(null);\n  let stdinContents = null;\n  let stdinResolveDir = null;\n  let watchMode = null;\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n  let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n  let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n  let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n  let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n  let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n  let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n  let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n  let platform = getFlag(options, keys, \"platform\", mustBeString);\n  let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n  let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n  let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n  let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n  let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n  let external = getFlag(options, keys, \"external\", mustBeArray);\n  let loader = getFlag(options, keys, \"loader\", mustBeObject);\n  let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n  let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n  let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n  let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n  let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n  let inject = getFlag(options, keys, \"inject\", mustBeArray);\n  let banner = getFlag(options, keys, \"banner\", mustBeObject);\n  let footer = getFlag(options, keys, \"footer\", mustBeObject);\n  let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n  let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n  let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n  let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n  let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n  let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n  keys.plugins = true;\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n  if (bundle)\n    flags.push(\"--bundle\");\n  if (allowOverwrite)\n    flags.push(\"--allow-overwrite\");\n  if (watch) {\n    flags.push(\"--watch\");\n    if (typeof watch === \"boolean\") {\n      watchMode = {};\n    } else {\n      let watchKeys = Object.create(null);\n      let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n      checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n      watchMode = { onRebuild };\n    }\n  }\n  if (splitting)\n    flags.push(\"--splitting\");\n  if (preserveSymlinks)\n    flags.push(\"--preserve-symlinks\");\n  if (metafile)\n    flags.push(`--metafile`);\n  if (outfile)\n    flags.push(`--outfile=${outfile}`);\n  if (outdir)\n    flags.push(`--outdir=${outdir}`);\n  if (outbase)\n    flags.push(`--outbase=${outbase}`);\n  if (platform)\n    flags.push(`--platform=${platform}`);\n  if (tsconfig)\n    flags.push(`--tsconfig=${tsconfig}`);\n  if (resolveExtensions) {\n    let values = [];\n    for (let value of resolveExtensions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid resolve extension: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--resolve-extensions=${values.join(\",\")}`);\n  }\n  if (publicPath)\n    flags.push(`--public-path=${publicPath}`);\n  if (entryNames)\n    flags.push(`--entry-names=${entryNames}`);\n  if (chunkNames)\n    flags.push(`--chunk-names=${chunkNames}`);\n  if (assetNames)\n    flags.push(`--asset-names=${assetNames}`);\n  if (mainFields) {\n    let values = [];\n    for (let value of mainFields) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid main field: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--main-fields=${values.join(\",\")}`);\n  }\n  if (conditions) {\n    let values = [];\n    for (let value of conditions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid condition: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--conditions=${values.join(\",\")}`);\n  }\n  if (external)\n    for (let name of external)\n      flags.push(`--external:${name}`);\n  if (banner) {\n    for (let type in banner) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid banner file type: ${type}`);\n      flags.push(`--banner:${type}=${banner[type]}`);\n    }\n  }\n  if (footer) {\n    for (let type in footer) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid footer file type: ${type}`);\n      flags.push(`--footer:${type}=${footer[type]}`);\n    }\n  }\n  if (inject)\n    for (let path of inject)\n      flags.push(`--inject:${path}`);\n  if (loader) {\n    for (let ext in loader) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid loader extension: ${ext}`);\n      flags.push(`--loader:${ext}=${loader[ext]}`);\n    }\n  }\n  if (outExtension) {\n    for (let ext in outExtension) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid out extension: ${ext}`);\n      flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n    }\n  }\n  if (entryPoints) {\n    if (Array.isArray(entryPoints)) {\n      for (let entryPoint of entryPoints) {\n        entries.push([\"\", entryPoint + \"\"]);\n      }\n    } else {\n      for (let [key, value] of Object.entries(entryPoints)) {\n        entries.push([key + \"\", value + \"\"]);\n      }\n    }\n  }\n  if (stdin) {\n    let stdinKeys = Object.create(null);\n    let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeString);\n    let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n    let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n    let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n    checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n    if (sourcefile)\n      flags.push(`--sourcefile=${sourcefile}`);\n    if (loader2)\n      flags.push(`--loader=${loader2}`);\n    if (resolveDir)\n      stdinResolveDir = resolveDir + \"\";\n    stdinContents = contents ? contents + \"\" : \"\";\n  }\n  let nodePaths = [];\n  if (nodePathsInput) {\n    for (let value of nodePathsInput) {\n      value += \"\";\n      nodePaths.push(value);\n    }\n  }\n  return {\n    entries,\n    flags,\n    write,\n    stdinContents,\n    stdinResolveDir,\n    absWorkingDir,\n    incremental,\n    nodePaths,\n    watch: watchMode\n  };\n}\nfunction flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n  let flags = [];\n  let keys = Object.create(null);\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n  let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n  let loader = getFlag(options, keys, \"loader\", mustBeString);\n  let banner = getFlag(options, keys, \"banner\", mustBeString);\n  let footer = getFlag(options, keys, \"footer\", mustBeString);\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n  if (tsconfigRaw)\n    flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n  if (sourcefile)\n    flags.push(`--sourcefile=${sourcefile}`);\n  if (loader)\n    flags.push(`--loader=${loader}`);\n  if (banner)\n    flags.push(`--banner=${banner}`);\n  if (footer)\n    flags.push(`--footer=${footer}`);\n  return flags;\n}\nfunction createChannel(streamIn) {\n  let responseCallbacks = new Map();\n  let pluginCallbacks = new Map();\n  let watchCallbacks = new Map();\n  let serveCallbacks = new Map();\n  let nextServeID = 0;\n  let isClosed = false;\n  let nextRequestID = 0;\n  let nextBuildKey = 0;\n  let stdout = new Uint8Array(16 * 1024);\n  let stdoutUsed = 0;\n  let readFromStdout = (chunk) => {\n    let limit = stdoutUsed + chunk.length;\n    if (limit > stdout.length) {\n      let swap = new Uint8Array(limit * 2);\n      swap.set(stdout);\n      stdout = swap;\n    }\n    stdout.set(chunk, stdoutUsed);\n    stdoutUsed += chunk.length;\n    let offset = 0;\n    while (offset + 4 <= stdoutUsed) {\n      let length = readUInt32LE(stdout, offset);\n      if (offset + 4 + length > stdoutUsed) {\n        break;\n      }\n      offset += 4;\n      handleIncomingPacket(stdout.subarray(offset, offset + length));\n      offset += length;\n    }\n    if (offset > 0) {\n      stdout.copyWithin(0, offset, stdoutUsed);\n      stdoutUsed -= offset;\n    }\n  };\n  let afterClose = () => {\n    isClosed = true;\n    for (let callback of responseCallbacks.values()) {\n      callback(\"The service was stopped\", null);\n    }\n    responseCallbacks.clear();\n    for (let callbacks of serveCallbacks.values()) {\n      callbacks.onWait(\"The service was stopped\");\n    }\n    serveCallbacks.clear();\n    for (let callback of watchCallbacks.values()) {\n      try {\n        callback(new Error(\"The service was stopped\"), null);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    watchCallbacks.clear();\n  };\n  let sendRequest = (refs, value, callback) => {\n    if (isClosed)\n      return callback(\"The service is no longer running\", null);\n    let id = nextRequestID++;\n    responseCallbacks.set(id, (error, response) => {\n      try {\n        callback(error, response);\n      } finally {\n        if (refs)\n          refs.unref();\n      }\n    });\n    if (refs)\n      refs.ref();\n    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));\n  };\n  let sendResponse = (id, value) => {\n    if (isClosed)\n      throw new Error(\"The service is no longer running\");\n    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));\n  };\n  let handleRequest = (id, request) => __async(this, null, function* () {\n    try {\n      switch (request.command) {\n        case \"ping\": {\n          sendResponse(id, {});\n          break;\n        }\n        case \"start\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"resolve\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"load\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"serve-request\": {\n          let callbacks = serveCallbacks.get(request.serveID);\n          if (callbacks && callbacks.onRequest)\n            callbacks.onRequest(request.args);\n          sendResponse(id, {});\n          break;\n        }\n        case \"serve-wait\": {\n          let callbacks = serveCallbacks.get(request.serveID);\n          if (callbacks)\n            callbacks.onWait(request.error);\n          sendResponse(id, {});\n          break;\n        }\n        case \"watch-rebuild\": {\n          let callback = watchCallbacks.get(request.watchID);\n          try {\n            if (callback)\n              callback(null, request.args);\n          } catch (err) {\n            console.error(err);\n          }\n          sendResponse(id, {});\n          break;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    } catch (e) {\n      sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")] });\n    }\n  });\n  let isFirstPacket = true;\n  let handleIncomingPacket = (bytes) => {\n    if (isFirstPacket) {\n      isFirstPacket = false;\n      let binaryVersion = String.fromCharCode(...bytes);\n      if (binaryVersion !== \"0.13.13\") {\n        throw new Error(`Cannot start service: Host version \"${\"0.13.13\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n      }\n      return;\n    }\n    let packet = decodePacket(bytes);\n    if (packet.isRequest) {\n      handleRequest(packet.id, packet.value);\n    } else {\n      let callback = responseCallbacks.get(packet.id);\n      responseCallbacks.delete(packet.id);\n      if (packet.value.error)\n        callback(packet.value.error, {});\n      else\n        callback(null, packet.value);\n    }\n  };\n  let handlePlugins = (initialOptions, plugins, buildKey, stash) => __async(this, null, function* () {\n    let onStartCallbacks = [];\n    let onEndCallbacks = [];\n    let onResolveCallbacks = {};\n    let onLoadCallbacks = {};\n    let nextCallbackID = 0;\n    let i = 0;\n    let requestPlugins = [];\n    plugins = [...plugins];\n    for (let item of plugins) {\n      let keys = {};\n      if (typeof item !== \"object\")\n        throw new Error(`Plugin at index ${i} must be an object`);\n      let name = getFlag(item, keys, \"name\", mustBeString);\n      if (typeof name !== \"string\" || name === \"\")\n        throw new Error(`Plugin at index ${i} is missing a name`);\n      try {\n        let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n        if (typeof setup !== \"function\")\n          throw new Error(`Plugin is missing a setup function`);\n        checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n        let plugin = {\n          name,\n          onResolve: [],\n          onLoad: []\n        };\n        i++;\n        let promise = setup({\n          initialOptions,\n          onStart(callback2) {\n            let registeredText = `This error came from the \"onStart\" callback registered here`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n            onStartCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onEnd(callback2) {\n            let registeredText = `This error came from the \"onEnd\" callback registered here`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n            onEndCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onResolve(options, callback2) {\n            let registeredText = `This error came from the \"onResolve\" callback registered here`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onResolve() call is missing a filter`);\n            let id = nextCallbackID++;\n            onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          onLoad(options, callback2) {\n            let registeredText = `This error came from the \"onLoad\" callback registered here`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onLoad() call is missing a filter`);\n            let id = nextCallbackID++;\n            onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          }\n        });\n        if (promise)\n          yield promise;\n        requestPlugins.push(plugin);\n      } catch (e) {\n        return { ok: false, error: e, pluginName: name };\n      }\n    }\n    const callback = (request) => __async(this, null, function* () {\n      switch (request.command) {\n        case \"start\": {\n          let response = { errors: [], warnings: [] };\n          yield Promise.all(onStartCallbacks.map((_0) => __async(this, [_0], function* ({ name, callback: callback2, note }) {\n            try {\n              let result = yield callback2();\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                if (errors != null)\n                  response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                if (warnings != null)\n                  response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n              }\n            } catch (e) {\n              response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n            }\n          })));\n          return response;\n        }\n        case \"resolve\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onResolveCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                importer: request.importer,\n                namespace: request.namespace,\n                resolveDir: request.resolveDir,\n                kind: request.kind,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let path = getFlag(result, keys, \"path\", mustBeString);\n                let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (path != null)\n                  response.path = path;\n                if (namespace != null)\n                  response.namespace = namespace;\n                if (external != null)\n                  response.external = external;\n                if (sideEffects != null)\n                  response.sideEffects = sideEffects;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        case \"load\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onLoadCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                namespace: request.namespace,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let loader = getFlag(result, keys, \"loader\", mustBeString);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (contents instanceof Uint8Array)\n                  response.contents = contents;\n                else if (contents != null)\n                  response.contents = encodeUTF8(contents);\n                if (resolveDir != null)\n                  response.resolveDir = resolveDir;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (loader != null)\n                  response.loader = loader;\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    });\n    let runOnEndCallbacks = (result, logPluginError, done) => done();\n    if (onEndCallbacks.length > 0) {\n      runOnEndCallbacks = (result, logPluginError, done) => {\n        (() => __async(this, null, function* () {\n          for (const { name, callback: callback2, note } of onEndCallbacks) {\n            try {\n              yield callback2(result);\n            } catch (e) {\n              result.errors.push(yield new Promise((resolve) => logPluginError(e, name, note && note(), resolve)));\n            }\n          }\n        }))().then(done);\n      };\n    }\n    let refCount = 0;\n    return {\n      ok: true,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs: {\n        ref() {\n          if (++refCount === 1)\n            pluginCallbacks.set(buildKey, callback);\n        },\n        unref() {\n          if (--refCount === 0)\n            pluginCallbacks.delete(buildKey);\n        }\n      }\n    };\n  });\n  let buildServeData = (refs, options, request) => {\n    let keys = {};\n    let port = getFlag(options, keys, \"port\", mustBeInteger);\n    let host = getFlag(options, keys, \"host\", mustBeString);\n    let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n    let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n    let serveID = nextServeID++;\n    let onWait;\n    let wait = new Promise((resolve, reject) => {\n      onWait = (error) => {\n        serveCallbacks.delete(serveID);\n        if (error !== null)\n          reject(new Error(error));\n        else\n          resolve();\n      };\n    });\n    request.serve = { serveID };\n    checkForInvalidFlags(options, keys, `in serve() call`);\n    if (port !== void 0)\n      request.serve.port = port;\n    if (host !== void 0)\n      request.serve.host = host;\n    if (servedir !== void 0)\n      request.serve.servedir = servedir;\n    serveCallbacks.set(serveID, {\n      onRequest,\n      onWait\n    });\n    return {\n      wait,\n      stop() {\n        sendRequest(refs, { command: \"serve-stop\", serveID }, () => {\n        });\n      }\n    };\n  };\n  const buildLogLevelDefault = \"warning\";\n  const transformLogLevelDefault = \"silent\";\n  let buildOrServe = (args) => {\n    let key = nextBuildKey++;\n    const details = createObjectStash();\n    let plugins;\n    let { refs, options, isTTY, callback } = args;\n    if (typeof options === \"object\") {\n      let value = options.plugins;\n      if (value !== void 0) {\n        if (!Array.isArray(value))\n          throw new Error(`\"plugins\" must be an array`);\n        plugins = value;\n      }\n    }\n    let logPluginError = (e, pluginName, note, done) => {\n      let flags = [];\n      try {\n        pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n      } catch (e2) {\n      }\n      const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n      sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n        message.detail = details.load(message.detail);\n        done(message);\n      });\n    };\n    let handleError = (e, pluginName) => {\n      logPluginError(e, pluginName, void 0, (error) => {\n        callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n      });\n    };\n    if (plugins && plugins.length > 0) {\n      if (streamIn.isSync)\n        return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n      handlePlugins(options, plugins, key, details).then((result) => {\n        if (!result.ok) {\n          handleError(result.error, result.pluginName);\n        } else {\n          try {\n            buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n              key,\n              details,\n              logPluginError,\n              requestPlugins: result.requestPlugins,\n              runOnEndCallbacks: result.runOnEndCallbacks,\n              pluginRefs: result.pluginRefs\n            }));\n          } catch (e) {\n            handleError(e, \"\");\n          }\n        }\n      }, (e) => handleError(e, \"\"));\n    } else {\n      try {\n        buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n          key,\n          details,\n          logPluginError,\n          requestPlugins: null,\n          runOnEndCallbacks: (result, logPluginError2, done) => done(),\n          pluginRefs: null\n        }));\n      } catch (e) {\n        handleError(e, \"\");\n      }\n    }\n  };\n  let buildOrServeContinue = ({\n    callName,\n    refs: callerRefs,\n    serveOptions,\n    options,\n    isTTY,\n    defaultWD,\n    callback,\n    key,\n    details,\n    logPluginError,\n    requestPlugins,\n    runOnEndCallbacks,\n    pluginRefs\n  }) => {\n    const refs = {\n      ref() {\n        if (pluginRefs)\n          pluginRefs.ref();\n        if (callerRefs)\n          callerRefs.ref();\n      },\n      unref() {\n        if (pluginRefs)\n          pluginRefs.unref();\n        if (callerRefs)\n          callerRefs.unref();\n      }\n    };\n    let writeDefault = !streamIn.isBrowser;\n    let {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch\n    } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n    let request = {\n      command: \"build\",\n      key,\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir: absWorkingDir || defaultWD,\n      incremental,\n      nodePaths\n    };\n    if (requestPlugins)\n      request.plugins = requestPlugins;\n    let serve2 = serveOptions && buildServeData(refs, serveOptions, request);\n    let rebuild;\n    let stop;\n    let copyResponseToResult = (response, result) => {\n      if (response.outputFiles)\n        result.outputFiles = response.outputFiles.map(convertOutputFiles);\n      if (response.metafile)\n        result.metafile = JSON.parse(response.metafile);\n      if (response.writeToStdout !== void 0)\n        console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n    };\n    let buildResponseToResult = (response, callback2) => {\n      let result = {\n        errors: replaceDetailsInMessages(response.errors, details),\n        warnings: replaceDetailsInMessages(response.warnings, details)\n      };\n      copyResponseToResult(response, result);\n      runOnEndCallbacks(result, logPluginError, () => {\n        if (result.errors.length > 0) {\n          return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n        }\n        if (response.rebuildID !== void 0) {\n          if (!rebuild) {\n            let isDisposed = false;\n            rebuild = () => new Promise((resolve, reject) => {\n              if (isDisposed || isClosed)\n                throw new Error(\"Cannot rebuild\");\n              sendRequest(refs, { command: \"rebuild\", rebuildID: response.rebuildID }, (error2, response2) => {\n                if (error2) {\n                  const message = { pluginName: \"\", text: error2, location: null, notes: [], detail: void 0 };\n                  return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                }\n                buildResponseToResult(response2, (error3, result3) => {\n                  if (error3)\n                    reject(error3);\n                  else\n                    resolve(result3);\n                });\n              });\n            });\n            refs.ref();\n            rebuild.dispose = () => {\n              if (isDisposed)\n                return;\n              isDisposed = true;\n              sendRequest(refs, { command: \"rebuild-dispose\", rebuildID: response.rebuildID }, () => {\n              });\n              refs.unref();\n            };\n          }\n          result.rebuild = rebuild;\n        }\n        if (response.watchID !== void 0) {\n          if (!stop) {\n            let isStopped = false;\n            refs.ref();\n            stop = () => {\n              if (isStopped)\n                return;\n              isStopped = true;\n              watchCallbacks.delete(response.watchID);\n              sendRequest(refs, { command: \"watch-stop\", watchID: response.watchID }, () => {\n              });\n              refs.unref();\n            };\n            if (watch) {\n              watchCallbacks.set(response.watchID, (serviceStopError, watchResponse) => {\n                if (serviceStopError) {\n                  if (watch.onRebuild)\n                    watch.onRebuild(serviceStopError, null);\n                  return;\n                }\n                let result2 = {\n                  errors: replaceDetailsInMessages(watchResponse.errors, details),\n                  warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                };\n                copyResponseToResult(watchResponse, result2);\n                runOnEndCallbacks(result2, logPluginError, () => {\n                  if (result2.errors.length > 0) {\n                    if (watch.onRebuild)\n                      watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                    return;\n                  }\n                  if (watchResponse.rebuildID !== void 0)\n                    result2.rebuild = rebuild;\n                  result2.stop = stop;\n                  if (watch.onRebuild)\n                    watch.onRebuild(null, result2);\n                });\n              });\n            }\n          }\n          result.stop = stop;\n        }\n        callback2(null, result);\n      });\n    };\n    if (write && streamIn.isBrowser)\n      throw new Error(`Cannot enable \"write\" in the browser`);\n    if (incremental && streamIn.isSync)\n      throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n    if (watch && streamIn.isSync)\n      throw new Error(`Cannot use \"watch\" with a synchronous build`);\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      if (serve2) {\n        let serveResponse = response;\n        let isStopped = false;\n        refs.ref();\n        let result = {\n          port: serveResponse.port,\n          host: serveResponse.host,\n          wait: serve2.wait,\n          stop() {\n            if (isStopped)\n              return;\n            isStopped = true;\n            serve2.stop();\n            refs.unref();\n          }\n        };\n        refs.ref();\n        serve2.wait.then(refs.unref, refs.unref);\n        return callback(null, result);\n      }\n      return buildResponseToResult(response, callback);\n    });\n  };\n  let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n    const details = createObjectStash();\n    let start = (inputPath) => {\n      try {\n        if (typeof input !== \"string\")\n          throw new Error('The input to \"transform\" must be a string');\n        let flags = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n        let request = {\n          command: \"transform\",\n          flags,\n          inputFS: inputPath !== null,\n          input: inputPath !== null ? inputPath : input\n        };\n        sendRequest(refs, request, (error, response) => {\n          if (error)\n            return callback(new Error(error), null);\n          let errors = replaceDetailsInMessages(response.errors, details);\n          let warnings = replaceDetailsInMessages(response.warnings, details);\n          let outstanding = 1;\n          let next = () => --outstanding === 0 && callback(null, { warnings, code: response.code, map: response.map });\n          if (errors.length > 0)\n            return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n          if (response.codeFS) {\n            outstanding++;\n            fs.readFile(response.code, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.code = contents;\n                next();\n              }\n            });\n          }\n          if (response.mapFS) {\n            outstanding++;\n            fs.readFile(response.map, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.map = contents;\n                next();\n              }\n            });\n          }\n          next();\n        });\n      } catch (e) {\n        let flags = [];\n        try {\n          pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n        } catch (e2) {\n        }\n        const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n        sendRequest(refs, { command: \"error\", flags, error }, () => {\n          error.detail = details.load(error.detail);\n          callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n        });\n      }\n    };\n    if (typeof input === \"string\" && input.length > 1024 * 1024) {\n      let next = start;\n      start = () => fs.writeFile(input, next);\n    }\n    start(null);\n  };\n  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n    let result = sanitizeMessages(messages, \"messages\", null, \"\");\n    if (!options)\n      throw new Error(`Missing second argument in ${callName}() call`);\n    let keys = {};\n    let kind = getFlag(options, keys, \"kind\", mustBeString);\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (kind === void 0)\n      throw new Error(`Missing \"kind\" in ${callName}() call`);\n    if (kind !== \"error\" && kind !== \"warning\")\n      throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n    let request = {\n      command: \"format-msgs\",\n      messages: result,\n      isWarning: kind === \"warning\"\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (terminalWidth !== void 0)\n      request.terminalWidth = terminalWidth;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.messages);\n    });\n  };\n  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n    if (options === void 0)\n      options = {};\n    let keys = {};\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    let request = {\n      command: \"analyze-metafile\",\n      metafile\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (verbose !== void 0)\n      request.verbose = verbose;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.result);\n    });\n  };\n  return {\n    readFromStdout,\n    afterClose,\n    service: {\n      buildOrServe,\n      transform: transform2,\n      formatMessages: formatMessages2,\n      analyzeMetafile: analyzeMetafile2\n    }\n  };\n}\nfunction createObjectStash() {\n  const map = new Map();\n  let nextID = 0;\n  return {\n    load(id) {\n      return map.get(id);\n    },\n    store(value) {\n      if (value === void 0)\n        return -1;\n      const id = nextID++;\n      map.set(id, value);\n      return id;\n    }\n  };\n}\nfunction extractCallerV8(e, streamIn, ident) {\n  let note;\n  let tried = false;\n  return () => {\n    if (tried)\n      return note;\n    tried = true;\n    try {\n      let lines = (e.stack + \"\").split(\"\\n\");\n      lines.splice(1, 1);\n      let location = parseStackLinesV8(streamIn, lines, ident);\n      if (location) {\n        note = { text: e.message, location };\n        return note;\n      }\n    } catch (e2) {\n    }\n  };\n}\nfunction extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n  let text = \"Internal error\";\n  let location = null;\n  try {\n    text = (e && e.message || e) + \"\";\n  } catch (e2) {\n  }\n  try {\n    location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n  } catch (e2) {\n  }\n  return { pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n}\nfunction parseStackLinesV8(streamIn, lines, ident) {\n  let at = \"    at \";\n  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i];\n      if (!line.startsWith(at))\n        continue;\n      line = line.slice(at.length);\n      while (true) {\n        let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n        if (match) {\n          let contents;\n          try {\n            contents = streamIn.readFileSync(match[1], \"utf8\");\n          } catch (e) {\n            break;\n          }\n          let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n          let column = +match[3] - 1;\n          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n          return {\n            file: match[1],\n            namespace: \"file\",\n            line: +match[2],\n            column: encodeUTF8(lineText.slice(0, column)).length,\n            length: encodeUTF8(lineText.slice(column, column + length)).length,\n            lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n            suggestion: \"\"\n          };\n        }\n        break;\n      }\n    }\n  }\n  return null;\n}\nfunction failureErrorWithLog(text, errors, warnings) {\n  let limit = 5;\n  let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n    if (i === limit)\n      return \"\\n...\";\n    if (!e.location)\n      return `\nerror: ${e.text}`;\n    let { file, line, column } = e.location;\n    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n    return `\n${file}:${line}:${column}: error: ${pluginText}${e.text}`;\n  }).join(\"\");\n  let error = new Error(`${text}${summary}`);\n  error.errors = errors;\n  error.warnings = warnings;\n  return error;\n}\nfunction replaceDetailsInMessages(messages, stash) {\n  for (const message of messages) {\n    message.detail = stash.load(message.detail);\n  }\n  return messages;\n}\nfunction sanitizeLocation(location, where) {\n  if (location == null)\n    return null;\n  let keys = {};\n  let file = getFlag(location, keys, \"file\", mustBeString);\n  let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n  let line = getFlag(location, keys, \"line\", mustBeInteger);\n  let column = getFlag(location, keys, \"column\", mustBeInteger);\n  let length = getFlag(location, keys, \"length\", mustBeInteger);\n  let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n  let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n  checkForInvalidFlags(location, keys, where);\n  return {\n    file: file || \"\",\n    namespace: namespace || \"\",\n    line: line || 0,\n    column: column || 0,\n    length: length || 0,\n    lineText: lineText || \"\",\n    suggestion: suggestion || \"\"\n  };\n}\nfunction sanitizeMessages(messages, property, stash, fallbackPluginName) {\n  let messagesClone = [];\n  let index = 0;\n  for (const message of messages) {\n    let keys = {};\n    let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n    let text = getFlag(message, keys, \"text\", mustBeString);\n    let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n    let notes = getFlag(message, keys, \"notes\", mustBeArray);\n    let detail = getFlag(message, keys, \"detail\", canBeAnything);\n    let where = `in element ${index} of \"${property}\"`;\n    checkForInvalidFlags(message, keys, where);\n    let notesClone = [];\n    if (notes) {\n      for (const note of notes) {\n        let noteKeys = {};\n        let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n        let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n        checkForInvalidFlags(note, noteKeys, where);\n        notesClone.push({\n          text: noteText || \"\",\n          location: sanitizeLocation(noteLocation, where)\n        });\n      }\n    }\n    messagesClone.push({\n      pluginName: pluginName || fallbackPluginName,\n      text: text || \"\",\n      location: sanitizeLocation(location, where),\n      notes: notesClone,\n      detail: stash ? stash.store(detail) : -1\n    });\n    index++;\n  }\n  return messagesClone;\n}\nfunction sanitizeStringArray(values, property) {\n  const result = [];\n  for (const value of values) {\n    if (typeof value !== \"string\")\n      throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n    result.push(value);\n  }\n  return result;\n}\nfunction convertOutputFiles({ path, contents }) {\n  let text = null;\n  return {\n    path,\n    contents,\n    get text() {\n      if (text === null)\n        text = decodeUTF8(contents);\n      return text;\n    }\n  };\n}\n\n// lib/npm/browser.ts\nvar version = \"0.13.13\";\nvar build = (options) => ensureServiceIsRunning().build(options);\nvar serve = () => {\n  throw new Error(`The \"serve\" API only works in node`);\n};\nvar transform = (input, options) => ensureServiceIsRunning().transform(input, options);\nvar formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\nvar analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\nvar buildSync = () => {\n  throw new Error(`The \"buildSync\" API only works in node`);\n};\nvar transformSync = () => {\n  throw new Error(`The \"transformSync\" API only works in node`);\n};\nvar formatMessagesSync = () => {\n  throw new Error(`The \"formatMessagesSync\" API only works in node`);\n};\nvar analyzeMetafileSync = () => {\n  throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n};\nvar initializePromise;\nvar longLivedService;\nvar ensureServiceIsRunning = () => {\n  if (longLivedService)\n    return longLivedService;\n  if (initializePromise)\n    throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n  throw new Error('You need to call \"initialize\" before calling this');\n};\nvar initialize = (options) => {\n  options = validateInitializeOptions(options || {});\n  let wasmURL = options.wasmURL;\n  let useWorker = options.worker !== false;\n  if (!wasmURL)\n    throw new Error('Must provide the \"wasmURL\" option');\n  wasmURL += \"\";\n  if (initializePromise)\n    throw new Error('Cannot call \"initialize\" more than once');\n  initializePromise = startRunningService(wasmURL, useWorker);\n  initializePromise.catch(() => {\n    initializePromise = void 0;\n  });\n  return initializePromise;\n};\nvar startRunningService = (wasmURL, useWorker) => __async(void 0, null, function* () {\n  let res = yield fetch(wasmURL);\n  if (!res.ok)\n    throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n  let wasm = yield res.arrayBuffer();\n  let code = `{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\t// - Webpack\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tconst fs = require(\"fs\");\n\t\tif (typeof fs === \"object\" && fs !== null && Object.keys(fs).length !== 0) {\n\t\t\t\n    global.fs = Object.assign({}, fs, {\n      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550\n      write(fd, buf, offset, length, position, callback) {\n        if (offset === 0 && length === buf.length && position === null) {\n          if (fd === process.stdout.fd) {\n            try {\n              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n          if (fd === process.stderr.fd) {\n            try {\n              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n        }\n        fs.write(fd, buf, offset, length, position, callback);\n      },\n    });\n  \n\t\t}\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto && global.require) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\tif (!global.crypto) {\n\t\tthrow new Error(\"global.crypto is not available, polyfill required (getRandomValues only)\");\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder && global.require) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\tif (!global.TextEncoder) {\n\t\tthrow new Error(\"global.TextEncoder is not available, polyfill required\");\n\t}\n\n\tif (!global.TextDecoder && global.require) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\tif (!global.TextDecoder) {\n\t\tthrow new Error(\"global.TextDecoder is not available, polyfill required\");\n\t}\n\n\t// End of polyfills for common API.\n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis.argv = [\"js\"];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = (code) => {\n\t\t\t\tif (code !== 0) {\n\t\t\t\t\tconsole.warn(\"exit code:\", code);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise((resolve) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t});\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tthis.mem.setUint32(addr + 0, v, true);\n\t\t\t\tthis.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = this.mem.getUint32(addr + 0, true);\n\t\t\t\tconst high = this.mem.getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = this.mem.getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = this.mem.getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\" && v !== 0) {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tthis.mem.setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tthis.mem.setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.mem.setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tthis.mem.setFloat64(addr, 0, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tthis.mem.setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn new Uint8Array(this._inst.exports.mem.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (addr) => {\n\t\t\t\tconst saddr = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst code = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._goRefCounts;\n\t\t\t\t\t\tdelete this._ids;\n\t\t\t\t\t\tdelete this._idPool;\n\t\t\t\t\t\tthis.exit(code);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst fd = getInt64(sp + 8);\n\t\t\t\t\t\tconst p = getInt64(sp + 16);\n\t\t\t\t\t\tconst n = this.mem.getInt32(sp + 24, true);\n\t\t\t\t\t\tfs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func resetMemoryDataView()\n\t\t\t\t\t\"runtime.resetMemoryDataView\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime1() int64\n\t\t\t\t\t\"runtime.nanotime1\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst msec = (new Date).getTime();\n\t\t\t\t\t\tsetInt64(sp + 8, msec / 1000);\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set(id, setTimeout(\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\twhile (this._scheduledTimeouts.has(id)) {\n\t\t\t\t\t\t\t\t\t// for some reason Go failed to register the timeout event, log and try again\n\t\t\t\t\t\t\t\t\t// (temporary workaround for https://github.com/golang/go/issues/28975)\n\t\t\t\t\t\t\t\t\tconsole.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\t\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, id, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tclearTimeout(this._scheduledTimeouts.get(id));\n\t\t\t\t\t\tthis._scheduledTimeouts.delete(id);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getUint32(sp + 8, true);\n\t\t\t\t\t\tthis._goRefCounts[id]--;\n\t\t\t\t\t\tif (this._goRefCounts[id] === 0) {\n\t\t\t\t\t\t\tconst v = this._values[id];\n\t\t\t\t\t\t\tthis._values[id] = null;\n\t\t\t\t\t\t\tthis._ids.delete(v);\n\t\t\t\t\t\t\tthis._idPool.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, loadString(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\tstoreValue(sp + 32, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst m = Reflect.get(v, loadString(sp + 16));\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 32);\n\t\t\t\t\t\t\tconst result = Reflect.apply(m, v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.apply(v, undefined, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.construct(v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = encoder.encode(String(loadValue(sp + 8)));\n\t\t\t\t\t\tstoreValue(sp + 16, str);\n\t\t\t\t\t\tsetInt64(sp + 24, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = loadValue(sp + 8);\n\t\t\t\t\t\tloadSlice(sp + 16).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadSlice(sp + 8);\n\t\t\t\t\t\tconst src = loadValue(sp + 32);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadValue(sp + 8);\n\t\t\t\t\t\tconst src = loadSlice(sp + 16);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": (value) => {\n\t\t\t\t\t\tconsole.log(value);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tif (!(instance instanceof WebAssembly.Instance)) {\n\t\t\t\tthrow new Error(\"Go.run: WebAssembly.Instance expected\");\n\t\t\t}\n\t\t\tthis._inst = instance;\n\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map([ // mapping from JS values to reference ids\n\t\t\t\t[0, 1],\n\t\t\t\t[null, 2],\n\t\t\t\t[true, 3],\n\t\t\t\t[false, 4],\n\t\t\t\t[global, 5],\n\t\t\t\t[this, 6],\n\t\t\t]);\n\t\t\tthis._idPool = [];   // unused ids that have been garbage collected\n\t\t\tthis.exited = false; // whether the Go program has exited\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = (str) => {\n\t\t\t\tconst ptr = offset;\n\t\t\t\tconst bytes = encoder.encode(str + \"\\\\0\");\n\t\t\t\tnew Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n\t\t\t\toffset += bytes.length;\n\t\t\t\tif (offset % 8 !== 0) {\n\t\t\t\t\toffset += 8 - (offset % 8);\n\t\t\t\t}\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach((arg) => {\n\t\t\t\targvPtrs.push(strPtr(arg));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst keys = Object.keys(this.env).sort();\n\t\t\tkeys.forEach((key) => {\n\t\t\t\targvPtrs.push(strPtr(\\`\\${key}=\\${this.env[key]}\\`));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach((ptr) => {\n\t\t\t\tthis.mem.setUint32(offset, ptr, true);\n\t\t\t\tthis.mem.setUint32(offset + 4, 0, true);\n\t\t\t\toffset += 8;\n\t\t\t});\n\n\t\t\t// The linker guarantees global data starts from at least wasmMinDataAddr.\n\t\t\t// Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\t\t\tconst wasmMinDataAddr = 4096 + 4096;\n\t\t\tif (offset >= wasmMinDataAddr) {\n\t\t\t\tthrow new Error(\"command line too long\");\n\t\t\t}\n\n\t\t\tthis._inst.exports.run(argc, argv);\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\ttypeof module !== \"undefined\" &&\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length < 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tgo.argv = process.argv.slice(2);\n\t\tgo.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n\t\tgo.exit = process.exit;\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\tprocess.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n\t\t\t\tif (code === 0 && !go.exited) {\n\t\t\t\t\t// deadlock, make Go print error and stack traces\n\t\t\t\t\tgo._pendingEvent = { id: 0 };\n\t\t\t\t\tgo._resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();\nonmessage = ({ data: wasm }) => {\n  let decoder = new TextDecoder();\n  let fs = global.fs;\n  let stderr = \"\";\n  fs.writeSync = (fd, buffer) => {\n    if (fd === 1) {\n      postMessage(buffer);\n    } else if (fd === 2) {\n      stderr += decoder.decode(buffer);\n      let parts = stderr.split(\"\\\\n\");\n      if (parts.length > 1)\n        console.log(parts.slice(0, -1).join(\"\\\\n\"));\n      stderr = parts[parts.length - 1];\n    } else {\n      throw new Error(\"Bad write\");\n    }\n    return buffer.length;\n  };\n  let stdin = [];\n  let resumeStdin;\n  let stdinPos = 0;\n  onmessage = ({ data }) => {\n    if (data.length > 0) {\n      stdin.push(data);\n      if (resumeStdin)\n        resumeStdin();\n    }\n  };\n  fs.read = (fd, buffer, offset, length, position, callback) => {\n    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n      throw new Error(\"Bad read\");\n    }\n    if (stdin.length === 0) {\n      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n      return;\n    }\n    let first = stdin[0];\n    let count = Math.max(0, Math.min(length, first.length - stdinPos));\n    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n    stdinPos += count;\n    if (stdinPos === first.length) {\n      stdin.shift();\n      stdinPos = 0;\n    }\n    callback(null, count);\n  };\n  let go = new global.Go();\n  go.argv = [\"\", \\`--service=\\${\"0.13.13\"}\\`];\n  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n};}`;\n  let worker;\n  if (useWorker) {\n    let blob = new Blob([code], { type: \"text/javascript\" });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    let fn = new Function(\"postMessage\", code + `var onmessage; return m => onmessage(m)`);\n    let onmessage = fn((data) => worker.onmessage({ data }));\n    worker = {\n      onmessage: null,\n      postMessage: (data) => onmessage({ data }),\n      terminate() {\n      }\n    };\n  }\n  worker.postMessage(wasm);\n  worker.onmessage = ({ data }) => readFromStdout(data);\n  let { readFromStdout, service } = createChannel({\n    writeToStdin(bytes) {\n      worker.postMessage(bytes);\n    },\n    isSync: false,\n    isBrowser: true\n  });\n  longLivedService = {\n    build: (options) => new Promise((resolve, reject) => service.buildOrServe({\n      callName: \"build\",\n      refs: null,\n      serveOptions: null,\n      options,\n      isTTY: false,\n      defaultWD: \"/\",\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    transform: (input, options) => new Promise((resolve, reject) => service.transform({\n      callName: \"transform\",\n      refs: null,\n      input,\n      options: options || {},\n      isTTY: false,\n      fs: {\n        readFile(_, callback) {\n          callback(new Error(\"Internal error\"), null);\n        },\n        writeFile(_, callback) {\n          callback(null);\n        }\n      },\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n      callName: \"formatMessages\",\n      refs: null,\n      messages,\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n      callName: \"analyzeMetafile\",\n      refs: null,\n      metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    }))\n  };\n});\n})(typeof exports===\"object\"?exports:(typeof self!==\"undefined\"?self:this).esbuild={});\n"]},"metadata":{},"sourceType":"script"}