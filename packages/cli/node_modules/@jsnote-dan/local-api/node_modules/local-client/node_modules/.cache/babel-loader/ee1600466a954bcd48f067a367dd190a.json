{"ast":null,"code":"import axios from \"axios\";\nimport { ActionType } from \"../action-types\";\nimport bundle from \"../../bundler\";\nexport const updateCell = (id, content) => {\n  return {\n    type: ActionType.UPDATE_CELL,\n    payload: {\n      id,\n      content\n    }\n  };\n};\nexport const deleteCell = id => {\n  return {\n    type: ActionType.DELETE_CELL,\n    payload: id\n  };\n};\nexport const moveCell = (id, direction) => {\n  return {\n    type: ActionType.MOVE_CELL,\n    payload: {\n      id,\n      direction\n    }\n  };\n};\nexport const insertCellAfter = (id, cellType) => {\n  return {\n    type: ActionType.INSERT_CELL_AFTER,\n    payload: {\n      id,\n      type: cellType\n    }\n  };\n};\nexport const createBundle = (id, input) => {\n  // use redux thunk for async logic\n  // type annotation for dispatch is to make sure we can only call dispatch with a properly typed action object\n  return async dispatch => {\n    dispatch({\n      type: ActionType.BUNDLE_START,\n      payload: {\n        id\n      }\n    });\n    const result = await bundle(input);\n    dispatch({\n      type: ActionType.BUNDLE_COMPLETE,\n      payload: {\n        id,\n        bundle: result\n      }\n    });\n  };\n};\nexport const fetchCells = () => {\n  return async dispatch => {\n    // only purpose of this action is to flip loading to true\n    dispatch({\n      type: ActionType.FETCH_CELLS\n    });\n\n    try {\n      // make request to fetch cells\n      const {\n        data\n      } = await axios.get(\"/cells\");\n      dispatch({\n        type: ActionType.FETCH_CELLS_COMPLETE,\n        payload: data\n      });\n    } catch (err) {\n      if (err instanceof Error) {\n        dispatch({\n          type: ActionType.FETCH_CELLS_ERROR,\n          payload: err.message\n        });\n      }\n    }\n  };\n};\nexport const saveCells = () => {\n  return async (dispatch, getState) => {\n    // get data and order from current cells state\n    const {\n      cells: {\n        data,\n        order\n      }\n    } = getState(); // derive array of cells in order from data and order array\n\n    const cells = order.map(id => data[id]); // make sure request body has an array of cells inside, as defined in createCellsRouter\n\n    try {\n      await axios.post(\"/cells\", {\n        cells\n      });\n    } catch (err) {\n      if (err instanceof Error) {\n        dispatch({\n          type: ActionType.SAVE_CELLS_ERROR,\n          payload: err.message\n        });\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/src/state/action-creators/index.ts"],"names":["axios","ActionType","bundle","updateCell","id","content","type","UPDATE_CELL","payload","deleteCell","DELETE_CELL","moveCell","direction","MOVE_CELL","insertCellAfter","cellType","INSERT_CELL_AFTER","createBundle","input","dispatch","BUNDLE_START","result","BUNDLE_COMPLETE","fetchCells","FETCH_CELLS","data","get","FETCH_CELLS_COMPLETE","err","Error","FETCH_CELLS_ERROR","message","saveCells","getState","cells","order","map","post","SAVE_CELLS_ERROR"],"mappings":"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","sourcesContent":["import { Dispatch } from \"react\";\r\nimport axios from \"axios\";\r\nimport { ActionType } from \"../action-types\";\r\nimport {\r\n\tAction,\r\n\tDirection,\r\n\tUpdateCellAction,\r\n\tDeleteCellAction,\r\n\tMoveCellAction,\r\n\tInsertCellAfterAction\r\n} from \"../actions\";\r\nimport { CellTypes, Cell } from \"../cell\";\r\nimport bundle from \"../../bundler\";\r\nimport { RootState } from \"..\";\r\n\r\nexport const updateCell = (id: string, content: string): UpdateCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.UPDATE_CELL,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\tcontent\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const deleteCell = (id: string): DeleteCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.DELETE_CELL,\r\n\t\tpayload: id\r\n\t};\r\n};\r\n\r\nexport const moveCell = (id: string, direction: Direction): MoveCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.MOVE_CELL,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\tdirection\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const insertCellAfter = (\r\n\tid: string | null,\r\n\tcellType: CellTypes\r\n): InsertCellAfterAction => {\r\n\treturn {\r\n\t\ttype: ActionType.INSERT_CELL_AFTER,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\ttype: cellType\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const createBundle = (id: string, input: string) => {\r\n\t// use redux thunk for async logic\r\n\t// type annotation for dispatch is to make sure we can only call dispatch with a properly typed action object\r\n\treturn async (dispatch: Dispatch<Action>) => {\r\n\t\tdispatch({\r\n\t\t\ttype: ActionType.BUNDLE_START,\r\n\t\t\tpayload:\r\n\t\t\t\t{\r\n\t\t\t\t\tid\r\n\t\t\t\t}\r\n\t\t});\r\n\r\n\t\tconst result = await bundle(input);\r\n\r\n\t\tdispatch({\r\n\t\t\ttype: ActionType.BUNDLE_COMPLETE,\r\n\t\t\tpayload:\r\n\t\t\t\t{\r\n\t\t\t\t\tid,\r\n\t\t\t\t\tbundle: result\r\n\t\t\t\t}\r\n\t\t});\r\n\t};\r\n};\r\n\r\nexport const fetchCells = () => {\r\n\treturn async (dispatch: Dispatch<Action>) => {\r\n\t\t// only purpose of this action is to flip loading to true\r\n\t\tdispatch({ type: ActionType.FETCH_CELLS });\r\n\r\n\t\ttry {\r\n\t\t\t// make request to fetch cells\r\n\t\t\tconst { data }: { data: Cell[] } = await axios.get(\"/cells\");\r\n\r\n\t\t\tdispatch({\r\n\t\t\t\ttype: ActionType.FETCH_CELLS_COMPLETE,\r\n\t\t\t\tpayload: data\r\n\t\t\t});\r\n\t\t} catch (err) {\r\n\t\t\tif (err instanceof Error) {\r\n\t\t\t\tdispatch({\r\n\t\t\t\t\ttype: ActionType.FETCH_CELLS_ERROR,\r\n\t\t\t\t\tpayload: err.message\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\nexport const saveCells = () => {\r\n\treturn async (dispatch: Dispatch<Action>, getState: () => RootState) => {\r\n\t\t// get data and order from current cells state\r\n\t\tconst { cells: { data, order } } = getState();\r\n\t\t// derive array of cells in order from data and order array\r\n\t\tconst cells = order.map(id => data[id]);\r\n\t\t// make sure request body has an array of cells inside, as defined in createCellsRouter\r\n\t\ttry {\r\n\t\t\tawait axios.post(\"/cells\", { cells });\r\n\t\t} catch (err) {\r\n\t\t\tif (err instanceof Error) {\r\n\t\t\t\tdispatch({\r\n\t\t\t\t\ttype: ActionType.SAVE_CELLS_ERROR,\r\n\t\t\t\t\tpayload: err.message\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}