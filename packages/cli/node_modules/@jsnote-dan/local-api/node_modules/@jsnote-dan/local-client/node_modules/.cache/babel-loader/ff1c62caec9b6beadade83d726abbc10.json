{"ast":null,"code":"/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit').Visitor<ElementChild>} Visitor\n */\nimport { direction } from 'direction';\nimport { isElement } from 'hast-util-is-element';\nimport { toString } from 'hast-util-to-string';\nimport { svg } from 'property-information';\nimport { visit, EXIT, SKIP } from 'unist-util-visit';\nimport { element } from './util.js';\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\n\nexport function enterState(state, node) {\n  var schema = state.schema;\n  var language = state.language;\n  var currentDirection = state.direction;\n  var editableOrEditingHost = state.editableOrEditingHost;\n  /** @type {Direction|undefined} */\n\n  var dirInferred;\n  /** @type {boolean|undefined} */\n\n  var found;\n\n  if (element(node) && node.properties) {\n    var lang = node.properties.xmlLang || node.properties.lang;\n    var type = node.properties.type || 'text';\n    var dir = dirProperty(node);\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang);\n      found = true;\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true;\n        found = true;\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg;\n        found = true;\n      } // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n\n\n      if (dir === 'rtl') {\n        dirInferred = dir;\n      } else if ( // Explicit `[dir=ltr]`.\n      dir === 'ltr' || // HTML with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'html') || // `input[type=tel]` with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'input') && type === 'tel') {\n        dirInferred = 'ltr'; // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node));\n        } else if (isElement(node, 'input') && (type === 'email' || type === 'search' || type === 'tel' || type === 'text')) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value ? // @ts-expect-error Assume string\n          dirBidi(node.properties.value) : 'ltr';\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality);\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred;\n        found = true;\n      }\n    } // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false;\n      found = true;\n    }\n  }\n\n  return found ? reset : noop;\n\n  function reset() {\n    state.schema = schema;\n    state.language = language;\n    state.direction = currentDirection;\n    state.editableOrEditingHost = editableOrEditingHost;\n  }\n  /** @type {Visitor} */\n\n\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value);\n      return dirInferred ? EXIT : null;\n    }\n\n    if (child !== node && (isElement(child, ['bdi', 'script', 'style', 'textare']) || dirProperty(child))) {\n      return SKIP;\n    }\n  }\n}\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\n\nfunction dirBidi(value) {\n  var result = direction(value);\n  return result === 'neutral' ? undefined : result;\n}\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\n\n\nfunction dirProperty(node) {\n  var value = element(node) && node.properties && typeof node.properties.dir === 'string' ? node.properties.dir.toLowerCase() : undefined;\n  return value === 'auto' || value === 'ltr' || value === 'rtl' ? value : undefined;\n}\n\nfunction noop() {}","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/node_modules/hast-util-select/lib/enter-state.js"],"names":["direction","isElement","toString","svg","visit","EXIT","SKIP","element","enterState","state","node","schema","language","currentDirection","editableOrEditingHost","dirInferred","found","properties","lang","xmlLang","type","dir","dirProperty","undefined","String","space","contentEditable","dirBidi","value","inferDirectionality","reset","noop","child","result","toLowerCase"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit').Visitor<ElementChild>} Visitor\n */\n\nimport {direction} from 'direction'\nimport {isElement} from 'hast-util-is-element'\nimport {toString} from 'hast-util-to-string'\nimport {svg} from 'property-information'\nimport {visit, EXIT, SKIP} from 'unist-util-visit'\nimport {element} from './util.js'\n\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  const schema = state.schema\n  const language = state.language\n  const currentDirection = state.direction\n  const editableOrEditingHost = state.editableOrEditingHost\n  /** @type {Direction|undefined} */\n  let dirInferred\n  /** @type {boolean|undefined} */\n  let found\n\n  if (element(node) && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang\n    const type = node.properties.type || 'text'\n    const dir = dirProperty(node)\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang)\n      found = true\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true\n        found = true\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg\n        found = true\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir\n      } else if (\n        // Explicit `[dir=ltr]`.\n        dir === 'ltr' ||\n        // HTML with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'html')) ||\n        // `input[type=tel]` with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'input') && type === 'tel')\n      ) {\n        dirInferred = 'ltr'\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node))\n        } else if (\n          isElement(node, 'input') &&\n          (type === 'email' ||\n            type === 'search' ||\n            type === 'tel' ||\n            type === 'text')\n        ) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value\n            ? // @ts-expect-error Assume string\n              dirBidi(node.properties.value)\n            : 'ltr'\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality)\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred\n        found = true\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false\n      found = true\n    }\n  }\n\n  return found ? reset : noop\n\n  function reset() {\n    state.schema = schema\n    state.language = language\n    state.direction = currentDirection\n    state.editableOrEditingHost = editableOrEditingHost\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value)\n      return dirInferred ? EXIT : null\n    }\n\n    if (\n      child !== node &&\n      (isElement(child, ['bdi', 'script', 'style', 'textare']) ||\n        dirProperty(child))\n    ) {\n      return SKIP\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\nfunction dirBidi(value) {\n  const result = direction(value)\n  return result === 'neutral' ? undefined : result\n}\n\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\nfunction dirProperty(node) {\n  const value =\n    element(node) && node.properties && typeof node.properties.dir === 'string'\n      ? node.properties.dir.toLowerCase()\n      : undefined\n\n  return value === 'auto' || value === 'ltr' || value === 'rtl'\n    ? value\n    : undefined\n}\n\nfunction noop() {}\n"]},"metadata":{},"sourceType":"module"}