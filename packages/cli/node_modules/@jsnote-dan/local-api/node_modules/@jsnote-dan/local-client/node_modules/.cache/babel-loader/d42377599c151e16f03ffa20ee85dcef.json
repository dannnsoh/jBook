{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/Ryzen/Desktop/jbook/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/Users/Ryzen/Desktop/jbook/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{ActionType}from\"../action-types\";import bundle from\"../../bundler\";export var updateCell=function updateCell(id,content){return{type:ActionType.UPDATE_CELL,payload:{id:id,content:content}};};export var deleteCell=function deleteCell(id){return{type:ActionType.DELETE_CELL,payload:id};};export var moveCell=function moveCell(id,direction){return{type:ActionType.MOVE_CELL,payload:{id:id,direction:direction}};};export var insertCellAfter=function insertCellAfter(id,cellType){return{type:ActionType.INSERT_CELL_AFTER,payload:{id:id,type:cellType}};};export var createBundle=function createBundle(id,input){// utilising redux thunk for bundling (async)\n// type annotation for dispatch is to make sure we only call dispatch with an actual action with a payload\nreturn/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch){var result;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:dispatch({type:ActionType.BUNDLE_START,payload:{id:id}});_context.next=3;return bundle(input);case 3:result=_context.sent;dispatch({type:ActionType.BUNDLE_COMPLETE,payload:{id:id,bundle:result}});case 5:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}();};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/src/state/action-creators/index.ts"],"names":["ActionType","bundle","updateCell","id","content","type","UPDATE_CELL","payload","deleteCell","DELETE_CELL","moveCell","direction","MOVE_CELL","insertCellAfter","cellType","INSERT_CELL_AFTER","createBundle","input","dispatch","BUNDLE_START","result","BUNDLE_COMPLETE"],"mappings":"+UACA,OAASA,UAAT,KAA2B,iBAA3B,CAUA,MAAOC,CAAAA,MAAP,KAAmB,eAAnB,CAEA,MAAO,IAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACC,EAAD,CAAaC,OAAb,CAAmD,CAC5E,MAAO,CACNC,IAAI,CAAEL,UAAU,CAACM,WADX,CAENC,OAAO,CACN,CACCJ,EAAE,CAAFA,EADD,CAECC,OAAO,CAAPA,OAFD,CAHK,CAAP,CAQA,CATM,CAWP,MAAO,IAAMI,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACL,EAAD,CAAkC,CAC3D,MAAO,CACNE,IAAI,CAAEL,UAAU,CAACS,WADX,CAENF,OAAO,CAAEJ,EAFH,CAAP,CAIA,CALM,CAOP,MAAO,IAAMO,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACP,EAAD,CAAaQ,SAAb,CAAsD,CAC7E,MAAO,CACNN,IAAI,CAAEL,UAAU,CAACY,SADX,CAENL,OAAO,CACN,CACCJ,EAAE,CAAFA,EADD,CAECQ,SAAS,CAATA,SAFD,CAHK,CAAP,CAQA,CATM,CAWP,MAAO,IAAME,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACV,EAAD,CAAoBW,QAApB,CAAmE,CACjG,MAAO,CACNT,IAAI,CAAEL,UAAU,CAACe,iBADX,CAENR,OAAO,CACN,CACCJ,EAAE,CAAFA,EADD,CAECE,IAAI,CAAES,QAFP,CAHK,CAAP,CAQA,CATM,CAWP,MAAO,IAAME,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAACb,EAAD,CAAac,KAAb,CAA+B,CAC1D;AACA;AACA,+FAAO,iBAAOC,QAAP,6HACNA,QAAQ,CAAC,CACRb,IAAI,CAAEL,UAAU,CAACmB,YADT,CAERZ,OAAO,CACN,CACCJ,EAAE,CAAFA,EADD,CAHO,CAAD,CAAR,CADM,sBASeF,CAAAA,MAAM,CAACgB,KAAD,CATrB,QASAG,MATA,eAWNF,QAAQ,CAAC,CACRb,IAAI,CAAEL,UAAU,CAACqB,eADT,CAERd,OAAO,CACN,CACCJ,EAAE,CAAFA,EADD,CAECF,MAAM,CAAEmB,MAFT,CAHO,CAAD,CAAR,CAXM,sDAAP,+DAoBA,CAvBM","sourcesContent":["import { Dispatch } from \"react\";\r\nimport { ActionType } from \"../action-types\";\r\nimport {\r\n\tAction,\r\n\tDirection,\r\n\tUpdateCellAction,\r\n\tDeleteCellAction,\r\n\tMoveCellAction,\r\n\tInsertCellAfterAction\r\n} from \"../actions\";\r\nimport { CellTypes } from \"../cell\";\r\nimport bundle from \"../../bundler\";\r\n\r\nexport const updateCell = (id: string, content: string): UpdateCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.UPDATE_CELL,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\tcontent\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const deleteCell = (id: string): DeleteCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.DELETE_CELL,\r\n\t\tpayload: id\r\n\t};\r\n};\r\n\r\nexport const moveCell = (id: string, direction: Direction): MoveCellAction => {\r\n\treturn {\r\n\t\ttype: ActionType.MOVE_CELL,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\tdirection\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const insertCellAfter = (id: string | null, cellType: CellTypes): InsertCellAfterAction => {\r\n\treturn {\r\n\t\ttype: ActionType.INSERT_CELL_AFTER,\r\n\t\tpayload:\r\n\t\t\t{\r\n\t\t\t\tid,\r\n\t\t\t\ttype: cellType\r\n\t\t\t}\r\n\t};\r\n};\r\n\r\nexport const createBundle = (id: string, input: string) => {\r\n\t// utilising redux thunk for bundling (async)\r\n\t// type annotation for dispatch is to make sure we only call dispatch with an actual action with a payload\r\n\treturn async (dispatch: Dispatch<Action>) => {\r\n\t\tdispatch({\r\n\t\t\ttype: ActionType.BUNDLE_START,\r\n\t\t\tpayload:\r\n\t\t\t\t{\r\n\t\t\t\t\tid\r\n\t\t\t\t}\r\n\t\t});\r\n\r\n\t\tconst result = await bundle(input);\r\n\r\n\t\tdispatch({\r\n\t\t\ttype: ActionType.BUNDLE_COMPLETE,\r\n\t\t\tpayload:\r\n\t\t\t\t{\r\n\t\t\t\t\tid,\r\n\t\t\t\t\tbundle: result\r\n\t\t\t\t}\r\n\t\t});\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}