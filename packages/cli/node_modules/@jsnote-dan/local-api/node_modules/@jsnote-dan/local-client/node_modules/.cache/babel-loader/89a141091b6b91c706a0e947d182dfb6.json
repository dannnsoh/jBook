{"ast":null,"code":"import produce from \"immer\";\nimport { ActionType } from \"../action-types\";\nconst initialState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {}\n};\n\nconst reducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  // draft is a proxy to the original state that can be safely mutated\n  return produce(state, draft => {\n    switch (action.type) {\n      case ActionType.SAVE_CELLS_ERROR:\n        draft.error = action.payload;\n        return draft;\n\n      case ActionType.FETCH_CELLS:\n        draft.loading = true;\n        draft.error = null;\n        return draft;\n\n      case ActionType.FETCH_CELLS_COMPLETE:\n        draft.order = action.payload.map(cell => cell.id);\n        draft.data = action.payload.reduce((acc, cell) => {\n          // data = { key(cell.id): cell(cell with id, type, content) }\n          acc[cell.id] = cell;\n          return acc;\n        }, {});\n        return draft;\n\n      case ActionType.FETCH_CELLS_ERROR:\n        draft.loading = false;\n        draft.error = action.payload;\n        return draft;\n\n      case ActionType.UPDATE_CELL:\n        const {\n          id,\n          content\n        } = action.payload;\n        draft.data[id].content = content;\n        return draft;\n\n      case ActionType.DELETE_CELL:\n        // delete cell\n        delete draft.data[action.payload]; // delete cell id from order array\n\n        draft.order = draft.order.filter(id => id !== action.payload);\n        return draft;\n\n      case ActionType.MOVE_CELL:\n        const {\n          direction\n        } = action.payload; // index of cell\n\n        const index = draft.order.findIndex(id => id === action.payload.id); // new index of cell depending on move direction\n\n        const targetId = direction === \"up\" ? index - 1 : index + 1; // ensure new index is within bounds of order array\n\n        if (targetId < 0 || targetId > draft.order.length - 1) {\n          return draft;\n        } // swap\n\n\n        draft.order[index] = draft.order[targetId];\n        draft.order[targetId] = action.payload.id;\n        return draft;\n\n      case ActionType.INSERT_CELL_AFTER:\n        const cell = {\n          id: randomId(),\n          type: action.payload.type,\n          content: \"\"\n        }; // insert cell into data array, which contains all the cells and their ids\n\n        draft.data[cell.id] = cell; // find index of cell to insert after\n\n        const foundIndex = draft.order.findIndex(id => id === action.payload.id); // if index is -1 (means no index was found for that id), add cell to start of order array\n\n        if (foundIndex === -1) {\n          draft.order.unshift(cell.id);\n        } else {\n          draft.order.splice(foundIndex + 1, 0, cell.id);\n        }\n\n        return draft;\n\n      default:\n        return draft;\n    }\n  });\n};\n\nconst randomId = () => {\n  return Math.random().toString(36).substr(2, 5);\n};\n\nexport default reducer;","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/src/state/reducers/cellsReducer.ts"],"names":["produce","ActionType","initialState","loading","error","order","data","reducer","state","action","draft","type","SAVE_CELLS_ERROR","payload","FETCH_CELLS","FETCH_CELLS_COMPLETE","map","cell","id","reduce","acc","FETCH_CELLS_ERROR","UPDATE_CELL","content","DELETE_CELL","filter","MOVE_CELL","direction","index","findIndex","targetId","length","INSERT_CELL_AFTER","randomId","foundIndex","unshift","splice","Math","random","toString","substr"],"mappings":"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","sourcesContent":["import produce from \"immer\";\r\nimport { ActionType } from \"../action-types\";\r\nimport { Action } from \"../actions\";\r\nimport { Cell } from \"../cell\";\r\n\r\ninterface CellsState {\r\n\tloading: boolean;\r\n\terror: string | null;\r\n\torder: string[];\r\n\tdata: {\r\n\t\t[key: string]: Cell;\r\n\t};\r\n}\r\n\r\nconst initialState: CellsState = {\r\n\tloading: false,\r\n\terror: null,\r\n\torder: [],\r\n\tdata: {}\r\n};\r\n\r\nconst reducer = (state: CellsState = initialState, action: Action): CellsState => {\r\n\t// draft is a proxy to the original state that can be safely mutated\r\n\treturn produce(state, draft => {\r\n\t\tswitch (action.type) {\r\n\t\t\tcase ActionType.SAVE_CELLS_ERROR:\r\n\t\t\t\tdraft.error = action.payload;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.FETCH_CELLS:\r\n\t\t\t\tdraft.loading = true;\r\n\t\t\t\tdraft.error = null;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.FETCH_CELLS_COMPLETE:\r\n\t\t\t\tdraft.order = action.payload.map(cell => cell.id);\r\n\t\t\t\tdraft.data = action.payload.reduce(\r\n\t\t\t\t\t(acc, cell) => {\r\n\t\t\t\t\t\t// data = { key(cell.id): cell(cell with id, type, content) }\r\n\t\t\t\t\t\tacc[cell.id] = cell;\r\n\t\t\t\t\t\treturn acc;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{} as CellsState[\"data\"]\r\n\t\t\t\t);\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.FETCH_CELLS_ERROR:\r\n\t\t\t\tdraft.loading = false;\r\n\t\t\t\tdraft.error = action.payload;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.UPDATE_CELL:\r\n\t\t\t\tconst { id, content } = action.payload;\r\n\t\t\t\tdraft.data[id].content = content;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.DELETE_CELL:\r\n\t\t\t\t// delete cell\r\n\t\t\t\tdelete draft.data[action.payload];\r\n\t\t\t\t// delete cell id from order array\r\n\t\t\t\tdraft.order = draft.order.filter(id => id !== action.payload);\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.MOVE_CELL:\r\n\t\t\t\tconst { direction } = action.payload;\r\n\t\t\t\t// index of cell\r\n\t\t\t\tconst index = draft.order.findIndex(id => id === action.payload.id);\r\n\t\t\t\t// new index of cell depending on move direction\r\n\t\t\t\tconst targetId = direction === \"up\" ? index - 1 : index + 1;\r\n\t\t\t\t// ensure new index is within bounds of order array\r\n\t\t\t\tif (targetId < 0 || targetId > draft.order.length - 1) {\r\n\t\t\t\t\treturn draft;\r\n\t\t\t\t}\r\n\t\t\t\t// swap\r\n\t\t\t\tdraft.order[index] = draft.order[targetId];\r\n\t\t\t\tdraft.order[targetId] = action.payload.id;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.INSERT_CELL_AFTER:\r\n\t\t\t\tconst cell: Cell = {\r\n\t\t\t\t\tid: randomId(),\r\n\t\t\t\t\ttype: action.payload.type,\r\n\t\t\t\t\tcontent: \"\"\r\n\t\t\t\t};\r\n\t\t\t\t// insert cell into data array, which contains all the cells and their ids\r\n\t\t\t\tdraft.data[cell.id] = cell;\r\n\t\t\t\t// find index of cell to insert after\r\n\t\t\t\tconst foundIndex = draft.order.findIndex(id => id === action.payload.id);\r\n\t\t\t\t// if index is -1 (means no index was found for that id), add cell to start of order array\r\n\t\t\t\tif (foundIndex === -1) {\r\n\t\t\t\t\tdraft.order.unshift(cell.id);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdraft.order.splice(foundIndex + 1, 0, cell.id);\r\n\t\t\t\t}\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\treturn draft;\r\n\t\t}\r\n\t});\r\n};\r\n\r\nconst randomId = () => {\r\n\treturn Math.random().toString(36).substr(2, 5);\r\n};\r\n\r\nexport default reducer;\r\n"]},"metadata":{},"sourceType":"module"}