{"ast":null,"code":"export const unpkgPathPlugin = () => {\n  return {\n    // name is mainly to identify this plugin for debugging purposes\n    name: \"unpkg-path-plugin\",\n\n    // setup of bundling process\n    setup(build) {\n      // onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\n      // can have multiple onResolve functions for different types of files, with the regex filter changing to look for the different types of files\n      // return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\n      // namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\n      // handle root entry file of index.js\n      build.onResolve({\n        filter: /(^index\\.js$)/\n      }, () => {\n        return {\n          path: \"index.js\",\n          namespace: \"a\"\n        };\n      }); // handle relative paths in a module\n\n      build.onResolve({\n        filter: /^\\.+\\//\n      }, async args => {\n        return {\n          namespace: \"a\",\n          path: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\n        };\n      }); // handle main file of a module\n\n      build.onResolve({\n        filter: /.*/\n      }, async args => {\n        return {\n          namespace: \"a\",\n          path: `https://unpkg.com/${args.path}`\n        };\n      }); // onLoad event listener (override esbuild's default file loading process)\n\n      build.onLoad({\n        filter: /.*/\n      }, async args => {\n        if (args.path === \"index.js\") {\n          return {\n            loader: \"jsx\",\n            contents: inputCode\n          };\n        } // Check to see if this file has already been fetched and if it is in the cache\n\n\n        const cachedResult = await fileCache.getItem(args.path); // If it is, return it immediately\n\n        if (cachedResult) {\n          return cachedResult;\n        } else {\n          // axios get request to path\n          const {\n            data,\n            request\n          } = await axios.get(args.path);\n          const result = {\n            loader: \"jsx\",\n            contents: data,\n            resolveDir: new URL(\"./\", request.responseURL).pathname\n          }; // store response in cache\n\n          await fileCache.setItem(args.path, result);\n          return result;\n        }\n      });\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/Udemy/React and Typescript (Stephen Grider)/jbook/src/plugins/unpkg-path-plugin.ts"],"names":["unpkgPathPlugin","name","setup","build","onResolve","filter","path","namespace","args","URL","resolveDir","href","onLoad","loader","contents","inputCode","cachedResult","fileCache","getItem","data","request","axios","get","result","responseURL","pathname","setItem"],"mappings":"AAEA,OAAO,MAAMA,eAAe,GAAG,MAAM;AACpC,SAAO;AACN;AACAC,IAAAA,IAAI,EAAE,mBAFA;;AAGN;AACAC,IAAAA,KAAK,CAACC,KAAD,EAA6B;AACjC;AACA;AACA;AACA;AAEA;AACAA,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAA6C,MAAM;AAClD,eAAO;AAAEC,UAAAA,IAAI,EAAE,UAAR;AAAoBC,UAAAA,SAAS,EAAE;AAA/B,SAAP;AACA,OAFD,EAPiC,CAWjC;;AACAJ,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAAsC,MAAOG,IAAP,IAAqB;AAC1D,eAAO;AACND,UAAAA,SAAS,EAAE,GADL;AAEND,UAAAA,IAAI,EAAE,IAAIG,GAAJ,CAAQD,IAAI,CAACF,IAAb,EAAoB,oBAAmBE,IAAI,CAACE,UAAW,GAAvD,EAA2DC;AAF3D,SAAP;AAIA,OALD,EAZiC,CAkBjC;;AACAR,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAAkC,MAAOG,IAAP,IAAqB;AACtD,eAAO;AACND,UAAAA,SAAS,EAAE,GADL;AAEND,UAAAA,IAAI,EAAG,qBAAoBE,IAAI,CAACF,IAAK;AAF/B,SAAP;AAIA,OALD,EAnBiC,CA0BjC;;AACAH,MAAAA,KAAK,CAACS,MAAN,CAAa;AAAEP,QAAAA,MAAM,EAAE;AAAV,OAAb,EAA+B,MAAOG,IAAP,IAAqB;AACnD,YAAIA,IAAI,CAACF,IAAL,KAAc,UAAlB,EAA8B;AAC7B,iBAAO;AACNO,YAAAA,MAAM,EAAE,KADF;AAENC,YAAAA,QAAQ,EAAEC;AAFJ,WAAP;AAIA,SANkD,CAQnD;;;AACA,cAAMC,YAAY,GAAG,MAAMC,SAAS,CAACC,OAAV,CAAwCV,IAAI,CAACF,IAA7C,CAA3B,CATmD,CAUnD;;AACA,YAAIU,YAAJ,EAAkB;AACjB,iBAAOA,YAAP;AACA,SAFD,MAEO;AACN;AACA,gBAAM;AAAEG,YAAAA,IAAF;AAAQC,YAAAA;AAAR,cAAoB,MAAMC,KAAK,CAACC,GAAN,CAAUd,IAAI,CAACF,IAAf,CAAhC;AACA,gBAAMiB,MAA4B,GAAG;AACpCV,YAAAA,MAAM,EAAE,KAD4B;AAEpCC,YAAAA,QAAQ,EAAEK,IAF0B;AAGpCT,YAAAA,UAAU,EAAE,IAAID,GAAJ,CAAQ,IAAR,EAAcW,OAAO,CAACI,WAAtB,EAAmCC;AAHX,WAArC,CAHM,CAQN;;AACA,gBAAMR,SAAS,CAACS,OAAV,CAAkBlB,IAAI,CAACF,IAAvB,EAA6BiB,MAA7B,CAAN;AACA,iBAAOA,MAAP;AACA;AACD,OAzBD;AA0BA;;AAzDK,GAAP;AA2DA,CA5DM","sourcesContent":["import * as esbuild from \"esbuild-wasm\";\r\n\r\nexport const unpkgPathPlugin = () => {\r\n\treturn {\r\n\t\t// name is mainly to identify this plugin for debugging purposes\r\n\t\tname: \"unpkg-path-plugin\",\r\n\t\t// setup of bundling process\r\n\t\tsetup(build: esbuild.PluginBuild) {\r\n\t\t\t// onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\r\n\t\t\t// can have multiple onResolve functions for different types of files, with the regex filter changing to look for the different types of files\r\n\t\t\t// return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\r\n\t\t\t// namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\r\n\r\n\t\t\t// handle root entry file of index.js\r\n\t\t\tbuild.onResolve({ filter: /(^index\\.js$)/ }, () => {\r\n\t\t\t\treturn { path: \"index.js\", namespace: \"a\" };\r\n\t\t\t});\r\n\r\n\t\t\t// handle relative paths in a module\r\n\t\t\tbuild.onResolve({ filter: /^\\.+\\// }, async (args: any) => {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\tpath: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\t// handle main file of a module\r\n\t\t\tbuild.onResolve({ filter: /.*/ }, async (args: any) => {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\tpath: `https://unpkg.com/${args.path}`\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t\t// onLoad event listener (override esbuild's default file loading process)\r\n\t\t\tbuild.onLoad({ filter: /.*/ }, async (args: any) => {\r\n\t\t\t\tif (args.path === \"index.js\") {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents: inputCode\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check to see if this file has already been fetched and if it is in the cache\r\n\t\t\t\tconst cachedResult = await fileCache.getItem<esbuild.OnLoadResult>(args.path);\r\n\t\t\t\t// If it is, return it immediately\r\n\t\t\t\tif (cachedResult) {\r\n\t\t\t\t\treturn cachedResult;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// axios get request to path\r\n\t\t\t\t\tconst { data, request } = await axios.get(args.path);\r\n\t\t\t\t\tconst result: esbuild.OnLoadResult = {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents: data,\r\n\t\t\t\t\t\tresolveDir: new URL(\"./\", request.responseURL).pathname\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// store response in cache\r\n\t\t\t\t\tawait fileCache.setItem(args.path, result);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}