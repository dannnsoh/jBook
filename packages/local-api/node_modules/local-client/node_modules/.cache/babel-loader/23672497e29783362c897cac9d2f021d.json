{"ast":null,"code":"import axios from \"axios\";\nimport localforage from \"localforage\";\nconst fileCache = localforage.createInstance({\n  name: \"filecache\"\n});\nexport const unpkgPathPlugin = () => {\n  return {\n    // name is mainly to identify this plugin for debugging purposes\n    name: \"unpkg-path-plugin\",\n\n    // setup of bundling process\n    setup(build) {\n      // onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\n      // can have multiple onResolve listeners for different types of files, with the regex filter changing to look for the different types of files\n      // return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\n      // namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\n      build.onResolve({\n        filter: /.*/\n      }, async args => {\n        console.log(\"onResolve\", args);\n\n        if (args.path === \"index.js\") {\n          return {\n            path: args.path,\n            namespace: \"a\"\n          };\n        }\n\n        if (args.path.includes(\"./\") || args.path.includes(\"../\")) {\n          return {\n            namespace: \"a\",\n            path: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\n          };\n        }\n\n        return {\n          namespace: \"a\",\n          path: `https://unpkg.com/${args.path}`\n        };\n      }); // onLoad event listener (override esbuild's default file loading process)\n\n      build.onLoad({\n        filter: /.*/\n      }, async args => {\n        console.log(\"onLoad\", args);\n\n        if (args.path === \"index.js\") {\n          return {\n            loader: \"jsx\",\n            contents: `\n                            import React, { useState } from \"react-select\";\n                            console.log(React, useState);\n                        `\n          };\n        } // Check to see if this file has already been fetched and if it is in the cache\n\n\n        const cachedResult = await fileCache.getItem(args.path); // If it is, return it immediately\n\n        if (cachedResult) {\n          return cachedResult;\n        } else {\n          const {\n            data,\n            request\n          } = await axios.get(args.path);\n          const result = {\n            loader: \"jsx\",\n            contents: data,\n            resolveDir: new URL(\"./\", request.responseURL).pathname\n          }; // store response in cache\n\n          await fileCache.setItem(args.path, result);\n          return result;\n        }\n      });\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/Udemy/React and Typescript (Stephen Grider)/jbook/src/plugins/unpkg-path-plugin.ts"],"names":["axios","localforage","fileCache","createInstance","name","unpkgPathPlugin","setup","build","onResolve","filter","args","console","log","path","namespace","includes","URL","resolveDir","href","onLoad","loader","contents","cachedResult","getItem","data","request","get","result","responseURL","pathname","setItem"],"mappings":"AACA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,WAAP,MAAwB,aAAxB;AAEA,MAAMC,SAAS,GAAGD,WAAW,CAACE,cAAZ,CAA2B;AAC5CC,EAAAA,IAAI,EAAE;AADsC,CAA3B,CAAlB;AAIA,OAAO,MAAMC,eAAe,GAAG,MAAM;AACpC,SAAO;AACN;AACAD,IAAAA,IAAI,EAAE,mBAFA;;AAGN;AACAE,IAAAA,KAAK,CAACC,KAAD,EAA6B;AACjC;AACA;AACA;AACA;AACAA,MAAAA,KAAK,CAACC,SAAN,CAAgB;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAhB,EAAkC,MAAOC,IAAP,IAAqB;AACtDC,QAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBF,IAAzB;;AACA,YAAIA,IAAI,CAACG,IAAL,KAAc,UAAlB,EAA8B;AAC7B,iBAAO;AAAEA,YAAAA,IAAI,EAAEH,IAAI,CAACG,IAAb;AAAmBC,YAAAA,SAAS,EAAE;AAA9B,WAAP;AACA;;AAED,YAAIJ,IAAI,CAACG,IAAL,CAAUE,QAAV,CAAmB,IAAnB,KAA4BL,IAAI,CAACG,IAAL,CAAUE,QAAV,CAAmB,KAAnB,CAAhC,EAA2D;AAC1D,iBAAO;AACND,YAAAA,SAAS,EAAE,GADL;AAEND,YAAAA,IAAI,EAAE,IAAIG,GAAJ,CAAQN,IAAI,CAACG,IAAb,EAAoB,oBAAmBH,IAAI,CAACO,UAAW,GAAvD,EAA2DC;AAF3D,WAAP;AAIA;;AAED,eAAO;AACNJ,UAAAA,SAAS,EAAE,GADL;AAEND,UAAAA,IAAI,EAAG,qBAAoBH,IAAI,CAACG,IAAK;AAF/B,SAAP;AAIA,OAjBD,EALiC,CAuBjC;;AACAN,MAAAA,KAAK,CAACY,MAAN,CAAa;AAAEV,QAAAA,MAAM,EAAE;AAAV,OAAb,EAA+B,MAAOC,IAAP,IAA0B;AACxDC,QAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAAsBF,IAAtB;;AACA,YAAIA,IAAI,CAACG,IAAL,KAAc,UAAlB,EAA8B;AAC7B,iBAAO;AACNO,YAAAA,MAAM,EAAE,KADF;AAENC,YAAAA,QAAQ,EACN;AACR;AACA;AACA;AANY,WAAP;AAQA,SAXuD,CAaxD;;;AACA,cAAMC,YAAY,GAAG,MAAMpB,SAAS,CAACqB,OAAV,CAAkBb,IAAI,CAACG,IAAvB,CAA3B,CAdwD,CAexD;;AACA,YAAIS,YAAJ,EAAkB;AACjB,iBAAOA,YAAP;AACA,SAFD,MAEO;AACN,gBAAM;AAAEE,YAAAA,IAAF;AAAQC,YAAAA;AAAR,cAAyB,MAAMzB,KAAK,CAAC0B,GAAN,CAAUhB,IAAI,CAACG,IAAf,CAArC;AACA,gBAAMc,MAAM,GAAG;AACdP,YAAAA,MAAM,EAAE,KADM;AAEdC,YAAAA,QAAQ,EAAEG,IAFI;AAGdP,YAAAA,UAAU,EAAE,IAAID,GAAJ,CAAQ,IAAR,EAAcS,OAAO,CAACG,WAAtB,EAAmCC;AAHjC,WAAf,CAFM,CAON;;AACA,gBAAM3B,SAAS,CAAC4B,OAAV,CAAkBpB,IAAI,CAACG,IAAvB,EAA6Bc,MAA7B,CAAN;AACA,iBAAOA,MAAP;AACA;AACD,OA7BD;AA8BA;;AA1DK,GAAP;AA4DA,CA7DM","sourcesContent":["import * as esbuild from \"esbuild-wasm\";\r\nimport axios from \"axios\";\r\nimport localforage from \"localforage\";\r\n\r\nconst fileCache = localforage.createInstance({\r\n\tname: \"filecache\"\r\n});\r\n\r\nexport const unpkgPathPlugin = () => {\r\n\treturn {\r\n\t\t// name is mainly to identify this plugin for debugging purposes\r\n\t\tname: \"unpkg-path-plugin\",\r\n\t\t// setup of bundling process\r\n\t\tsetup(build: esbuild.PluginBuild) {\r\n\t\t\t// onResolve event listener (override esbuild's default process of figuring out where the main file is stored)\r\n\t\t\t// can have multiple onResolve listeners for different types of files, with the regex filter changing to look for the different types of files\r\n\t\t\t// return path to where the main file is stored (in this case, index.js as defined in the \"entry point\")\r\n\t\t\t// namespace is an \"identifier\" which can be used in onLoad to apply the onLoad function to only the files with the specified namespace\r\n\t\t\tbuild.onResolve({ filter: /.*/ }, async (args: any) => {\r\n\t\t\t\tconsole.log(\"onResolve\", args);\r\n\t\t\t\tif (args.path === \"index.js\") {\r\n\t\t\t\t\treturn { path: args.path, namespace: \"a\" };\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (args.path.includes(\"./\") || args.path.includes(\"../\")) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\t\tpath: new URL(args.path, `https://unpkg.com${args.resolveDir}/`).href\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnamespace: \"a\",\r\n\t\t\t\t\tpath: `https://unpkg.com/${args.path}`\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\t// onLoad event listener (override esbuild's default file loading process)\r\n\t\t\tbuild.onLoad({ filter: /.*/ }, async (args: any): any => {\r\n\t\t\t\tconsole.log(\"onLoad\", args);\r\n\t\t\t\tif (args.path === \"index.js\") {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents:\r\n\t\t\t\t\t\t\t`\r\n                            import React, { useState } from \"react-select\";\r\n                            console.log(React, useState);\r\n                        `\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check to see if this file has already been fetched and if it is in the cache\r\n\t\t\t\tconst cachedResult = await fileCache.getItem(args.path);\r\n\t\t\t\t// If it is, return it immediately\r\n\t\t\t\tif (cachedResult) {\r\n\t\t\t\t\treturn cachedResult;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst { data, request }: any = await axios.get(args.path);\r\n\t\t\t\t\tconst result = {\r\n\t\t\t\t\t\tloader: \"jsx\",\r\n\t\t\t\t\t\tcontents: data,\r\n\t\t\t\t\t\tresolveDir: new URL(\"./\", request.responseURL).pathname\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// store response in cache\r\n\t\t\t\t\tawait fileCache.setItem(args.path, result);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n};\r\n"]},"metadata":{},"sourceType":"module"}