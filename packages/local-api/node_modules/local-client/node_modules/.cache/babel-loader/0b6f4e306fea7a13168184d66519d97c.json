{"ast":null,"code":"import produce from\"immer\";import{ActionType}from\"../action-types\";var initialState={loading:false,error:null,order:[],data:{}};var reducer=function reducer(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:initialState;var action=arguments.length>1?arguments[1]:undefined;return produce(state,function(draft){switch(action.type){case ActionType.UPDATE_CELL:var _action$payload=action.payload,id=_action$payload.id,content=_action$payload.content;draft.data[id].content=content;return draft;case ActionType.DELETE_CELL:// delete cell\ndelete draft.data[action.payload];// delete cell id from order array\ndraft.order=draft.order.filter(function(id){return id!==action.payload;});return draft;case ActionType.MOVE_CELL:var direction=action.payload.direction;// index of cell\nvar index=draft.order.findIndex(function(id){return id===action.payload.id;});// new index of cell depending on move direction\nvar targetId=direction===\"up\"?index-1:index+1;// ensure new index is within bounds of order array\nif(targetId<0||targetId>draft.order.length-1){return draft;}// swap\ndraft.order[index]=draft.order[targetId];draft.order[targetId]=action.payload.id;return draft;case ActionType.INSERT_CELL_AFTER:var cell={id:randomId(),type:action.payload.type,content:\"\"};// insert cell into data array, which contains all the cells and their ids\ndraft.data[cell.id]=cell;// find index of cell to insert after\nvar foundIndex=draft.order.findIndex(function(id){return id===action.payload.id;});// if index is -1 (means no index was found for that id), add cell to start of order array\nif(foundIndex===-1){draft.order.unshift(cell.id);}else{draft.order.splice(foundIndex+1,0,cell.id);}return draft;default:return draft;}});};var randomId=function randomId(){return Math.random().toString(36).substr(2,5);};export default reducer;","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/src/state/reducers/cellsReducer.ts"],"names":["produce","ActionType","initialState","loading","error","order","data","reducer","state","action","draft","type","UPDATE_CELL","payload","id","content","DELETE_CELL","filter","MOVE_CELL","direction","index","findIndex","targetId","length","INSERT_CELL_AFTER","cell","randomId","foundIndex","unshift","splice","Math","random","toString","substr"],"mappings":"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","sourcesContent":["import produce from \"immer\";\r\nimport { ActionType } from \"../action-types\";\r\nimport { Action } from \"../actions\";\r\nimport { Cell } from \"../cell\";\r\n\r\ninterface CellsState {\r\n\tloading: boolean;\r\n\terror: string | null;\r\n\torder: string[];\r\n\tdata: {\r\n\t\t[key: string]: Cell;\r\n\t};\r\n}\r\n\r\nconst initialState: CellsState = {\r\n\tloading: false,\r\n\terror: null,\r\n\torder: [],\r\n\tdata: {}\r\n};\r\n\r\nconst reducer = (state: CellsState = initialState, action: Action): CellsState => {\r\n\treturn produce(state, (draft) => {\r\n\t\tswitch (action.type) {\r\n\t\t\tcase ActionType.UPDATE_CELL:\r\n\t\t\t\tconst { id, content } = action.payload;\r\n\t\t\t\tdraft.data[id].content = content;\r\n\t\t\t\treturn draft;\r\n\t\t\tcase ActionType.DELETE_CELL:\r\n\t\t\t\t// delete cell\r\n\t\t\t\tdelete draft.data[action.payload];\r\n\t\t\t\t// delete cell id from order array\r\n\t\t\t\tdraft.order = draft.order.filter((id) => id !== action.payload);\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.MOVE_CELL:\r\n\t\t\t\tconst { direction } = action.payload;\r\n\t\t\t\t// index of cell\r\n\t\t\t\tconst index = draft.order.findIndex((id) => id === action.payload.id);\r\n\t\t\t\t// new index of cell depending on move direction\r\n\t\t\t\tconst targetId = direction === \"up\" ? index - 1 : index + 1;\r\n\t\t\t\t// ensure new index is within bounds of order array\r\n\t\t\t\tif (targetId < 0 || targetId > draft.order.length - 1) {\r\n\t\t\t\t\treturn draft;\r\n\t\t\t\t}\r\n\t\t\t\t// swap\r\n\t\t\t\tdraft.order[index] = draft.order[targetId];\r\n\t\t\t\tdraft.order[targetId] = action.payload.id;\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tcase ActionType.INSERT_CELL_AFTER:\r\n\t\t\t\tconst cell: Cell = {\r\n\t\t\t\t\tid: randomId(),\r\n\t\t\t\t\ttype: action.payload.type,\r\n\t\t\t\t\tcontent: \"\"\r\n\t\t\t\t};\r\n\t\t\t\t// insert cell into data array, which contains all the cells and their ids\r\n\t\t\t\tdraft.data[cell.id] = cell;\r\n\t\t\t\t// find index of cell to insert after\r\n\t\t\t\tconst foundIndex = draft.order.findIndex((id) => id === action.payload.id);\r\n\t\t\t\t// if index is -1 (means no index was found for that id), add cell to start of order array\r\n\t\t\t\tif (foundIndex === -1) {\r\n\t\t\t\t\tdraft.order.unshift(cell.id);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdraft.order.splice(foundIndex + 1, 0, cell.id);\r\n\t\t\t\t}\r\n\t\t\t\treturn draft;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\treturn draft;\r\n\t\t}\r\n\t});\r\n};\r\n\r\nconst randomId = () => {\r\n\treturn Math.random().toString(36).substr(2, 5);\r\n};\r\n\r\nexport default reducer;\r\n"]},"metadata":{},"sourceType":"module"}