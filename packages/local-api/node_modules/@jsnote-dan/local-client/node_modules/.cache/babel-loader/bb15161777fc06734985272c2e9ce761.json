{"ast":null,"code":"/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array<Range>} Ranges\n */\n\n/**\n * @callback Check\n * @param {Tag} tag\n * @param {Range} range\n * @returns {boolean}\n */\n\n/**\n * @callback Filter\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * @callback Lookup\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @type {{\n *   (check: Check, filter: true): Filter\n *   (check: Check, filter?: false): Lookup\n * }}\n */\n// prettier-ignore\nconst factory =\n/**\n * @param {Check} check\n * @param {boolean} [filter=false]\n */\nfunction (check, filter) {\n  return match;\n  /**\n   * @param {Tag|Tags} tags\n   * @param {Range|Ranges} [ranges='*']\n   * @returns {Tag|Tags|undefined}\n   */\n\n  function match(tags, ranges) {\n    let left = cast(tags, 'tag');\n    const right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n\n    const matches = [];\n    let rightIndex = -1;\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\n\n      if (!filter && range === '*') continue;\n      let leftIndex = -1;\n      /** @type {Tags} */\n\n      const next = [];\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) return left[leftIndex];\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n\n      left = next;\n    } // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n\n\n    return filter ? matches : undefined;\n  }\n};\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\n\n\nexport const basicFilter = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\n\nexport const extendedFilter = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-');\n  const right = range.split('-');\n  let leftIndex = 0;\n  let rightIndex = 0; // 3.3.2.2\n\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n\n  leftIndex++;\n  rightIndex++; // 3.3.2.3\n\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.B\n\n\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\n\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.D\n\n\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\n\n    leftIndex++;\n  } // 3.3.2.4\n\n\n  return true;\n}, true);\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\nexport const lookup = factory(\n/** @type {Check} */\nfunction (tag, range) {\n  let right = range;\n  /* eslint-disable-next-line no-constant-condition */\n\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    let index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n});\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\n\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values;\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n\n  return value;\n}","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/packages/local-client/node_modules/bcp-47-match/index.js"],"names":["factory","check","filter","match","tags","ranges","left","cast","right","undefined","matches","rightIndex","length","range","toLowerCase","leftIndex","next","push","basicFilter","tag","includes","extendedFilter","split","lookup","index","lastIndexOf","charAt","slice","values","name","value","Error"],"mappings":"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","sourcesContent":["/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array<Range>} Ranges\n */\n\n/**\n * @callback Check\n * @param {Tag} tag\n * @param {Range} range\n * @returns {boolean}\n */\n\n/**\n * @callback Filter\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * @callback Lookup\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @type {{\n *   (check: Check, filter: true): Filter\n *   (check: Check, filter?: false): Lookup\n * }}\n */\n// prettier-ignore\nconst factory = (\n  /**\n   * @param {Check} check\n   * @param {boolean} [filter=false]\n   */\n  function (check, filter) {\n    return match\n\n    /**\n     * @param {Tag|Tags} tags\n     * @param {Range|Ranges} [ranges='*']\n     * @returns {Tag|Tags|undefined}\n     */\n    function match(tags, ranges) {\n      let left = cast(tags, 'tag')\n      const right = cast(\n        ranges === null || ranges === undefined ? '*' : ranges,\n        'range'\n      )\n      /** @type {Tags} */\n      const matches = []\n      let rightIndex = -1\n\n      while (++rightIndex < right.length) {\n        const range = right[rightIndex].toLowerCase()\n\n        // Ignore wildcards in lookup mode.\n        if (!filter && range === '*') continue\n\n        let leftIndex = -1\n        /** @type {Tags} */\n        const next = []\n\n        while (++leftIndex < left.length) {\n          if (check(left[leftIndex].toLowerCase(), range)) {\n            // Exit if this is a lookup and we have a match.\n            if (!filter) return left[leftIndex]\n            matches.push(left[leftIndex])\n          } else {\n            next.push(left[leftIndex])\n          }\n        }\n\n        left = next\n      }\n\n      // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n      // a match, so return `undefined`.\n      return filter ? matches : undefined\n    }\n  }\n)\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport const basicFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    return range === '*' || tag === range || tag.includes(range + '-')\n  },\n  true\n)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport const extendedFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    // 3.3.2.1\n    const left = tag.split('-')\n    const right = range.split('-')\n    let leftIndex = 0\n    let rightIndex = 0\n\n    // 3.3.2.2\n    if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n      return false\n    }\n\n    leftIndex++\n    rightIndex++\n\n    // 3.3.2.3\n    while (rightIndex < right.length) {\n      // 3.3.2.3.A\n      if (right[rightIndex] === '*') {\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.B\n      if (!left[leftIndex]) return false\n\n      // 3.3.2.3.C\n      if (left[leftIndex] === right[rightIndex]) {\n        leftIndex++\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.D\n      if (left[leftIndex].length === 1) return false\n\n      // 3.3.2.3.E\n      leftIndex++\n    }\n\n    // 3.3.2.4\n    return true\n  },\n  true\n)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\nexport const lookup = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    let right = range\n\n    /* eslint-disable-next-line no-constant-condition */\n    while (true) {\n      if (right === '*' || tag === right) return true\n\n      let index = right.lastIndexOf('-')\n\n      if (index < 0) return false\n\n      if (right.charAt(index - 2) === '-') index -= 2\n\n      right = right.slice(0, index)\n    }\n  }\n)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}