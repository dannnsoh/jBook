{"ast":null,"code":"export function selectWord(_ref) {\n  var {\n    text,\n    selection\n  } = _ref;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10; // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n\n\n  var start = 0; // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n\n  var end = text.length; // iterate to the left\n\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  } // iterate to the right\n\n\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n\n  return {\n    start,\n    end\n  };\n}","map":{"version":3,"sources":["../../src/utils/markdownUtils.ts"],"names":["selection","text","getSurroundingWord","startPosition","neededBreaks","isInFirstLine","i","isInLastLine","Error","isWordDelimiter","c","start","end"],"mappings":"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","sourcesContent":["import { TextRange } from '../commands';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexport function getSurroundingWord(text: string, position: number): TextRange {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  const isWordDelimiter = (c: string) => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  let start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  let end = text.length;\n\n  // iterate to the left\n  for (let i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (let i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return { start, end };\n}\n"]},"metadata":{},"sourceType":"module"}