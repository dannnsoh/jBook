{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\nimport { zwitch } from 'zwitch';\nimport { enterState } from './enter-state.js';\nimport { parent, element } from './util.js';\nconst own = {}.hasOwnProperty;\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan,\n  // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant,\n    // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n});\n/** @type {Handler} */\n\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state);\n} // Shouldn’t be called, parser gives correct data.\n\n/* c8 ignore next 6 */\n\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\n\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`');\n}\n/** @type {Handler} */\n\n\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node');\n  } // Shouldn’t happen.\n\n  /* c8 ignore next 3 */\n\n\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`');\n  }\n\n  state.iterator(query, node, index, parent, state);\n  if (!state.shallow) descendant(query, node, index, parent, state);\n}\n/** @type {Handler} */\n\n\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator;\n  state.iterator = iterator;\n  child(query, node, index, parent, state);\n  /** @type {SelectIterator} */\n\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`');\n    }\n\n    state.iterator = previous;\n    previous(query, node, index, parent, state);\n    state.iterator = iterator;\n    if (state.one && state.found) return;\n    child(query, node, index, parent, state);\n  }\n}\n/** @type {Handler} */\n\n\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return;\n  if (node.children.length === 0) return;\n  indexedSearch(query, node, state);\n}\n/** @type {Handler} */\n\n\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1, true);\n}\n/** @type {Handler} */\n\n\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1);\n}\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\n\n\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add;\n  const children = parent.children;\n  let elements = 0;\n  let index = -1;\n  /** @type {Object.<string, number>} */\n\n  const types = {};\n  /** @type {Array.<Function>} */\n\n  const delayed = []; // Start looking at `from`\n\n  if (from === undefined || from === null) from = 0; // Exit if there are no further nodes.\n\n  if (from >= children.length) return; // If we need to index for types, do so for all elements before `from`.\n\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index];\n      if (element(child)) count(child.tagName);\n    }\n  }\n\n  index = from - 1;\n\n  while (++index < children.length) {\n    const child = children[index]; // Only check elements.\n    // Check either all elements, or only check the first sibling\n\n    if (element(child)) {\n      handle(child, index); // Stop if we’re looking for one node and it’s already found.\n\n      if (state.one && state.found) return;\n      if (firstElementOnly) break;\n    }\n  }\n\n  if (state.index) {\n    index = -1;\n\n    while (++index < delayed.length) {\n      delayed[index]();\n      if (state.one && state.found) return;\n    }\n  }\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n\n\n  function delay(node, childIndex) {\n    const elementsBefore = elements;\n    const elementsByTypeBefore = own.call(types, node.tagName) ? types[node.tagName] : 0;\n    count(node.tagName);\n    delayed.push(fn);\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore;\n      state.typeIndex = elementsByTypeBefore; // After counting all elements.\n\n      state.elementCount = elements;\n      state.typeCount = types[node.tagName];\n      add(node, childIndex);\n    }\n  }\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n\n\n  function add(node, childIndex) {\n    const exit = enterState(state, node); // Shouldn’t happen.\n\n    /* c8 ignore next 3 */\n\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`');\n    }\n\n    state.iterator(query, node, childIndex, parent, state);\n    exit();\n  }\n  /**\n   * @param {string} name\n   */\n\n\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0;\n    elements++;\n    types[name]++;\n  }\n}","map":{"version":3,"sources":["C:/Users/Ryzen/Desktop/jbook/node_modules/hast-util-select/lib/nest.js"],"names":["zwitch","enterState","parent","element","own","hasOwnProperty","handle","unknown","unknownNesting","invalid","topScan","handlers","null","descendant","child","adjacentSibling","generalSibling","nest","query","node","index","state","Error","nestingOperator","iterator","shallow","previous","one","found","_1","_2","children","length","indexedSearch","_","from","firstElementOnly","delay","add","elements","types","delayed","undefined","count","tagName","childIndex","elementsBefore","elementsByTypeBefore","call","push","fn","elementIndex","typeIndex","elementCount","typeCount","exit","name"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\n\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {parent, element} from './util.js'\n\nconst own = {}.hasOwnProperty\n\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan, // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant, // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n})\n\n/** @type {Handler} */\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state)\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')\n}\n\n/** @type {Handler} */\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node')\n  }\n\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`')\n  }\n\n  state.iterator(query, node, index, parent, state)\n  if (!state.shallow) descendant(query, node, index, parent, state)\n}\n\n/** @type {Handler} */\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator\n\n  state.iterator = iterator\n  child(query, node, index, parent, state)\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator = previous\n    previous(query, node, index, parent, state)\n    state.iterator = iterator\n\n    if (state.one && state.found) return\n\n    child(query, node, index, parent, state)\n  }\n}\n\n/** @type {Handler} */\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return\n  if (node.children.length === 0) return\n  indexedSearch(query, node, state)\n}\n\n/** @type {Handler} */\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1, true)\n}\n\n/** @type {Handler} */\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1)\n}\n\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add\n  const children = parent.children\n  let elements = 0\n  let index = -1\n  /** @type {Object.<string, number>} */\n  const types = {}\n  /** @type {Array.<Function>} */\n  const delayed = []\n\n  // Start looking at `from`\n  if (from === undefined || from === null) from = 0\n\n  // Exit if there are no further nodes.\n  if (from >= children.length) return\n\n  // If we need to index for types, do so for all elements before `from`.\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index]\n      if (element(child)) count(child.tagName)\n    }\n  }\n\n  index = from - 1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Only check elements.\n    // Check either all elements, or only check the first sibling\n    if (element(child)) {\n      handle(child, index)\n\n      // Stop if we’re looking for one node and it’s already found.\n      if (state.one && state.found) return\n      if (firstElementOnly) break\n    }\n  }\n\n  if (state.index) {\n    index = -1\n\n    while (++index < delayed.length) {\n      delayed[index]()\n      if (state.one && state.found) return\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function delay(node, childIndex) {\n    const elementsBefore = elements\n    const elementsByTypeBefore = own.call(types, node.tagName)\n      ? types[node.tagName]\n      : 0\n\n    count(node.tagName)\n\n    delayed.push(fn)\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore\n      state.typeIndex = elementsByTypeBefore\n\n      // After counting all elements.\n      state.elementCount = elements\n      state.typeCount = types[node.tagName]\n\n      add(node, childIndex)\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function add(node, childIndex) {\n    const exit = enterState(state, node)\n\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator(query, node, childIndex, parent, state)\n    exit()\n  }\n\n  /**\n   * @param {string} name\n   */\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0\n    elements++\n    types[name]++\n  }\n}\n"]},"metadata":{},"sourceType":"module"}